/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
/**
 * 
 * @name iscCore
 * @module iscCore
 * @description iscCore module provides utility methods to do basic tasks
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 */



(function () {
    'use strict';
    /** @name iscCore */
    var  iscCore = window.iscCore || (window.iscCore = {});
  
  /**
   *@module iscCore
   *@method isVoid
   *@param obj {object} String or Object to be tested for void
   *@description This method checks string or object for void. If any other types are passed it will return false
   *@returns {boolean} Returns true if string or object is void else false.
   */
  
  iscCore.isVoid = function(obj){
    if(obj === null || obj === undefined) {
			return true;
		}
    else{
      var type = "";
      if(typeof obj ==="string"){
        type = "STRING";
      }
      if(typeof obj ==="object"){
        type = "OBJECT";
      }
      if(type==="STRING" && obj.length === 0){
        return true;
      }
      else if(type==="OBJECT"){
        var count = 0;
  	    for(var prop in obj) {
	        count++;
          if(obj.hasOwnProperty && obj.hasOwnProperty(prop)){
              break;
          }
        }
        if(count === 0 ){
          return true;
        }
        else {
          return false;
        }
      }
      return false;
    }
  };
  
  /**
   * 
   *@module iscCore
   *@method getValueFromJsonPath
   *@param jsonObj {object} Json object
   *@param jsonPath {string} Json path 
   *@returns {any} Returns value from the specified path. If path not found, undefined is returned
   * 
   * 
   */
  iscCore.getValueFromJsonPath = function(jsonObj,jsonPath,create){
		var context = jsonObj,i = 0,p;
		//var create = create?create:false;
		var parts = jsonPath.split(".");
		while(context && (p = parts[i++])){
			context = (p in context ? context[p] : (create ? context[p] = {} : undefined));
		}
		return context;
	};
  
  
  /**
   * 
   *@module iscCore 
   *@method getArrayElements
   *@param array {array} Array object
   *@param start {number} Start index 
   *@param end {number} End index
   *@returns {array} Returns new array which contains array items from start and end index
   */
  
  iscCore.getArrayElements = function (array,start,end){
    var tempArray = [];
    var l = 0;
    for(var i=start;i<end;i++){
      tempArray[l++] = array[i];
    }
    return tempArray;
  };
  
  iscCore.isBooleanTrue = function(value){
	if(true === value || value === "Y" || value === "y" || value === "YES" ||
			value === "yes"){
		return true;
	}  
	else{
		return false;
	}
  };
  iscCore.isBooleanFalse = function(value){
		if(false === value || value === "N" || value === "n" || value === "NO" ||
				value === "no"){
			return true;
		}  
		else{
			return false;
		}
	  };
  
})();

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/

(function(){
  'use strict';
  angular.module('isc.shared',['ui.bootstrap','angularMoment'/*,"x1.ui.modal"*/]);  
})();

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
/*
	The core logic to format a number into a currency value has been copied from angular.js file(https://github.com/angular/angular.js). This logic has been customized to accomodate inputs such currencyCode and 'getCurrencyList' API output before the formatting is done.
*/
(function(iscCore){

	angular.module('isc.shared').filter('iscCurrency',['iscCurrencyFormat','iscAppContext', function (iscCurrencyFormat,iscAppContext) {
		
		/**
		 * @ngdoc filter
		 * @name iscCurrency
		 *
		 * @description
		 *	Formats a numeric value and returns the currency equivalent of it based on the currency code passed as input. In the example below, 
		 * 	'iscCurrency' filter is applied to a label showing ListPrice. The currency code is passed as input to the filter through 'model.itemDetails.Currency'
		 *
		 * @example
		 * <label class="comapps-label zero-width-label" ng-if="!ui.priceOverride.isPriceOverriden"
		 * 
		 * ng-bind="model.itemDetails.ComputedPrice.ListPrice | iscCurrency:model.itemDetails.Currency"></label>
		 */
  
		'use strict';
		
		function formatCurrency(amount, currencyCode,fractionSize, showAsNeg) {
			
			/**
			 * @ngdoc method
			 * @name iscCurrency#formatCurrency
			 *
			 * @param amount {Number} Amount which needs to be formatted into currency
			 * 
			 * @param currencyCode {String} Currency code to be used for formatting
			 *
			 * @param fractionSize {Number} The number of decimal places needed to be shown
			 * 
			 * @param showAsNeg {Boolean} Flag to display the number as a negative amount. Used to display Discount as a negative amount.
			 *
			 * @returns {String} The formatted currency value
			 *
			 * @description
			 * Formats the amount passed as input based on currencyCode and fractionSize and returns the formatted currency value. Merges the output from 'getCurrencyList' API and the formatting inforamtion JSON set through 'iscCurrencyFormatProvider' before formatting. Here are the possible scenarios considered by this method:
			 *
			 * 1) If currencyCode is not passed as input, return the amount without any formatting.
			 *
			 * 2) If currencyCode is not present in the API output and not in formatting inforamtion JSON, currencyCode is used as the currency symbol. Formatting for the amount is done based on the 'defaultPrefix' format.
			 *
			 * 3) If currencyCode is present in the API output and also in formatting inforamtion JSON , the symbol and prefix/postfix information from the API output is used. For the rest of formatting, the information in JSON object is used. 
			 *
			 * 4) If currencyCode is present in the API output and not in formatting inforamtion JSON, 'defaultPrefix' or 'defaultSuffix' format is used based on whether the API says the currency symbol is a prefix or postfix.
			 *
			 * 5) If currencyCode is not present the API output but present in formatting inforamtion JSON, formatting is done as per format JSON including the currency symbol.
			 *
			 */
			
			if(!amount){
				amount = 0;
			}
			
			if(!currencyCode) return amount;
			
			if(showAsNeg && amount>0){
				amount = amount*-1;
			}
			
			var currencyListFromAPI = iscAppContext.getFromContext('currencyList');
			var currencyInputFromAPI = {};
			if(currencyListFromAPI) {
				var currencyAPIOutputArray = currencyListFromAPI.CurrencyList.Currency;
				for(var i=0; i<currencyAPIOutputArray.length; i++) {
					var currentCurrencyObject = currencyAPIOutputArray[i];
					if(currentCurrencyObject.Currency === currencyCode) {
						currencyInputFromAPI = currentCurrencyObject;
						break;
					}
				}
			}
            
			var formats = iscCurrencyFormat.getCurrencyFormat(currencyCode);
			
			if(isEmptyObject(currencyInputFromAPI)) {
				if(formats) {
					return _format(amount,fractionSize,formats);
				} else {
					formats = iscCurrencyFormat.getCurrencyFormat('defaultPrefix');
					formats.CURRENCY_SYM = currencyCode;
					return _format(amount,fractionSize,formats);
				}
			} else {
				if(formats) {
					//There can be a clash between API and config file for the format. Have to handle both cases of clash and no clash
					if(currencyInputFromAPI.PrefixSymbol) {
						formats.CURRENCY_SYM = currencyInputFromAPI.PrefixSymbol;
						if(formats.PATTERNS.posPre) {
							return _format(amount,fractionSize,formats);
						}
						if(formats.PATTERNS.posSuf) {
							formats.PATTERNS.posPre = "\u00a4";
							formats.PATTERNS.negPre = "-\u00a4";
							formats.PATTERNS.posSuf = "";
							formats.PATTERNS.negSuf = "";
							return _format(amount,fractionSize,formats);
						}
						
					}
					if(currencyInputFromAPI.PostfixSymbol) {
						formats.CURRENCY_SYM = currencyInputFromAPI.PostfixSymbol;
						if(formats.PATTERNS.posPre) {
							formats.PATTERNS.posPre = "";
							formats.PATTERNS.negPre = "-";
							formats.PATTERNS.posSuf = "\u00a0\u00a4";
							formats.PATTERNS.negSuf = "\u00a0\u00a4";
							return _format(amount,fractionSize,formats);
						}
						if(formats.PATTERNS.posSuf) {
							return _format(amount,fractionSize,formats);
						}
					}
				} else {
					if(currencyInputFromAPI.PrefixSymbol) {
						formats = iscCurrencyFormat.getCurrencyFormat('defaultPrefix');
						formats.CURRENCY_SYM = currencyInputFromAPI.PrefixSymbol;
						return _format(amount,fractionSize,formats);
					}
					if(currencyInputFromAPI.PostfixSymbol) {
						formats = iscCurrencyFormat.getCurrencyFormat('defaultSuffix');
						formats.CURRENCY_SYM = currencyInputFromAPI.PostfixSymbol;
						return _format(amount,fractionSize,formats);
					}
				}
			}
			
		}
		
		/* Internally called by formatCurrency method to format a number into currency value */
		function _format(amount,fractionSize,formats) {
			var currencySymbol = formats.CURRENCY_SYM;
			if (isUndefined(fractionSize)) {
			  fractionSize = formats.PATTERNS.maxFrac;
			}
			
			return (amount == null)
				? amount
				: formatNumber(amount, formats.PATTERNS, formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).
					replace(/\u00A4/g, currencySymbol);	
		}
		
		/* Internally called by formatCurrency method to format a number into currency value */
		function isUndefined(value) {return typeof value === 'undefined';}
		
		/* Internally called by formatCurrency method to format a number into currency value */
		function isObject(value) {
			return value !== null && typeof value === 'object';
		}
		
		/* Internally called by formatCurrency method to format a number into currency value */
		function isEmptyObject(obj) {
			var name;
			for (name in obj) {
				return false;
			}
			return true;
		}
		
		var DECIMAL_SEP = '.';
		
		/* Internally called by _format method to format a number into currency value */
		function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
			if (isObject(number)) return '';

			var isNegative = number < 0;
			number = Math.abs(number);

			var isInfinity = number === Infinity;
			if (!isInfinity && !isFinite(number)) return '';

			var numStr = number + '',
			  formatedText = '',
			  hasExponent = false,
			  parts = [];

			if (isInfinity) formatedText = '\u221e';

			if (!isInfinity && numStr.indexOf('e') !== -1) {
				var match = numStr.match(/([\d\.]+)e(-?)(\d+)/);
				if (match && match[2] == '-' && match[3] > fractionSize + 1) {
					number = 0;
				} else {
					formatedText = numStr;
					hasExponent = true;
				}
			}

			if (!isInfinity && !hasExponent) {
				var fractionLen = (numStr.split(DECIMAL_SEP)[1] || '').length;

				if (isUndefined(fractionSize)) {
					fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac);
				}

				number = +(Math.round(+(number.toString() + 'e' + fractionSize)).toString() + 'e' + -fractionSize);

				var fraction = ('' + number).split(DECIMAL_SEP);
				var whole = fraction[0];
				fraction = fraction[1] || '';

				var i, pos = 0,
					lgroup = pattern.lgSize,
					group = pattern.gSize;

				if (whole.length >= (lgroup + group)) {
				  pos = whole.length - lgroup;
				  for (i = 0; i < pos; i++) {
					if ((pos - i) % group === 0 && i !== 0) {
					  formatedText += groupSep;
					}
					formatedText += whole.charAt(i);
				  }
				}

				for (i = pos; i < whole.length; i++) {
				  if ((whole.length - i) % lgroup === 0 && i !== 0) {
					formatedText += groupSep;
				  }
				  formatedText += whole.charAt(i);
				}

				while (fraction.length < fractionSize) {
				  fraction += '0';
				}

				if (fractionSize && fractionSize !== "0") formatedText += decimalSep + fraction.substr(0, fractionSize);
			} else {
				if (fractionSize > 0 && number < 1) {
					formatedText = number.toFixed(fractionSize);
					number = parseFloat(formatedText);
					formatedText = formatedText.replace(DECIMAL_SEP, decimalSep);
				}
			}

			if (number === 0) {
				isNegative = false;
			}

			parts.push(isNegative ? pattern.negPre : pattern.posPre,
				formatedText,
				isNegative ? pattern.negSuf : pattern.posSuf);
			return parts.join('');
		}
		
		return formatCurrency;
  }]);
})(window.iscCore);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
/**
 * @ngdoc filter
 * @name iscI18n
 * @kind function
 *
 * @description
 * Translates the key to document set language
 *
 * @param {string} key Key string to the filter
 * @param {object=} options Options to be used for translation
 * @returns {string} Translated string.
 *
 *
 * @example
    <div>
      <span ng-bind="ns.key | iscI18n"></span>
    </div>
 */

(function(iscCore){

  angular.module('isc.shared').filter('iscI18n', function () {
  
  	'use strict';
  
  	function iscI18n(key, options) {
  		return iscCore.translate(key, options);
  	}
  	
  	iscI18n.$stateful = true;
  	
  	return iscI18n;
  
  });
})(window.iscCore);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp. 2018 All Rights Reserved. , 2018 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
/**
 * @ngdoc filter
 * @name iscNumber
 * @kind function
 *
 * @description
 * Parses numeric string value to int.
 *
 * @param {string} value String value to the filter
 * @returns {string} Numeric value.
 *
 *
 * @example
    <div>
      <span ng-bind="ns.value | iscNumber"></span>
    </div>
 */

(function(iscCore){

  angular.module('isc.shared').filter('iscNumber', function () {
  
  	'use strict';
  
  	function iscNumber(value) {
  		value = value | 0;
		return parseInt(value);
  	}
  	
  	iscNumber.$stateful = true;
  	
  	return iscNumber;
  
  });
})(window.iscCore);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/


(function(iscCore){
	/**
	 * @ngdoc filter
	 * @name iscComponentUOM
	 *
	 * @description
	 *	Returns the Unit Of Measure(UOM) string based on the ComponentDetails passed as input. This filter is used in conjunction with a quantity field to add the UOM text to the quantity value. Whether the UOM text gets added before/after the quantity value depends on the locale and can be controlled through a bundle file entry.
	 *
	 * @example
	 * <span class="comapps-label zero-width-label" 
	 *
	 * isc-i18n = "[i18n]({'quantity':'{{ component.KitQuantity | number:$root.ui.quantityFractionSize}}',
	 *
	 * 'uom':'{{component | iscComponentUOM}}'})shipmentsummary.LABEL_QuantityDisplay"></span>
	 */
	
	'use strict';

	angular.module('isc.shared').filter('iscComponentUOM', function () {
		
		function formatUOM(componentDetails) {
			/**
			 * @ngdoc method
			 * @name iscUOM#formatUOM
			 *
			 * @param componentDetails {Object} Model data corresponding to the component details etc
			 *
			 * @returns {String} Unit Of Measure(UOM) string
			 *
			 * @description
			 * Returns the UOM string based upon the data passed in the componentDetails. 
			 *
			 * If componentDetails does not have UOMDisplayFormat and DisplayUnitOfMeasure attributes, then UnitOfMeasure attribute value is returned.
			 *
			 * If componentDetails.UOMDisplayFormat has value as 'formattedQty', DisplayUnitOfMeasure attribute value is returned. 
			 *
			 * If componentDetails.UOMDisplayFormat has value as 'qtyOnly', then nothing is returned.
			 */
			
			if(!componentDetails) return;
			
			if(!componentDetails.UOMDisplayFormat && !componentDetails.DisplayComponentUnitOfMeasure) return componentDetails.ComponentUnitOfMeasure;
			
			if(componentDetails.UOMDisplayFormat == 'formattedQty') return componentDetails.DisplayComponentUnitOfMeasure;
			
			if(componentDetails.UOMDisplayFormat == 'qtyOnly') return;
		}
		
		return formatUOM;
	 });
})(window.iscCore);
/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/


(function(iscCore){
	/**
	 * @ngdoc filter
	 * @name iscUOM
	 *
	 * @description
	 *	Returns the Unit Of Measure(UOM) string based on the LineDetails passed as input. This filter is used in conjunction with a quantity field to add the UOM text to the quantity value. Whether the UOM text gets added before/after the quantity value depends on the locale and can be controlled through a bundle file entry.
	 *
	 * @example
	 * <span class="comapps-label zero-width-label" 
	 * 
	 * isc-i18n = "[i18n]({'quantity':'{{orderLine.OrderedQty | number:$root.ui.quantityFractionSize}}',
	 *
	 * 'uom':'{{orderLine.ItemDetails | iscUOM}}'})orderDetails.Ordered_Qty_UOM"></span>
	 */
	'use strict';

	angular.module('isc.shared').filter('iscUOM', function () {
		
		function formatUOM(lineDetails) {
			/**
			 * @ngdoc method
			 * @name iscUOM#formatUOM
			 *
			 * @param lineDetails {Object} Model data corresponding to the order or shipment etc
			 *
			 * @returns {String} Unit Of Measure(UOM) string
			 *
			 * @description
			 * Returns the UOM string based upon the data passed in the lineDetails. 
			 *
			 * If lineDetails does not have UOMDisplayFormat and DisplayUnitOfMeasure attributes, then UnitOfMeasure attribute value is returned.
			 *
			 * If lineDetails.UOMDisplayFormat has value as 'formattedQty', DisplayUnitOfMeasure attribute value is returned. 
			 *
			 * If lineDetails.UOMDisplayFormat has value as 'qtyOnly', then nothing is returned.
			 */
			if(!lineDetails) return;
			
			if(!lineDetails.DisplayComponentUnitOfMeasure) {
				
				if(!lineDetails.UOMDisplayFormat && !lineDetails.DisplayUnitOfMeasure) return lineDetails.UnitOfMeasure;
				if(lineDetails.UOMDisplayFormat == 'formattedQty') return lineDetails.DisplayUnitOfMeasure;
				
			} else {
				
				if(!lineDetails.UOMDisplayFormat && !lineDetails.DisplayComponentUnitOfMeasure) return lineDetails.ComponentUnitOfMeasure;
				if(lineDetails.UOMDisplayFormat == 'formattedQty') return lineDetails.DisplayComponentUnitOfMeasure;
				
			}
			
			
			if(lineDetails.UOMDisplayFormat == 'qtyOnly') return;
		}
		
		return formatUOM;
	 });
})(window.iscCore);
/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/


(function(iscCore){
  'use strict';
  var _appContext = {};
  
  iscCore.addToContext = function(key,value){
	  _appContext[key] = value;		
	};
	
	iscCore.removeFromContext = function(key){
		delete _appContext[key];		
	};
	
	iscCore.getFromContext = function(key){
		return _appContext[key];		
	};
	
	iscCore.isMobile = function() {
		var check = false;
		(function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4)))check = true})(navigator.userAgent||navigator.vendor||window.opera);
		return check;
	}
	
})(window.iscCore);


(function(iscCore){
  'use strict';

	/**
	 * @ngdoc provider
	 * @name iscAppContextProvider
	 * @description
	 * Use the `iscAppContextProvider` to register the app level key-values data
	 */
angular.module('isc.shared').provider('iscAppContext', function() {
  	
	/**
	 * @ngdoc method
	 * @name iscAppContextProvider#addToContext
	 * @description
	 * The addToContext adds the value to specified key in the app context registry
	 * @param key {string} Key
	 * @param value {any} Value
	 * @example			
			iscAppContextProvider.addToContext(key,value);
	 */
  	this.addToContext = iscCore.addToContext;
  	
  	this.$get = function(){
			/**
       * @ngdoc service       
       * @name iscAppContext       
       * 
       * @description
       * The iscAppContext is the core service which facilitates retreiving app context data
       */
			
  	  return {
				/**
				 * @ngdoc method
				 * @name iscAppContext#getFromContext
				 * @description The getFromContext returns the value for the specified key from app context registry
				 * 
				 * @returns {any}  Value for the specified key
				 * 
				 * @example						
						iscAppContext.getFromContext(key);
				 */
  		addToContext : iscCore.addToContext,
  		removeFromContext : iscCore.removeFromContext,
  		getFromContext : iscCore.getFromContext,
		isMobile : iscCore.isMobile
  	  };
  	};
  });

})(window.iscCore);
/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
(function(iscCore){
  'use strict';
  var appInfo = {};
	
	var _csrfToken;
	var _csrfValidationMode = 'ALL';
	var _loginPage = null;
	var _ssoEnabled = false;
	var _activeHelpURL = null;
	var _devMode = false;
	var _direction = "";
	var _theme = "";
	var _extensibilityMode = false;
	var _isPathBasedExtnEnabled = false;
	var _applicationContext = "";
	var _mashupControllerUrl = "";
	var _checkOnExitEnabled = true;
	var _isMobileMode = false;
	var _appDeviceMode = 'desktop';
	var _urlParsingNode = null;
	var _landingPageState = "/home";
	var _npsScriptsLoaded = false;
	
	appInfo.setAppDeviceMode = function(appDeviceMode) {
		_appDeviceMode = appDeviceMode;
	};
	
	appInfo.getAppDeviceMode = function() {
		return _appDeviceMode;
	};
	
	appInfo.setCSRFToken = function(csrfToken) {
		_csrfToken = csrfToken;
	};
	
	appInfo.getCSRFToken = function() {
		return _csrfToken;
	};
	
	appInfo.setCSRFValidationMode = function(csrfValidationMode) {
		_csrfValidationMode = csrfValidationMode;
	};
	
	appInfo.getCSRFValidationMode = function() {
		return _csrfValidationMode;
	};
	
	appInfo.setLoginPage = function(loginPage) {
		_loginPage = loginPage;
	};
	
	appInfo.getLoginPage = function() {
		return _loginPage;
	};
	
	appInfo.setSSOEnabled = function(ssoEnabled) {
		_ssoEnabled = ssoEnabled;
	};
	
	appInfo.isSSOEnabled = function() {
		return (_ssoEnabled === true);
	};
	
	appInfo.setActiveHelpURL = function(activeHelpURL) {
		_activeHelpURL = activeHelpURL;
	};
	
	appInfo.getActiveHelpURL = function() {
		return _activeHelpURL;
	};
	
	appInfo.setDevMode = function(devMode) {
		_devMode = devMode;
	};
	
	appInfo.isDevMode = function() {
		return (_devMode === true);
	};

	appInfo.setDirection = function(direction) {
		_direction = direction;
	};
	
	appInfo.getDirection = function() {
		return _direction;
	};
		
	appInfo.setTheme = function(theme) {
		_theme = theme;
	};
	
	appInfo.getTheme = function() {
		return _theme;
	};
	
	appInfo.setExtensibilityMode = function(extensibilityMode) {
		_extensibilityMode = extensibilityMode;
	};
	
	appInfo.isExtensibilityMode = function() {
		return (_extensibilityMode === true);
	};
	
	appInfo.setIsPathBasedExtnEnabled = function(isPathBasedExtnEnabled) {
		_isPathBasedExtnEnabled = isPathBasedExtnEnabled;
	};
	
	appInfo.getIsPathBasedExtnEnabled = function() {
		return _isPathBasedExtnEnabled;
	};
	
	appInfo.isLocalStorageSupported = function() {
		try {
			return "sessionStorage" in window && window["sessionStorage"] !== null;
		} catch(e) {
			return false;
		}
	};
	
	// Not setting this now. Keep this and set possibly later.
	appInfo.setApplicationContext = function(applicationContext) {
		_applicationContext = applicationContext;
	};
	
	appInfo.getApplicationContext = function() {
		return _applicationContext;
	};
	
	appInfo.setMashupControllerUrl = function(mashupControllerUrl) {
		_mashupControllerUrl = mashupControllerUrl;
	};

	appInfo.getMashupControllerUrl = function() {
		return _mashupControllerUrl;
	};

	appInfo.setCheckOnExit = function(checkOnExit) {
		_checkOnExitEnabled = checkOnExit;
	};

	appInfo.isCheckOnExitEnabled = function() {
		return _checkOnExitEnabled;
	};

	appInfo.isMobileMode = function() {
		return _isMobileMode;
	};

	appInfo.setMobileMode = function(mobileMode) {
		_isMobileMode = mobileMode;
	};

	appInfo.getUrlParsingNode = function() {
		if (!_urlParsingNode) {
			_urlParsingNode = document.createElement("a");
		}
		return _urlParsingNode;
	};
	
	appInfo.setLandingPageState = function(landingPageState) {
		if (landingPageState != null && landingPageState.trim() != "") {
			_landingPageState = landingPageState;
		}
	};
	
	appInfo.getLandingPageState = function() {
		return _landingPageState;
	};
	
	appInfo.getLocaleCodeForMoment = function(inputLocaleCode) {
		var momentLocaleCode = inputLocaleCode;
		if (inputLocaleCode === "zh") {
			momentLocaleCode = "zh-cn";
		}
		return momentLocaleCode;
	};
	
	appInfo.setNPSScriptsLoaded = function(loaded){
		_npsScriptsLoaded = loaded;
	};
	
	appInfo.isNPSScriptsLoaded = function(){
		return _npsScriptsLoaded;
	};
	
	appInfo.getIBMMetaObject = function(userInfo,otherInfo,triggerFlagList){
		var IBM_Meta = {
						userId: userInfo.UserId,
						userEmail: otherInfo.EmailID,
						userFirstName: otherInfo.FirstName,
						userLastName: otherInfo.LastName,
						country: userInfo.Country,
						language: userInfo.Language,
						offeringId: '5737-D58',
						offeringName: 'IBM Store Engagement',
						highLevelOfferingName: 'IBM Store Engagement',
						icn: otherInfo.icn,
						triggerIntercept: 'heavy',
						customerName: otherInfo.TenantName
					};
					
					//set trigger based parameters
					for(var key in triggerFlagList){
						IBM_Meta[key] = triggerFlagList[key];
					
					}
			
					
			return IBM_Meta;		
	
	};
	
	iscCore.appInfo = appInfo;
})(window.iscCore);


(function(iscCore){
  'use strict';
	/**
	 * @ngdoc provider
	 * @name iscAppInfoProvider
	 * @description
	 * Use the `iscAppInfoProvider` to set the application info
	 */
  angular.module('isc.shared').provider('iscAppInfo', function() {
    
		/**
		 * @ngdoc method
		 * @name iscAppInfoProvider#setCSRFToken
		 * @description
		 * Sets the CSRF token for the application
		 * @param csrfToken {string} CSRF token
		 * @example			
				iscAppInfoProvider.setCSRFToken(csrfToken);
		 */
    this.setCSRFToken = iscCore.appInfo.setCSRFToken;
		/**
		 * @ngdoc method
		 * @name iscAppInfoProvider#setCSRFValidationMode
		 * @description
		 * Sets the CSRF validation mode
		 * @param csrfValidationMode {boolean} Flag to indicate csrf validation mode true|false
		 * @example			
				iscAppInfoProvider.setCSRFValidationMode(true|false);
		 */
    this.setCSRFValidationMode = iscCore.appInfo.setCSRFValidationMode;
		/**
		 * @ngdoc method
		 * @name iscAppInfoProvider#setLoginPage
		 * @description
		 * Sets the login page for application
		 * @param loginUrl {string} Login url for the application
		 * @example			
				iscAppInfoProvider.setLoginPage(loginUrl);
		 */
    this.setLoginPage = iscCore.appInfo.setLoginPage;
		/**
		 * @ngdoc method
		 * @name iscAppInfoProvider#setSSOEnabled
		 * @description
		 * Sets the SSO enabled flag to indicate whether SSO should be enabled
		 * @param ssoEnabled {boolean} Flag to indicate sso enabled true|false
		 * @example			
				iscAppInfoProvider.setSSOEnabled(true|false);
		 */
    this.setSSOEnabled = iscCore.appInfo.setSSOEnabled;
		/**
		 * @ngdoc method
		 * @name iscAppInfoProvider#setActiveHelpURL
		 * @description
		 * Sets the active help url
		 * @param activeHelpURL {string} Active help url
		 * @example			
				iscAppInfoProvider.setActiveHelpURL(activeHelpURL);
		 */
    this.setActiveHelpURL = iscCore.appInfo.setActiveHelpURL;
		/**
		 * @ngdoc method
		 * @name iscAppInfoProvider#setDevMode
		 * @description
		 * Sets the flag to indicate development mode
		 * @param devMode {boolean} Flag to indicate development mode true|false
		 * @example			
				iscAppInfoProvider.setDevMode(true|false);
		 */
    this.setDevMode = iscCore.appInfo.setDevMode;
		/**
		 * @ngdoc method
		 * @name iscAppInfoProvider#setDirection
		 * @description
		 * Sets the direction to be applied to the application
		 * @param extensibilityMode {string} direction of the application ltr|rtl
		 * @example			
				iscAppInfoProvider.setDirectio(ltr|rtl);
		 */
    this.setDirection = iscCore.appInfo.setDirection;
		/**
		 * @ngdoc method
		 * @name iscAppInfoProvider#setTheme
		 * @description
		 * Sets the theme to be applied to the application
		 * @param extensibilityMode {string} theme to be applied for the application
		 * @example			
				iscAppInfoProvider.setTheme(themeName);
		 */
    this.setTheme = iscCore.appInfo.setTheme;
		/**
		 * @ngdoc method
		 * @name iscAppInfoProvider#setExtensibilityMode
		 * @description
		 * Sets the flag to indicate extensiblity mode
		 * @param extensibilityMode {boolean} Flag to indicate extensiblity mode true|false
		 * @example			
				iscAppInfoProvider.setExtensibilityMode(true|false);
		 */
    this.setExtensibilityMode = iscCore.appInfo.setExtensibilityMode;
		/**
		 * @ngdoc method
		 * @name iscAppInfoProvider#setIsPathBasedExtnEnabled
		 * @description
		 * Sets the flag to indicate whether path based extensiblity is enabled
		 * @param pathBasedExtnEnabled {boolean} Flag to indicate path based extensiblity is enabled true|false
		 * @example			
				iscAppInfoProvider.setIsPathBasedExtnEnabled(true|false);
		 */
    this.setIsPathBasedExtnEnabled = iscCore.appInfo.setIsPathBasedExtnEnabled;
		/**
		 * @ngdoc method
		 * @name iscAppInfoProvider#setApplicationContext
		 * @description
		 * Sets the application context uri
		 * @param applicationContext {string} Application context uri
		 * @example			
				iscAppInfoProvider.setApplicationContext(applicationContext);
		 */
    this.setApplicationContext = iscCore.appInfo.setApplicationContext;
		/**
		 * @ngdoc method
		 * @name iscAppInfoProvider#setMashupControllerUrl
		 * @description
		 * Sets the mashup controller url
		 * @param mashupControllerUrl {string} Mashup controller url
		 * @example			
				iscAppInfoProvider.setMashupControllerUrl(mashupControllerUrl);
		 */
    this.setMashupControllerUrl = iscCore.appInfo.setMashupControllerUrl;
		/**
		 * @ngdoc method
		 * @name iscAppInfoProvider#setCheckOnExit
		 * @description
		 * Sets the flag to indicate whether to check on window unload/exit
		 * @param checkOnExit {boolean} Flag to indicate whether to check on window unload/exit true|false
		 * @example			
				iscAppInfoProvider.setCheckOnExit(true|false);
		 */
    this.setCheckOnExit = iscCore.appInfo.setCheckOnExit;
    /**
		 * @ngdoc method
		 * @name iscAppInfoProvider#setMobileMode
		 * @description
		 * Sets the flag to indicate whether mobile mode
		 * @param mobileMode {boolean} Flag to indicate whether mobile mode true|false
		 * @example			
				iscAppInfoProvider.setMobileMode(true|false);
		 */
		this.setMobileMode = iscCore.appInfo.setMobileMode;
		/**
		 * @ngdoc method
		 * @name iscAppInfoProvider#setAppDeviceMode
		 * @description
		 * Sets the device mode
		 * @param appDeviceMode {String} Device mode 'Destop'|'Mobile'|'Handheld'
		 * @example			
				iscAppInfoProvider.setAppDeviceMode('Destop'|'Mobile'|'Handheld');
		 */
    this.setAppDeviceMode = iscCore.appInfo.setAppDeviceMode;
    	/**
		 * @ngdoc method
		 * @name iscAppInfoProvider#setLandingPageState
		 * @description
		 * Sets the landing page state for the application. Defaults to '/home' if not set
		 * @param landingPageState {String} Value to be set as the landing page when user logs into the application
		 * @example			
				iscAppInfoProvider.setLandingPageState('/manager-dashboard');
		 */
	this.setLandingPageState = iscCore.appInfo.setLandingPageState;
		/**
		 * @ngdoc method
		 * @name iscAppInfoProvider#getLandingPageState
		 * @description
		 * Gets the landing page state for the application. Defaults to '/home' if not set
		 * @example			
				iscAppInfoProvider.getLandingPageState();
		 */
	this.getLandingPageState = iscCore.appInfo.getLandingPageState;
	
	
		/**
		 * @ngdoc method
		 * @name iscAppInfoProvider#setNPSScriptsLoaded
		 * @description
		 * Sets information regarding loading of NPS scripts.
		 * @param loaded {boolean} Value to be set if NPS script is loaded already
		 * @example			
				iscAppInfoProvider.setLandingPageState('/manager-dashboard');
		 */
	this.setNPSScriptsLoaded = iscCore.appInfo.setNPSScriptsLoaded;
		
		/**
		 * @ngdoc method
		 * @name iscAppInfoProvider#isNPSScriptsLoaded
		 * @description
		 * Gets information about loading of NPS scripts.
		 * @example			
				iscAppInfoProvider.isNPSScriptsLoaded();
		 */
		  
	this.isNPSScriptsLoaded = iscCore.appInfo.isNPSScriptsLoaded;
	
	/**
		 * @ngdoc method
		 * @name iscAppInfoProvider#getIBMMetaObject
		 * @description
		 * Gets meta data information needed for loading NPS survey popup.
		 * @example			
				iscAppInfoProvider.getIBMMetaObject();
		 */
	
	this.getIBMMetaObject = iscCore.appInfo.getIBMMetaObject;
    
    this.$get = function(){
			/**
       * @ngdoc service       
       * @name iscAppInfo       
       * 
       * @description
       * The iscAppInfo is the core service which facilitates retreiving application info
       */
    	return {
				/**
				 * @ngdoc method
				 * @name iscAppInfo#getCSRFToken
				 * @description
				 * Returns CSRF Token  
				 *
				 * @returns {string} CSRF Token
				 */
    	  getCSRFToken : iscCore.appInfo.getCSRFToken,
				/**
				 * @ngdoc method
				 * @name iscAppInfo#getAppDeviceMode
				 * @description
				 * Returns Device mode
				 *
				 * @returns {string} Device mode
				 */
    	  getAppDeviceMode : iscCore.appInfo.getAppDeviceMode,
				/**
				 * @ngdoc method
				 * @name iscAppInfo#getCSRFValidationMode
				 * @description
				 * Returns CSRF validation mode
				 *
				 * @returns {boolean} CSRF validation mode
				 */
    	  getCSRFValidationMode : iscCore.appInfo.getCSRFValidationMode,
				/**
				 * @ngdoc method
				 * @name iscAppInfo#getLoginPage
				 * @description
				 * Returns login page url
				 *
				 * @returns {string} Login page url
				 */
    	  getLoginPage : iscCore.appInfo.getLoginPage,
				/**
				 * @ngdoc method
				 * @name iscAppInfo#isSSOEnabled
				 * @description
				 * Returns SSO mode
				 *
				 * @returns {boolean} true if sso is enabled else false
				 */
    	  isSSOEnabled : iscCore.appInfo.isSSOEnabled,
				/**
				 * @ngdoc method
				 * @name iscAppInfo#getActiveHelpURL
				 * @description
				 * Returns active help url
				 *
				 * @returns {string} active help url
				 */
    	  getActiveHelpURL : iscCore.appInfo.getActiveHelpURL,
				/**
				 * @ngdoc method
				 * @name iscAppInfo#isDevMode
				 * @description
				 * Returns true if application is running in development mode else false
				 *
				 * @returns {boolean} true if application is running in development mode else false
				 */
    	  isDevMode : iscCore.appInfo.isDevMode,
				/**
				 * @ngdoc method
				 * @name iscAppInfo#getDirection
				 * @description
				 * Returns the direction of the application(Left-to-Right or Right-to-Left)
				 *
				 * @returns {string} ltr or rtl
				 */
    	  getDirection : iscCore.appInfo.getDirection,
				/**
				 * @ngdoc method
				 * @name iscAppInfo#getTheme
				 * @description
				 * Returns the theme which is applied to the application
				 *
				 * @returns {string} theme name(blue)
				 */
    	  getTheme : iscCore.appInfo.getTheme,    	  
				/**
				 * @ngdoc method
				 * @name iscAppInfo#isExtensibilityMode
				 * @description
				 * Returns true if application is running in extensibility mode else false
				 *
				 * @returns {boolean} true if application is running in extensibility mode else false
				 */
    	  isExtensibilityMode : iscCore.appInfo.isExtensibilityMode,
				/**
				 * @ngdoc method
				 * @name iscAppInfo#getIsPathBasedExtnEnabled
				 * @description
				 * Returns true if path based extensions are enabled else false
				 *
				 * @returns {boolean} true if path based extensions are enabled else false
				 */
    	  getIsPathBasedExtnEnabled : iscCore.appInfo.getIsPathBasedExtnEnabled,
				/**
				 * @ngdoc method
				 * @name iscAppInfo#isLocalStorageSupported
				 * @description
				 * Returns true if local storage is supported in the current browser else false
				 *
				 * @returns {boolean} true if local storage is supported in the current browser else false
				 */
    	  isLocalStorageSupported : iscCore.appInfo.isLocalStorageSupported,
				/**
				 * @ngdoc method
				 * @name iscAppInfo#getApplicationContext
				 * @description
				 * Returns application context uri
				 *
				 * @returns {string} Application context uri
				 */
    	  getApplicationContext : iscCore.appInfo.getApplicationContext,
				/**
				 * @ngdoc method
				 * @name iscAppInfo#getMashupControllerUrl
				 * @description
				 * Returns mashup controller url
				 *
				 * @returns {string} Mashup controller url
				 */
    	  getMashupControllerUrl : iscCore.appInfo.getMashupControllerUrl,
				/**
				 * @ngdoc method
				 * @name iscAppInfo#isCheckOnExitEnabled
				 * @description
				 * Returns true if check on window unload/exit is enabled else false
				 *
				 * @returns {boolean} true if check on window unload/exit is enabled else false
				 */
    	  isCheckOnExitEnabled : iscCore.appInfo.isCheckOnExitEnabled,
				/**
				 * @ngdoc method
				 * @name iscAppInfo#isMobileMode
				 * @description
				 * Returns true if application is running in mobile else false
				 *
				 * @returns {boolean} true if application is running in mobile else false
				 */
    	  isMobileMode : iscCore.appInfo.isMobileMode,
				/**
				 * @ngdoc method
				 * @name iscAppInfo#getUrlParsingNode
				 * @description
				 * Returns url parsing node
				 *
				 * @returns {dom} Url parsing node
				 */
    	  getUrlParsingNode : iscCore.appInfo.getUrlParsingNode,
    	  		/**
				 * @ngdoc method
				 * @name iscAppInfo#getLandingPageState
				 * @description
				 * Returns the landing page state for the application
				 *
				 * @returns {string} Landing page when user logs into the application
				 */
		  getLandingPageState : iscCore.appInfo.getLandingPageState,
				/**
				 * @ngdoc method
				 * @name iscAppInfo#getLocaleCodeForMoment
				 * @description
				 * Returns the correct locale code for moment as a few moment locale codes are different from application locale codes
				 *
				 * @returns {string} Moment locale code
				 */
		  getLocaleCodeForMoment: iscCore.appInfo.getLocaleCodeForMoment,
		  
		 /**
		 * @ngdoc method
		 * @name iscAppInfoProvider#setNPSScriptsLoaded
		 * @description
		 * Sets information regarding loading of NPS scripts.
		 * @param loaded {boolean} Value to be set if NPS script is loaded already
		 * @example			
				iscAppInfoProvider.setLandingPageState('/manager-dashboard');
		 */
		setNPSScriptsLoaded : iscCore.appInfo.setNPSScriptsLoaded,
		
		/**
		 * @ngdoc method
		 * @name iscAppInfoProvider#isNPSScriptsLoaded
		 * @description
		 * Gets information about loading of NPS scripts.
		 * @example			
				iscAppInfoProvider.isNPSScriptsLoaded();
		 */
		  
		isNPSScriptsLoaded : iscCore.appInfo.isNPSScriptsLoaded,
		
		
			/**
		 * @ngdoc method
		 * @name iscAppInfoProvider#getIBMMetaObject
		 * @description
		 * Gets the meta data needed for loading NPS scripts
		 * @example			
				iscAppInfoProvider.getIBMMetaObject();
		 */
		getIBMMetaObject : iscCore.appInfo.getIBMMetaObject
    	};
    };
  });
})(window.iscCore);
/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp.  2015, 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/

function Datatype(globalDatatypeInst, defaultDatatypeInst, configJson, numberFormat, iscCore) {
	var type = configJson.type,
		name = configJson.name,
		decimalDigits = (configJson.decimalDigits != null) ? configJson.decimalDigits : 0,
		decimalAllowed = (decimalDigits > 0) ? true : false,
		negativeAllowed = (configJson.negativeAllowed === false) ? false : true,
		displaySeconds = (configJson.displaySeconds === false) ? false : true,
		displayInUI = configJson.displayInUI || false,
		displayGroup = configJson.displayGroup || false,
		defaultvalue = configJson.defaultvalue || "",
		zeroAllowed = (configJson.zeroAllowed === false) ? false : true,
		length = configJson.length || 0,
		maxValue = 0,
		minValue = 0,
		uisize = configJson.uisize || 0,
		uitablesize = configJson.uitablesize || 0,
		whitelist = configJson.whitelist || [],
		blacklist = configJson.blacklist || [],
		// TODO: not using validators. So we need them?
		validators = configJson.validators || [];
	
	var decimalSeparator = ".",
		groupingSeparator = ",",
		groupLength = 3,
		_errorMsg = "",
		_globalDatatypeInst = globalDatatypeInst,
		_defaultDatatypeInst = defaultDatatypeInst;
	// Commenting this code as number input will always be in default en locale.
	// Once input is supported for locale , this code needs to be enabled
	/*if (numberFormat != null) {
		decimalSeparator = numberFormat.DECIMAL_SEP || decimalSeparator;
		groupingSeparator = numberFormat.GROUP_SEP || groupingSeparator;
		if (numberFormat.PATTERNS != null && numberFormat.PATTERNS[0] != null) {
			groupLength = numberFormat.PATTERNS[0].lgSize || groupLength;
		}
	}*/
	
	var _fn_getRegex = function(str, attributes) {
		if (str == null || str == "") {
			return null;
		}
		attributes = attributes || "";
		var retVal = new RegExp(str, attributes);
		return retVal;
	};
	
	
	var returnObj = {
		isDecimalAllowed: function() {
			return decimalAllowed;
		},
		getDecimalDigits: function() {
			return decimalDigits;
		},
		getMaxValue: function() {
			return maxValue;
		},
		getMinValue: function() {
			return minValue;
		},
		getType: function() {
			return type;
		},
		getName: function() {
			return name;
		},
		isNegativeAllowed: function() {
			return negativeAllowed;
		},
		getDefaultValue: function() {
			return defaultvalue;
		},
		isZeroAllowed: function() {
			return zeroAllowed;
		},
		getFixedLength: function() {
			return fixedLength;
		},
		getLength: function() {
			return length;
		},
		getUISize: function() {
			return uisize;
		},
		getUITableSize: function() {
			return uitablesize;
		},
		isDisplaySeconds: function() {
			return displaySeconds;
		},
		isDisplayInUI: function() {
			return displayInUI;
		},
		getDisplayGroup: function() {
			return displayGroup;
		},
		setDefaultValue: function(value) {
			defaultvalue = value;
		},
		getWhitelist: function() {
			return whitelist;
		},
		getBlacklist: function() {
			return blacklist;
		},
		getValidators: function() {
			return validators;
		},
		validate: function(value) {
			// TODO: getDisplayGroup(), isDisplayInUI(), isDisplaySeconds(), getUISize(), getUITableSize(), getFixedLength().
			var validationResponse = false;
			// TODO: Globalize _errorMsg.
			_errorMsg = iscCore.translate("globals.ERROR_invalid_input");
			if (value == null) {
				validationResponse = true;
				_errorMsg = "";
			} else if (returnObj.getType() === "NUMBER") {
				// TODO: Is getDisplayGroup() any way related to numbers?
				// 1st replace all white spaces (between numbers)
				if(value) value = value.replace(/ /g, "");
				// 2nd check if its not a number - isNaN().
				validationResponse = _fn_isNumber(value);
				if (!validationResponse) {
					// 3rd check - remove grouping separator.
					var groupingRegExp = new RegExp(groupingSeparator, "g");
					if(value) var tempvalue = value.replace(groupingRegExp, "");
					validationResponse = _fn_isNumber(tempvalue);
				}
				// 4th check - test for number related limits.
				if (validationResponse) {
					var numValue = +value;
					if (value.indexOf(groupingSeparator) !== -1) {
						var valueWithoutDecimal = value.split(decimalSeparator)[0];
						var groupingSplitValues = valueWithoutDecimal.split(groupingSeparator);
						for(var gi=0; gi < groupingSplitValues.length; gi ++){
							var groupVal = groupingSplitValues[gi];
							if(!groupVal || !_fn_isNumber(groupVal)){
								validationResponse = false;
								_errorMsg = iscCore.translate("globals.ERROR_invalid_input");
							}
							else if(gi > 0 && groupVal.length != groupLength){
								validationResponse = false;
								_errorMsg = iscCore.translate("globals.ERROR_invalid_input");
							}
							else if (gi == 0 && groupVal.length > groupLength){
								validationResponse = false;
								_errorMsg = iscCore.translate("globals.ERROR_invalid_input");
							}
						}
					}
					if (numValue < 0 && !returnObj.isNegativeAllowed()) {
						validationResponse = false;
						_errorMsg = iscCore.translate("datatypevalidation.ERROR_negative_unsupported");
					} else if (numValue === 0 && !returnObj.isZeroAllowed()) {
						validationResponse = false;
						_errorMsg = iscCore.translate("datatypevalidation.ERROR_zero_unsupported");
					} else if (!returnObj.isDecimalAllowed() && value.indexOf(decimalSeparator) !== -1) {
						validationResponse = false;
						_errorMsg = iscCore.translate("datatypevalidation.ERROR_decimal_unsupported");
					} else if (numValue < returnObj.getMinValue() || numValue > returnObj.getMaxValue()) {
						validationResponse = false;
						_errorMsg = iscCore.translate("datatypevalidation.ERROR_max_value_exceeded");
						if (numValue < returnObj.getMinValue()) {
							_errorMsg = iscCore.translate("datatypevalidation.ERROR_min_value_limit");
						}
					} else if (returnObj.isDecimalAllowed() && value.indexOf(decimalSeparator) !== -1) {
						var decimalPart = value.substring(value.indexOf(decimalSeparator) + 1);
						if (decimalPart.length > returnObj.getDecimalDigits()) {
							validationResponse = false;
							_errorMsg = iscCore.translate("datatypevalidation.ERROR_decimal_max") + returnObj.getDecimalDigits();
						}
					}
				}
			} else {
				if (value != null && value.length <= returnObj.getLength()) {
					validationResponse = true;
				} else if (value != null && value.length >= returnObj.getLength()) {
					validationResponse = false;
					_errorMsg = iscCore.translate("datatypevalidation.ERROR_string_max");
				}
				if (validationResponse) {
					var selfName = returnObj.getName();
					var whitelist_tmp = whitelist;
					var blacklist_tmp = blacklist;
					var validators_tmp = validators;
					
					if (selfName !== "_global_" && selfName !== "_default_" && _globalDatatypeInst != null) {
						whitelist_tmp = whitelist_tmp.concat(_globalDatatypeInst.getWhitelist());
						blacklist_tmp = blacklist_tmp.concat(_globalDatatypeInst.getBlacklist());
						validators_tmp = validators_tmp.concat(_globalDatatypeInst.getValidators());
					}
				
					if (selfName !== "_default_" && whitelist_tmp.length == 0 && blacklist_tmp.length == 0 && validators_tmp.length == 0 && _defaultDatatypeInst != null) {
						whitelist_tmp = _defaultDatatypeInst.getWhitelist();
						blacklist_tmp = _defaultDatatypeInst.getBlacklist();
						validators_tmp = _defaultDatatypeInst.getValidators();
					}
					
					validationResponse = true;
					for (var i = 0; i < whitelist_tmp.length; i++) {
						var w = whitelist_tmp[i];
						var r = w[0];
						var re = _fn_getRegex(r, "m");
						if (!re.test(value)) {
							validationResponse = false;
							_errorMsg = iscCore.translate("datatypevalidation." + w[1]);
							break;
						}
					}
					
					if (validationResponse) {
						for (var i = 0; i < blacklist_tmp.length; i++) {
							var b = blacklist_tmp[i];
							var r = b[0];
							var re = _fn_getRegex(r, "m");
							if (re.test(value)) {
								validationResponse = false;
								_errorMsg = iscCore.translate("datatypevalidation." + b[1]);
								break;
							}
						}
					}
				}
			}
			
			_errorMsg = validationResponse ? "" : _errorMsg;
			
			return validationResponse;
			// Removed everything else.
		},
		getValidationResponseObjForDefaultType: function(value) {
			var validationResponse = true;
			if (value == null) {
				validationResponse = true;
				_errorMsg = "";
			} else {
				for (var i = 0; i < whitelist.length; i++) {
					var w = whitelist[i];
					var r = w[0];
					var re = _fn_getRegex(r, "m");
					if (!re.test(value)) {
						validationResponse = false;
						_errorMsg = iscCore.translate("datatypevalidation." + w[1]);
						break;
					}
				}
				
				if (validationResponse) {
					for (var i = 0; i < blacklist.length; i++) {
						var b = blacklist[i];
						var r = b[0];
						var re = _fn_getRegex(r, "m");
						if (re.test(value)) {
							validationResponse = false;
							_errorMsg = iscCore.translate("datatypevalidation." + b[1]);
							break;
						}
					}
				}
			}
			return {
				"booleanResponse": validationResponse,
				"errorMesssage": _errorMsg
			};
		},
		getValidationResponseObj: function(value) {
			if (returnObj.getName() === "_default_") {
				return returnObj.getValidationResponseObjForDefaultType(value);
			} else {
				return {
					"booleanResponse": returnObj.validate(value),
					"errorMesssage": _errorMsg
				};
			}
		}
	};
	
	var _fn_isNumber = function(value) {
		return (isNaN(value) === false);
	};
	
	var _fn_calculateMaxValue = function(config) {
		var totalDigits = returnObj.getLength() - returnObj.getDecimalDigits();
		return (Math.pow(10, totalDigits) - (1/Math.pow(10, returnObj.getDecimalDigits())));
	};
	
	var _fn_calculateMinValue = function(config) {
		if (returnObj.isNegativeAllowed()) {
			return (_fn_calculateMaxValue(config) * -1);
		}
		if (returnObj.isZeroAllowed()) {
			return (0);
		}
		return (1/Math.pow(10, returnObj.getDecimalDigits()));
	};
	
	var _fn_initDataTypeValidations = function() {
		var fn = function(dataType) {
			return (function(input) {
				return dataType.validateData(input);
			});
		}(this);
	
		//scValidateUtils.registerFieldAttributes("datatypeval-" + this.name, this.name);
		//scValidateUtils.registerValidator("datatypeval-" + this.name, fn);
	};
	
	if (configJson.type === "NUMBER") {
		maxValue = _fn_calculateMaxValue(configJson);
		minValue = _fn_calculateMinValue(configJson);
	}
	_fn_initDataTypeValidations();
	
	return returnObj;
}



(function(iscCore, iscData) {
	"use strict";
	var datatypeManager = {};
	var _datatypeObjMap = {};
	
	var emailRegex  = /^[a-z]{1}[\w-\.]+@\w+\.\w+$/i;
	var phoneRegex  = /((\(\d{3}\))|(\d{3}))([-\/\s\.])\d{3}\4\d{4}/;
	var ccRegex  = /[^\d ]/;
	
	var _globalDatatypeInst = null;
	var _defaultDatatypeInst = null;
	
	var _fn_retrieveDatatypeDef = function(key, datatypeJson) {
		if (typeof datatypeJson[key] === "string") {
			datatypeDef = _fn_retrieveDatatypeDef(datatypeJson[key], datatypeJson);
		} else {
			return datatypeJson[key];
		}
	};
	
	var _fn_datatypeInitializer = function(datatypeDef, numberFormat) {
		var datatype = new Datatype(_globalDatatypeInst, _defaultDatatypeInst, datatypeDef, numberFormat, iscCore);
		return datatype;
	};
	
	var _fn_getDatatypeFromBindings = function(ngModel, ngBind, domNode) {
		ngModel = (ngModel != null) ? ngModel : (domNode.attr("ng-model") || domNode.attr("ngModel"));
		
		var datatypeObj = _fn_getDatatypeWithXPath(ngModel);
		if (datatypeObj == null) {
			ngBind = (ngBind != null) ? ngBind : (domNode.attr("ng-bind") || domNode.attr("ngBind"));
			datatypeObj = _fn_getDatatypeWithXPath(ngBind);
		}
		return datatypeObj;
	};
	
	var _fn_getDatatypeWithXPath = function(bindingStr) {
		var datatypeObj = null;
		if (bindingStr != null) {
			var xPath = "",
				attrName = "",
				tok = bindingStr.split(".");
			
			if (tok != null && tok.length > 0) {
				for (var i = 0; i < tok.length; i++) {
					var aTok = tok[i];
					if (i == (tok.length - 1)) {
						xPath = xPath + "/@" + aTok;
						attrName = aTok;
					} else {
						xPath = xPath + "/" + aTok;
					}
				}
			}
			datatypeObj = datatypeManager.getDatatype(("xml:" + xPath));
			if (datatypeObj == null) {
				datatypeObj = datatypeManager.getDatatype(xPath);
				if (datatypeObj == null) {
					datatypeObj = datatypeManager.getDatatype(attrName);
				}
			}
		}
		return datatypeObj;
	};
	
	var _fn_getValidResponse = function() {
		return {
			"booleanResponse": true,
			"errorMesssage": ""
		};
	};
	
	var _fn_getInvalidResponse = function(msg) {
		return {
			"booleanResponse": false,
			"errorMesssage": msg || iscCore.translate("globals.ERROR_invalid_input")
		};
	};
	
	datatypeManager.loadDatatypes = function(datatypeJson,localeNumberFormat) {
		var datatypeDef = null,
			datatypeObj = null,
			numberFormat = angular.copy(localeNumberFormat);
		
		/*if (iscData != null && iscData.userInfo != null && iscData.userInfo.Currency != null) {
			numberFormat = iscCore.getCurrencyFormat(iscData.userInfo.Currency);
			if (numberFormat == null) {
				numberFormat = iscCore.getCurrencyFormat("defaultPrefix");
			}
		}*/
		
		if (datatypeJson["_global_"] != null) {
			_globalDatatypeInst = new Datatype(null, null, datatypeJson["_global_"], numberFormat, iscCore);
			datatypeManager.setDatatype("_global_", _globalDatatypeInst);
		}
		if (datatypeJson["_default_"] != null) {
			_defaultDatatypeInst = new Datatype(null, null, datatypeJson["_default_"], numberFormat, iscCore);
			datatypeManager.setDatatype("_default_", _defaultDatatypeInst);
		}
		
		for (var entry in datatypeJson) {
			if (entry !== "_global_" && entry !== "_default_") {
				datatypeDef = datatypeJson[entry];
				if (typeof datatypeDef === "string") {
					datatypeDef = _fn_retrieveDatatypeDef(datatypeDef, datatypeJson);
				}
				datatypeObj = _fn_datatypeInitializer(datatypeDef, numberFormat);
				datatypeManager.setDatatype(entry, datatypeObj);
			}
		}
	};
	
	datatypeManager.getDatatypeFor = function(iscDatatype, ngModel, ngBind, domNode, scope) {
		iscDatatype = (iscDatatype != null) ? iscDatatype : (domNode.attr("isc-datatype") || domNode.attr("iscDatatype"));
		
		// check if isc-datatype is a string or a config string.
		if (scope != null && iscDatatype != null && iscDatatype.indexOf != null && iscDatatype.indexOf("{") != -1) {
			// Following attributes are allowed: "datatype", "customValidator", "useOnlyCustomValidator".
			iscDatatype = scope.$eval(iscDatatype);
			iscDatatype = iscDatatype.datatype;
		}
		var datatypeObj = datatypeManager.getDatatype(iscDatatype);
		if (datatypeObj == null) {
			datatypeObj = _fn_getDatatypeFromBindings(ngModel, ngBind, domNode);
		}
		if (datatypeObj == null) {
			// set default type. But it can still be null in dev instance.
			datatypeObj = _defaultDatatypeInst;
		}
		return datatypeObj;
	};
	
	datatypeManager.emailFormatValidator = function(v) {
		if (!emailRegex.test(v)) {
			return _fn_getInvalidResponse(iscCore.translate("datatypevalidation.ERROR_invalid_email"));
		}
		return _fn_getValidResponse();
	};
	
	datatypeManager.phoneNumberFormatValidator = function(v) {
		if (!phoneRegex.test(v)) {
			return _fn_getInvalidResponse(iscCore.translate("datatypevalidation.ERROR_invalid_phone_format"));
		}
		return _fn_getValidResponse();
	};
	
	datatypeManager.creditCardFormatValidator = function(v) {
		if (ccRegex.test(v)) {
			return _fn_getInvalidResponse(iscCore.translate("datatypevalidation.ERROR_invalid_char_cc_num"));
		}
		if(v) v = v.replace(/ /g, "");
		var len = v.length, prod, index, sum = 0;
		for (index = len - 1; index >= 0; index--) {
			sum += parseInt(v.charAt(index));
			index--;
			prod = (v.charAt(index) * 2);
			sum += prod > 9 ? Math.floor(prod / 10) + prod % 10 : prod;
		}
		if (sum % 10 != 0) {
			return _fn_getInvalidResponse();
		}
		return _fn_getValidResponse();
	};
	
	datatypeManager.getDatatype = function(datatypeName) {
		return _datatypeObjMap[datatypeName];
	};
	
	datatypeManager.setDatatype = function(datatypeName, datatypeDefinitionObj) {
		_datatypeObjMap[datatypeName] = datatypeDefinitionObj;
	};
	
	datatypeManager.getDatatypeDefinitionObjMap = function() {
		return _datatypeObjMap;
	};
	
	iscCore.datatypeManager = datatypeManager;
	
})(window.iscCore, window.iscData);



(function(iscCore){
	"use strict";
	/**
	 * @ngdoc provider
	 * @name iscDatatypeManagerProvider
	 * @description
	 * Use the `iscDatatypeManagerProvider` to set the datatype info.
	 */
	angular.module("isc.shared").provider("iscDatatypeManager", [function() {
		/**
		 * @ngdoc method
		 * @name iscDatatypeManagerProvider#loadDatatypes
		 * @description
		 * Loads all the datatypes for the application.
		 * @param iscDatatypeInfo {string} A JSON string containing the datatype information.
		 * @example			
				iscDatatypeManagerProvider.loadDatatypes(iscDatatypeInfo);
		 */
		this.loadDatatypes = iscCore.datatypeManager.loadDatatypes;
		
		this.$get = ["iscI18n", function(iscI18n) {
			return {
				getDatatypeFor: iscCore.datatypeManager.getDatatypeFor,
				getDatatype: iscCore.datatypeManager.getDatatype,
				setDatatype: iscCore.datatypeManager.setDatatype,
				getDatatypeDefinitionObjMap: iscCore.datatypeManager.getDatatypeDefinitionObjMap,
				defaultEmailValidator: iscCore.datatypeManager.emailFormatValidator,
				defaultPhoneValidator: iscCore.datatypeManager.phoneNumberFormatValidator,
				defaultCreditCardValidator: iscCore.datatypeManager.creditCardFormatValidator
			};
		}];
	}]);
})(window.iscCore);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/




(function(){
  
  /**
   * @ngdoc provider
   * @name iscIdentifierProvider
   * @description
   * Use the `iscIdentifier` to register the identifier views and to load them
   */
  
  angular.module('isc.shared').provider('iscIdentifier', function() {
    
    var _identifierRegistry = {};
    
    
    /**
     * @ngdoc method
     * @name iscIdentifier#registerIndentifier
     * @description
     * The registerIndentifier adds the idenfier details to identifier registry
     * 
     * @param {string} identifierType Identifer Type
     * @param {string} identifier identifier key
     * @param {object:any} identifierData Identifer data
     * 
     * Note: Default should be configured by passing 'default' as identier key
     * @example
       
  	    iscIdentifier.registerIndentifier("iscAddressDisplay","default","./shared/directives/address/address-display/address-display.tpl.html");
  	    iscIdentifier.registerIndentifier("iscAddressDisplay","US","./shared/directives/address/address-display/address-display_US.tpl.html");
  	    iscIdentifier.registerIndentifier("iscAddressDisplay","FR","./shared/directives/address/address-display/address-display_FR.tpl.html");
     */
    
    this.registerIndentifier = function(identifierType,identifier,identifierData){
      _identifierRegistry[identifierType][identifier] = identifierData;
    };
    
    this.$get = [function(){
      return {
        
    /**
     * @ngdoc method
     * @name iscIdentifier#getIdentifier
     * @description
     * The getIdentifier returns the idenfier details
     * 
     * @param {string} identifierType Identifer Type
     * @param {string} identifier Identifier key
     * 
     * Note: Default value will be returned if identifier key is not found
     * @example
       
  	    iscIdentifier.getIdentifier("iscAddressDisplay","default");
  	    iscIdentifier.getIdentifier("iscAddressDisplay","US");
  	    iscIdentifier.getIdentifier("iscAddressDisplay","FR");
     */
        
        getIdentifier : function(identifierType,identifier){
          return _identifierRegistry[identifierType][identifier]?_identifierRegistry[identifierType][identifier]:_identifierRegistry[identifierType]["default"];
          
        }
      };
    }];
  });
})();

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
(function(){
  'use strict';
	/**
	 * @ngdoc provider
	 * @name iscMediaProvider
	 * @description
	 * Use the `iscMediaProvider` to manage media queries for the app
	 */
  angular.module("isc.shared").provider("iscMedia",[function(){
    		
    var _mediaList = {};
    
		/**
		 * @ngdoc method
		 * @name iscMediaProvider#addMediaQuery
		 * @description
		 * Adds the media query to the application media query list
		 * @param mediaName {string} Media query name
		 * @param minWidth {number} Media min width
		 * @param maxWidth {number} Media max width
		 * @example			
				iscMediaProvider.addMediaQuery("custom-800-1600",800,1600);
		 */
    this.addMediaQuery = function(mediaName,minWidth,maxWidth){
			_mediaList[mediaName] = {minWidth:minWidth,maxWidth:maxWidth};      
    };
    
    this.$get = ["$window",function($window){
			/**
       * @ngdoc service       
       * @name iscMedia       
       * 
       * @description
       * The iscMedia is the core service which facilitates media query handling
       */
      return {
				/**
				 * @ngdoc method
				 * @name iscMedia#getRequestParam
				 * @description
				 * Returns media query match flag 
				 *
				 * @param mediaQueryList {string} Space seperated media query list
				 * @returns {boolean} True when the current media matches the media query list else false
				 */
				isMediaEnabled : function(mediaQueryList){
					var show = false;
      		var winWidth = $window.innerWidth || $window.outerWidth;
					var medias = mediaQueryList.split(' ');
      		var len = medias.length;
					
					for(var i=0;i<len;i++){
						var media = medias[i];
						var mediaQuery = _mediaList[media];
						var min = true;
						var max = true;
						if(!iscCore.isVoid(mediaQuery)){
							if(!iscCore.isVoid(mediaQuery.minWidth) && !(winWidth >= mediaQuery.minWidth)){
								min = false;
							}							
							if(!iscCore.isVoid(mediaQuery.maxWidth) && !(winWidth < mediaQuery.maxWidth)){
								max = false;
							}
							show = min && max;	
						}
						if(show){
							break;	
						}
					}
					return show;
				}
        
      };
    }];
    
  }]);
})();

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
(function(){
  'use strict';
	/**
	 * @ngdoc provider
	 * @name iscRequestProvider
	 * @description
	 * Use the `iscRequestProvider` to set the app level request parameters
	 */
  angular.module("isc.shared").provider("iscRequest",[function(){
    		
    var _requestParams = {};
    
		/**
		 * @ngdoc method
		 * @name iscRequestProvider#setRequestParam
		 * @description
		 * Sets the parameter value to the specified parameter name in the request params
		 * @param requestParamName {string} Parameter name
		 * @param requestParamValue {string} Parameter value
		 * @example			
				iscRequestProvider.setRequestParam(requestParamName,requestParamValue);
		 */
    this.setRequestParam = function(requestParamName,requestParamValue){
      _requestParams[requestParamName] = requestParamValue;
    };
    
    this.$get = [function(){
			/**
       * @ngdoc service       
       * @name iscRequest       
       * 
       * @description
       * The iscRequest is the core service which facilitates retreiving request parameters
       */
      return {
				/**
				 * @ngdoc method
				 * @name iscRequest#getRequestParam
				 * @description
				 * Returns parameter value for the specified parameter name
				 *
				 * @returns {string} Parameter value for the specified parameter name
				 */
        getRequestParam : function(requestParamName){
          return _requestParams[requestParamName];
        }
      };
    }];
    
  }]);
})();

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/



(function(iscCore){
  angular.module('isc.shared').provider('iscScreen', function() {
    'use strict';
    
    var initializeScreen = function($scope,control){
  		$scope.ui = control.ui;  		
  		$scope.model=control.model;
  		
  		angular.forEach(control,function(value,key){
  			if(key.indexOf('ui')===0 && angular.isFunction(control[key])){
  				$scope[key] =function (){					
  					//angular.bind(control, control[key],arguments)();
  					// ideally ui methods should not return value. But, in some cases this is a necessary evil. Just keep these methods very light for performance.
  					return control[key].apply(control,arguments);
  				};
  			}			
  		});
  		
  		if(control.subscribers){
  			angular.forEach(control.subscribers, function(subscriber){
					$scope.$on(subscriber.event,control[subscriber.handler].bind(control));
				});
  		}
  		if(control.initialize && angular.isFunction(control.initialize)){
  			control.initialize();
  		}
  		/*if(control.initializeExtn && angular.isFunction(control.initializeExtn)){
  			control.initializeExtn();
  		}	*/	
  	};	

		var initializeModalScreen = function($scope,control){
			$scope.$on('modal.closing',function(e,args){
				if(args==="escape key press"){
					e.defaultPrevented = true;
				}							
			});
			initializeScreen($scope,control);
			
		};
    
  	this.$get = function () {
			/**
			 * @ngdoc service
			 * @name iscScreen
			 * 
			 * 
			 * @description 
			 * Handles all the common tasks related to screen.
			 * 
			 */
  		return {
  			/**
				 * @ngdoc method
				 * @name iscScreen#initializeScreen
				 * @description Initializes the view $scope with control object and calls initialize method of the view
				 * 
				 * @param $scope {object} Scope object of the view controller
				 * @param control {object} Implementation object of the view
				 * @example
						iscScreen.initializeScreen($scope,{
							//define the models used in the view
							model:{
								"viewModal1":{}
							},
							//define the mashups used in the view
							mashupRefs:[
								{
									mashupRefId:"mashuprefid1",
									mashupId:"mashupid1",
									modelName:"model1"
								}				
							],
							ui:{
								//ui properties goes here
							},				
							initialize:function(){
								//view initialization code goes here
							},
							//define the ui methods that can be called from html with ui as prefix
							uiApply:function(){

							},
							//define helper methods
							helpMethod1:function(){

							},
							//define the private methods with _
							_privateMethod1:function(){

							}			
						});
				 */
  			initializeScreen : initializeScreen,
				/**
				 * @ngdoc method
				 * @name iscScreen#initializeModalScreen
				 * @description Initializes the modal view $scope with control object and calls initialize method of the modal view
				 * 
				 * @param $scope {object} Scope object of the modal view controller
				 * @param control {object} Implementation object of the modal view	 
				 * @example
						iscScreen.initializeModalScreen($scope,{
							//define the models used in the view
							model:{
								"viewModal1":{}
							},
							//define the mashups used in the view
							mashupRefs:[
								{
									mashupRefId:"mashuprefid1",
									mashupId:"mashupid1",
									modelName:"model1"
								}				
							],
							ui:{
								//ui properties goes here
							},				
							initialize:function(){
								//view initialization code goes here
							},
							//define the ui methods that can be called from html with ui as prefix
							uiApply:function(){

							},
							//define helper methods
							helpMethod1:function(){

							},
							//define the private methods with _
							_privateMethod1:function(){

							}			
						});
				 */
				initializeModalScreen : initializeModalScreen
  		};
  	};
  });
})(window.iscCore);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
(function(){
  'use strict';
    /**
     * @ngdoc provider
     * @name iscTimezoneProvider
     * @description
     * Use the `iscTimezoneProvider` to set the timezone values
     */
    angular.module("isc.shared").provider("iscTimezone",[function(){
    		
        var _timezoneMap = {};
        var _installTimezone = "";
        /**
         * @ngdoc method
         * @name iscTimezoneProvider#addTimezone
         * @description
         * Adds the data value to the specified timezone id in the timezone map
         * @param timezoneId {string} Timezone id
         * @param timezoneData {object} Timezone data
         * @example			
                iscTimezoneProvider.setTimezone(timezoneId,timezoneData);
         */
        this.addTimezone = function(timezoneId,timezoneData){
          _timezoneMap[timezoneId] = timezoneData;
        };


        this.setInstallTimezone = function(timezoneId){
          _installTimezone = timezoneId;
        };

        this.$get = [function(){
        /**
        * @ngdoc service       
        * @name iscTimezone       
        * 
        * @description
        * The iscTimezone is the core service which facilitates retreiving timezone values
        */
        return {
            /**
             * @ngdoc method
             * @name iscTimezone#getTimezoneOffset
             * @description
             * Returns parameter value for the specified parameter name
             *
             * @returns {string} Parameter value for the specified parameter name
             */
            getTimezoneOffset : function(timezoneId){
                return _timezoneMap[timezoneId].TimezoneOffset;
            },
            getInstallTimezone :function(){
                return _installTimezone;
            },
            getInstallTimezoneOffset :function(){
                return _timezoneMap[_installTimezone].TimezoneOffset;
            }
        
        
        };
    }];
    
  }]);
})();

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp. 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/




(function(iscCore){
    
    angular.module("isc.shared").provider("iscAppointmentStatus",[function(){
        
		var _appointmentStatusConfig = {};
		 
		this.addAppointmentStatusConfig = function(StatusCode,StatusBundleKey) {
			
			var statusConfig = {
				'StatusCode':StatusCode,
				'StatusBundleKey':StatusBundleKey
				
			};
			
			var tmpConfig = _appointmentStatusConfig;
			 
			if(iscCore.isVoid(tmpConfig)){
				var statusList = {};
				statusList.StatusList={}
				statusList.StatusList.Status = [];
				statusList.StatusList.Status[0] = {};
				statusList.StatusList.Status[0] = statusConfig;
				_appointmentStatusConfig = statusList; 
			}else {
				var statusArray = tmpConfig.StatusList.Status;
				statusArray.push(statusConfig);
				_appointmentStatusConfig = tmpConfig;
			}
			
		};
		
        this.$get = [function(){
			
			return {
				
				getAppointmentStatusConfig : function(){
					return _appointmentStatusConfig;
                },

			
                
				
			};
		}];
        
        
    }])
    
    
    
})(window.iscCore);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp. 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/


(function(iscCore) {
	"use strict";
	
	var iscCalendarDayAgendaViewPvdr = {};
	
	var _calendarMinTimeSlotDuration = "00:60:00";
	var _calendarLocale = "en";
	var _calendarPopupTimeFormat = "h:mma";
	
	iscCalendarDayAgendaViewPvdr.setCalendarMinTimeSlotDuration = function(minDuration) {
		_calendarMinTimeSlotDuration = (minDuration != null && minDuration != "") ? minDuration : _calendarMinTimeSlotDuration;
	};
	
	iscCalendarDayAgendaViewPvdr.getCalendarMinTimeSlotDuration = function() {
		return _calendarMinTimeSlotDuration;
	};
	
	iscCalendarDayAgendaViewPvdr.setCalendarLocale = function(calLocale) {
		_calendarLocale = (calLocale != null && calLocale != "") ? calLocale : _calendarLocale;
		_calendarLocale = _calendarLocale.replace(/_/g, "-");
	};
	
	iscCalendarDayAgendaViewPvdr.getCalendarLocale = function() {
		return _calendarLocale;
	};
	
	iscCalendarDayAgendaViewPvdr.setCalendarPopupTimeFormat = function(timeFormat) {
		_calendarPopupTimeFormat = (timeFormat != null && timeFormat != "") ? timeFormat : _calendarPopupTimeFormat;
	};
	
	iscCalendarDayAgendaViewPvdr.getCalendarPopupTimeFormat = function() {
		return _calendarPopupTimeFormat;
	};
	
	iscCore.iscCalendarDayAgendaViewPvdr = iscCalendarDayAgendaViewPvdr;
})(window.iscCore);


(function(iscCore) {
	"use strict";

	/**
	 * @ngdoc provider
	 * @name iscCalendarDayAgendaViewPvdrProvider
	 * @description
	 * Use the 'iscCalendarDayAgendaViewPvdrProvider' to set calendar view related information.
	 */
	angular.module("isc.shared").provider("iscCalendarDayAgendaViewPvdr", function() {
		
		/**
		 * @ngdoc method
		 * @name iscCalendarDayAgendaViewPvdrProvider#setCalendarMinTimeSlotDuration
		 * @description
		 * This sets the minimum time slot duration for the calendar.
		 * @param minDuration {string} to use in the iscCalendarDayAgendaView directive.
		 * @example			
				iscCalendarDayAgendaViewPvdrProvider.setCalendarMinTimeSlotDuration(minDuration);
		 */
		this.setCalendarMinTimeSlotDuration = iscCore.iscCalendarDayAgendaViewPvdr.setCalendarMinTimeSlotDuration;
	  	
		this.setCalendarLocale = iscCore.iscCalendarDayAgendaViewPvdr.setCalendarLocale;
		
		this.setCalendarPopupTimeFormat = iscCore.iscCalendarDayAgendaViewPvdr.setCalendarPopupTimeFormat;
		
		this.$get = function() {
			
			return {
				
				setCalendarMinTimeSlotDuration: iscCore.iscCalendarDayAgendaViewPvdr.setCalendarMinTimeSlotDuration,
				
				getCalendarMinTimeSlotDuration: iscCore.iscCalendarDayAgendaViewPvdr.getCalendarMinTimeSlotDuration,
				
				setCalendarLocale: iscCore.iscCalendarDayAgendaViewPvdr.setCalendarLocale,
				
				getCalendarLocale: iscCore.iscCalendarDayAgendaViewPvdr.getCalendarLocale,
				
				setCalendarPopupTimeFormat: iscCore.iscCalendarDayAgendaViewPvdr.setCalendarPopupTimeFormat,
				
				getCalendarPopupTimeFormat: iscCore.iscCalendarDayAgendaViewPvdr.getCalendarPopupTimeFormat
				
			};
		};
	});
})(window.iscCore);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
(function(iscCore){
	'use strict';
	var _CURRENCY_FORMATS = {};
	
	iscCore.addCurrencyFormat = function(currencyJSON) {
		var currencyCode = currencyJSON.currencyCode;
		var currencyFormat = currencyJSON.NUMBER_FORMATS;
		_CURRENCY_FORMATS[currencyCode] = currencyFormat;
	}
	
	iscCore.getCurrencyFormat = function(currencyCode,localeNumberFormat) {
        var currencyFormat = angular.copy(_CURRENCY_FORMATS[currencyCode]);
        currencyFormat.DECIMAL_SEP = localeNumberFormat.DECIMAL_SEP;
        currencyFormat.GROUP_SEP = localeNumberFormat.GROUP_SEP;
        currencyFormat.PATTERNS.gSize = localeNumberFormat.PATTERNS[1].gSize;
        currencyFormat.PATTERNS.lgSize = localeNumberFormat.PATTERNS[1].lgSize;
        currencyFormat.PATTERNS.maxFrac = localeNumberFormat.PATTERNS[1].maxFrac;
        currencyFormat.PATTERNS.minFrac = localeNumberFormat.PATTERNS[1].minFrac;
        currencyFormat.PATTERNS.minInt = localeNumberFormat.PATTERNS[1].minInt;
		return currencyFormat;
	}
	
	 
})(window.iscCore);


(function(iscCore){
	'use strict';

	angular.module('isc.shared').provider('iscCurrencyFormat',function() {
		/**
		 * 	@ngdoc provider
		 * 	@name iscCurrencyFormatProvider
		 * 	@description
		 *	Configures the formatting information for currency values based on different currency codes.
		 */
		 
		/**
		 * @ngdoc method
		 * @name iscCurrencyFormatProvider#addCurrencyFormat
		 *
		 * @param currencyJSON {Object} JSON object that contains formatting information for a currencyCode.
		 *
		 * @description
		 * Adds the currency formatting information for a currency code (passed through currencyJSON) to a list. This information is retrieved and used by the iscCurrencyFormat service. This method is currently used by currency.config.js to provide formatting information of ten currencies present in YFS_CURRENCY table of the database. If a new currency is added to the database, formatting information for it can be added by calling this method like the example below. The keys for currencyJSON object follow the angular i18n currency formatting standards. Please refer to "NUMBER_FORMATS" object in any of the locale specific angular i18n javascript files for further information.
		 *
		 * 'currencyCode' in the example JSON below should match the 'Currency' returned by the 'getCurrencyList' API.
		 *
		 * Note that unicode character u00a4 is the placeholder for currency symbol. Unicode character u00a0 refers to blank space that needs to be prefixed or suffixed while formatting some currency values.
		 * 
		 * @example
		 * iscCurrencyFormatProvider.addCurrencyFormat({
				"currencyCode" : "USD",
				"currencyDescription" : "US Dollar",
				"NUMBER_FORMATS" : {
					"CURRENCY_SYM": "$",
					"DECIMAL_SEP": ".",
					"GROUP_SEP": ",",
					"PATTERNS": 
					{
						"gSize": 3,
						"lgSize": 3,
						"maxFrac": 2,
						"minFrac": 2,
						"minInt": 1,
						"negPre": "-\u00a4",
						"negSuf": "",
						"posPre": "\u00a4",
						"posSuf": ""
					}
				}
			});
		 */
		this.addCurrencyFormat = iscCore.addCurrencyFormat;
		
		this.$get = ["$locale",function($locale){
			/**
			 * @ngdoc service
			 * @name iscCurrencyFormat
			 *
			 * @description
			 *	Helps to format a currency value based on pre-configured formatting information for a currency code.
			 */
			return {
				/**
				 * @ngdoc method
				 * @name iscCurrencyFormat#getCurrencyFormat
				 *
				 * @param currencyCode {String} The currency code for which formatting information needs to be retrieved
				 *
				 * @description
				 * Gets the formatting information for a currency code that was added through the iscCurrencyFormatProvider.
				 *
				 * @returns {Object} The JSON object containing the formatting information for a currency code
				 */
				getCurrencyFormat : function(currencyCode){
                    return iscCore.getCurrencyFormat(currencyCode,$locale.NUMBER_FORMATS);
                }
            
			};
		}];
	});
})(window.iscCore);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp.  2016, 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/



(function(iscCore){
    
    angular.module("isc.shared").provider("iscDateFilter",[function(){
        
		var _dateFormatForLocale = {};
		var _dateTimeFormatForLocale = {};
		
		/**
		 * 	@ngdoc provider
		 * 	@name iscDateFilterProvider
		 * 	@description
		 *	Configures the date filter options.
		 */
        
        this.addDateFormatForLocale = function(key,value) {
			_dateFormatForLocale[key] = value;
		};
        
		this.addDateTimeFormatForLocale = function(key,value) {
			_dateTimeFormatForLocale[key] = value;
		};
		
        this.$get = ["amDifferenceFilter","iscI18n",function(amDifferenceFilter,iscI18n){
			/**
			 * @ngdoc service
			 * @name iscDateFilter
			 *
			 * @description
			 *	Provides utilities for date operations
			 */
			return {
				/**
				 * @ngdoc method
				 * @name iscDateFilter#validateDateRange
				 *
				 * @param fromDate {Date} Start date for the date range
                 * @param toDate {Date} End date for the date range
                 * @param maxDate {Date} Maximum date for the date range validation. Optional
                 * @param minDate {Date} Minimum date for the date range validation. Optional
				 *
				 * @description
				 * Validates the date range.
				 *
				 * @returns {Object} The JSON object containing the flag isError for indication date range has errors and errorMessage string for indicating the error message 
				 */
				validateDateRange : function(fromDate,toDate,maxDate,minDate) {
                    var isError = false;
                    var errorMessage = "";
                    if ((fromDate && !toDate) || (!fromDate && toDate)) {
                        errorMessage = iscI18n.translate('datefilter.ERROR_date_missing');
                        isError = true;
                    }

                    if (fromDate && toDate) {
                        if (amDifferenceFilter(toDate, fromDate) < 0) {
                            errorMessage = iscI18n.translate('datefilter.ERROR_toDate_lesser');
                            isError = true;
                        }

                        if (maxDate && ((amDifferenceFilter(fromDate, maxDate) > 0) || (amDifferenceFilter(toDate, maxDate) > 0))) {
                            errorMessage = iscI18n.translate('datefilter.ERROR_date_greater_than_range');
                            isError = true;
                        }

                        if (minDate && ((amDifferenceFilter(fromDate, minDate) < 0) || (amDifferenceFilter(toDate, minDate) < 0))) {
                            errorMessage = iscI18n.translate('datefilter.ERROR_date_greater_than_range');
                            isError = true;
                        }
                    }
                    return {
                        isError: isError, 
                        errorMesssage: errorMessage
                    };
                },
                
                getDBFromDate : function(date){
                    return date.format("YYYY-MM-DDT00:00:00");
                },
                
				getDBToDate : function(date){
                    return date.format("YYYY-MM-DDT23:59:59");
                },
                
				getDateFormatForLocale : function(key) {
					return _dateFormatForLocale[key];
				},
				
				getDateTimeFormatForLocale : function(key) {
					return _dateTimeFormatForLocale[key];
				},
				
			};
		}];
        
        
    }])
    
    
    
})(window.iscCore);
/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp. 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
 
(function(iscCore) {
	"use strict";
	
	var iscDialChartD3Pvdr = {};
	var _dialChartsConfigData = null;
	var _managerDashboardConfig = null;
	
	iscDialChartD3Pvdr.setDialChartsConfigData = function(dialChartsConfigData) {
		_dialChartsConfigData = dialChartsConfigData;
	};
	
	iscDialChartD3Pvdr.getDialChartsConfigData = function() {
		return _dialChartsConfigData;
	};
	
	iscDialChartD3Pvdr.setManagerDashboardConfig = function(managerDashboardConfig) {
		_managerDashboardConfig = managerDashboardConfig;
	};
	
	iscDialChartD3Pvdr.getManagerDashboardConfig = function() {
		return _managerDashboardConfig;
	};
	
	iscDialChartD3Pvdr.updateManagerDashboardConfigWithRefreshInterval = function(refreshInterval) {
		_managerDashboardConfig["refreshInterval"] = refreshInterval;
	};
	
	iscCore.iscDialChartD3Pvdr = iscDialChartD3Pvdr;
	
})(window.iscCore);

(function(iscCore) {
	"use strict";
	
	/**
	 * @ngdoc provider
	 * @name iscDialChartD3PvdrProvider
	 * @description
	 * Use the iscDialChartD3PvdrProvider to set the config data to be used by iscDialChartD3 directive.
	 */
	
	angular.module("isc.shared").provider("iscDialChartD3Pvdr", function() {
		
		/**
		 * @ngdoc method
		 * @name iscDialChartD3PvdrProvider#setDialChartsConfigData
		 * @description
		 * This method sets the config data for iscDialChartD3 directive.
		 * @param dialChartsConfigData {object} Json object containing the configuration data.
		 * @example			
				iscDialChartD3PvdrProvider.setDialChartsConfigData(dialChartsConfigData);
		 */
		
		this.setDialChartsConfigData = iscCore.iscDialChartD3Pvdr.setDialChartsConfigData;
		
		/**
		 * @ngdoc method
		 * @name iscDialChartD3PvdrProvider#setManagerDashboardConfig
		 * @description
		 * This method sets the manager dashboard configuration data which can be used by iscDialChartD3 directive.
		 * @param managerDashboardConfig {object} Json object containing the manager dashboard configuration json data.
		 * @example			
				iscDialChartD3PvdrProvider.setManagerDashboardConfig(managerDashboardConfig);
		 */
		
		this.setManagerDashboardConfig = iscCore.iscDialChartD3Pvdr.setManagerDashboardConfig;
    
		this.$get = function() {
			/**
		     * @ngdoc service       
		     * @name iscDialChartD3Pvdr       
		     * 
		     * @description
		     * The iscDialChartD3Pvdr is the core service which facilitates retrieving and updating info regarding dialchart and manager dashborad config.
		     */
			return {
				/**
				 * @ngdoc method
				 * @name iscDialChartD3Pvdr#getDialChartsConfigData
				 * @description
				 * Returns dial charts configuration json data.
				 *
				 * @returns {object} dialChartsConfigData
				 */
				getDialChartsConfigData: iscCore.iscDialChartD3Pvdr.getDialChartsConfigData,
				
				/**
				 * @ngdoc method
				 * @name iscDialChartD3Pvdr#getManagerDashboardConfig
				 * @description
				 * Returns manager dashboard configuration json data.
				 *
				 * @returns {object} managerDashboardConfig
				 */
				getManagerDashboardConfig: iscCore.iscDialChartD3Pvdr.getManagerDashboardConfig,
				
				updateManagerDashboardConfigWithRefreshInterval: iscCore.iscDialChartD3Pvdr.updateManagerDashboardConfigWithRefreshInterval
			};
		};
	});
})(window.iscCore);
/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/

(function(iscCore){
  'use strict';

	/**
	 * @ngdoc provider
	 * @name iscAutofocusProvider
	 * @description
	 * Use the iscAutofocusProvider to register the function for setting focus for HTML elements generated through the bootstrap element tags
	 */
angular.module('isc.shared').provider('iscAutofocus', function() {
	var _focusConfigurationMap = {};
	
	/**
     * @ngdoc method
     * @name iscAutofocusProvider#addFocusConfiguration
     * @description
     * Adds the focus logic corresponding to a bootstrap element tag
     * @param elementTagName {String} tag name associated with the bootstrap element as specified in the HTML
     * @param config {Object} Configuration object associated with the element which includes the function to be called to set focus for the element. The config object should have 'focus' key defined with its value pointing to the function to be executed to set focus for the element.
     * @example
        var focusConfig = {
      		'focus' : function(scope,element,attributes){
				var anchorElement = element[0].getElementsByTagName('a');
				anchorElement[0].setAttribute('autofocus',true);
      		}
      	};
      	iscAutofocusProvider.addFocusConfiguration('uib-tab',focusConfig);
	*/
	this.addFocusConfiguration = function(elementTagName,config) {
		if(_focusConfigurationMap[elementTagName] === undefined){
			_focusConfigurationMap[elementTagName] = config;
		}
	}
	
	this.setFocusOnElement = function(scope,element,attributes){
		var elementTagName = element[0].getAttribute('isc-tag-name');
		if(elementTagName) {
			var functionToCall = _focusConfigurationMap[elementTagName]['focus'];
			functionToCall(scope,element,attributes);
		}
	}
	
  	this.$get = function(){
	  /**
       * @ngdoc service       
       * @name iscAutofocusService      
       * 
       * @description
       * Sets focus on an HTML element (corresponding to a bootstrap element tag, for example) based upon the logic registered through the iscAutofocusProvider
       */
			
  	  return {
		/**
		 * @ngdoc method
		 * @name iscAutofocusService#setFocusOnElement
		 * @param scope {Object} Scope associated with the HTML element
		 * @param element {Object} HTML element on which focus needs to be set
		 * @param attributes {Object} Attributes associated with the HTML element
		 * @description Sets focus on an HTML element based on the element tagName
		 * 
		 * @example						
				iscAutofocus.setFocusOnElement(scope,element,attributes);
		 */
		setFocusOnElement : this.setFocusOnElement
  	  };
  	};
  });

})(window.iscCore);
/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp.  2015, 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/

(function(iscCore,i18n){
  'use strict';
  
  var _l10n = {};
  var _l10nExtn = {};
  
  var _l10nSupportedLocales = [];
  var _l10nDefaultLocale = "en";
  var _currentLocale = "en";
  
  
  var mergeL10n = function(target,src){
    if(!iscCore.isVoid(src)){
      Object.keys(src).forEach(function (key) {
          if (typeof src[key] !== 'object' || !src[key]) {
              target[key] = src[key];
          }
          else {
              if (!target[key]) {
                  target[key] = src[key];
              } else {
                  mergeL10n(target[key], src[key]);
              }
          }
      });
    }
  };
  
  
  iscCore.registerL10n = function(locale,ns,l10nBundle){
    _l10n[locale] = _l10n[locale]?_l10n[locale]:{};
    _l10n[locale][ns] = _l10n[locale][ns]?_l10n[locale][ns]:{};
    mergeL10n(_l10n[locale][ns],l10nBundle);
  };

  iscCore.registerL10nExtn = function(locale,ns,L10nBundleExtn){
    _l10n[locale] = _l10n[locale]?_l10n[locale]:{};
    _l10n[locale][ns] = L10nBundleExtn;
  };
  
  iscCore.getL10n = function(locale,ns){
    return _l10n[locale]?_l10n[locale][ns]?_l10n[locale][ns]:{}:{};
  };
  
  iscCore.translate = function (key,options){
	  var temp = i18n.t(key,options);
	  if(temp.indexOf("app:")===0) {
		  console.log("i18n DEBUG: Bundle Key '"+key+"' is not found.");
		  temp = temp.replace("app:","");
	  }
	  return temp;
    //return i18n.t(key,options);
  };
    
  iscCore.hasBundleKey = function(key){
		return i18n.exists(key);
	};
	
	iscCore.registerLocales = function(localList){
	  _l10nSupportedLocales = localList;
	};
	
    iscCore.getDefaultLocale = function(){
	  return _l10nDefaultLocale;
	};
    
	iscCore.setDefaultLocale = function(defaultLocale){
	  _l10nDefaultLocale = defaultLocale!==""?defaultLocale:"en";
	};
	
	iscCore.setCurrentLocale = function(currentLocale){
	  _currentLocale = currentLocale!==""?currentLocale:"en";
	};
	
	iscCore.getCurrentLocale = function(){
	  return _resolveLocale(_currentLocale);
	};
	
	var _resolveLocale = function _resolveLocale(locale){
	  
	  function __resolveLocale(locale){
	    var resolvedLocale="";
  	  var len = _l10nSupportedLocales.length;
  	  while(len--){
  	    if(_l10nSupportedLocales[len]===locale){
  	      resolvedLocale = locale;
  	      break;
  	    }
  	  }
  	  return resolvedLocale;
	  }
	  
	  var resolvedLocale = __resolveLocale(locale);
	  if(resolvedLocale===""){
	    var splitLocale = locale.split('-')[0].split('_')[0];
	    resolvedLocale = __resolveLocale(splitLocale);
	  }
	  
	  return resolvedLocale!==""?resolvedLocale:_l10nDefaultLocale;
	};
	
})(window.iscCore,window.i18next);



/**
 * @ngdoc provider
 * @name iscI18nProvider
 * @requires $httpProvider
 * @description
 * Use the `iscI18nProvider` to initialize and load locale bundles
 */

(function(iscCore,i18n){
  'use strict';
  
  angular.module('isc.shared').provider('iscI18n', ['$httpProvider',function($http) {
    
    var _globalOptions = null;
    var _initialized = false;
    var _l10nKitFiles = [];
    /**
     * @ngdoc property
     * @name iscI18nProvider#options
     * @description
     * The options property is used to initializes i18next
     * 
     */
    this.options = {};
    /**
		 * @ngdoc method
		 * @name iscI18nProvider#init
		 * @description
		 * Initializes the i18n congiguration for application. 
		 * @param options {object} options for i18n		 
		 * @example			
				iscI18nProvider.init(options);
		 */
    this.init = function(options){
      iscCore.setDefaultLocale(options.fallbackLng);
      iscCore.registerLocales(options.lngs);
      _l10nKitFiles = options.l10nKit;
      
    };
    /**
		 * @ngdoc method
		 * @name iscI18nProvider#registerL10n
		 * @description
		 * Registers the l10n bundles for the specified locale and namespace 
		 * @param locale {string} Locale code
		 * @param ns {string} Namespace
		 * @param l10nBundle {object} Language bundles
		 * @example			
				iscI18nProvider.registerL10n('en','globlas',{"hello":"world"});
		 */
    this.registerL10n = iscCore.registerL10n;
  	/**
		 * @ngdoc method
		 * @name iscI18nProvider#registerL10nExtn
		 * @description
		 * Registers the l10n bundles for the specified locale and namespace as an extension
		 * @param locale {string} Locale code
		 * @param ns {string} Namespace
		 * @param l10nBundle {object} Language bundles
		 * @example			
				iscI18nProvider.registerL10nExtn('en','globlas',{"hello":"world"});
		 */
    this.registerL10nExtn = iscCore.registerL10nExtn;
    
    this.$get = ['$rootScope','$http','$q','iscL10nRequest', function($rootScope,$http,$q,iscL10nRequest){
      var that = this;
      var customLoad = function(lng, ns, options, loadComplete) {
       
        console.log(lng);
        var currentLng = lng;//iscCore.getCurrentLocale();
              
        var qArray = [];
        var f = 0;
        var filesLen = _l10nKitFiles.length;
        
        while(f<filesLen){
          var l10nUrl = _l10nKitFiles[f].url;
          var l10nNs = _l10nKitFiles[f].ns;
          l10nUrl = l10nUrl.replace('__lng__',currentLng);
          addToQueue(qArray,l10nUrl,l10nNs);
          f++;
        }
        
        function addToQueue(queue,l10nUrl,l10nNs){
          var promise = iscL10nRequest(l10nUrl).then(function(l10nJson) {
            console.log("bundle loaded "+l10nUrl);
            iscCore.registerL10n(currentLng,l10nNs,l10nJson);
          });
          queue.push(promise);
          
        }        
        
        $q.all(qArray).then(function(){
          console.log("bundles loaded for :: "+currentLng);
          loadComplete(null,iscCore.getL10n(currentLng,"app"));
        },function(error){
          console.log("bundles loaded for with errors:: "+currentLng);
          loadComplete(null,iscCore.getL10n(currentLng,"app"));
        });       
      };
        
        
        
    var backend = {
      type: 'backend',
      init: function(services, backendOptions, i18nextOptions) { /* use services and options */ },
      read: function(language, namespace, callback) { /* return resources */ 
        console.log();
        customLoad(language,namespace,{},callback);
      },

      // optional
      readMulti: function(languages, namespaces, callback) { /* return multiple resources - usefull eg. for bundling loading in one xhr request */ },
      create: function(languages, namespace, key, fallbackValue) { /* save the missing translation */ }
    }
    
      this.init = function (options){
        if(_initialized){
          return;
        }
        if (i18n) {
          iscCore.setCurrentLocale(options.lng);
            options.compatibilityAPI = 'v1',
            options.compatibilityJSON = 'v1',
          options.lng = iscCore.getCurrentLocale();
          options.customLoad = customLoad;
					options.interpolationPrefix = "${";
					options.interpolationSuffix = "}";
          //window.i18n.init({customLoad:customLoad});
            i18n.use(backend);
          i18n.init(options,function(){
            //window.i18n.addResourceBundle("en","app",{"home":{"TITLE_Home":"HOME2"}});  
            $rootScope.ui = $rootScope.ui?$rootScope.ui : {};
            $rootScope.ui.i18nReady = true;
            _initialized = true;
          });
        }
        else{
          console.error("i18n is not initialized");
        }
      };
      
      this.translate = iscCore.translate;
      
      this.hasKey = iscCore.hasBundleKey;
      /**
       * @ngdoc service       
       * @name iscI18nService       
       * 
       * @description
       * The iscI18n is the core service which facilitates i18n translations
       */  
      return {
				/**
				 * @ngdoc method
				 * @name iscI18nService#translate
				 * @description
				 * The translate method translates the key to document set language
				 * @param {string} key key to translate
				 * @param {object} options Options for i18next 
				 * @returns {string} Translated string if found else the key itself
				 * @example
				 		iscI18n.translate(key,options);
				 */
        translate : that.translate,
				/**
				 * @ngdoc method
				 * @name iscI18nService#init
				 * @description
				 * The init method loads the language bundles and initializes i18next
				 * @param {object} options Options for i18next 
				 * 
				 * @example
				 		iscI18n.init(options);
				 */
        init : that.init,
				/**
				 * @ngdoc property
				 * @name iscI18nService#options
				 * @description
				 * The options property is used to initializes i18next
				 * 
				 */
        options : that.options,
				/**
				 * @ngdoc method
				 * @name iscI18nService#hasKey
				 * @description
				 * Checks whether the given bundle key is present in the language bundle or not
				 * @param {string} key Key to check
				 * @returns {string} true if the bundle key is present else false
				 * @example
				 		iscI18n.hasKey(key);
				 */
        hasKey : that.hasKey
      };
      
    }];
  }]);

})(window.iscCore,window.i18next);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/




(function(){
  
  function iscL10nCacheProvider() {
    this.$get = ['$cacheFactory', function($cacheFactory) {
      return $cacheFactory('l10n');
    }];
  }
  
  angular.module('isc.shared').provider('iscL10nCache',iscL10nCacheProvider);
  
  
  
  var l10nMinErr = angular.$$minErr('iscL10n');
  
  function iscL10nRequestProvider() {
    this.$get = ['iscL10nCache', '$http', '$q', function(iscL10nCache, $http, $q) {
      function handleRequestFn(l10n, ignoreRequestError) {
        handleRequestFn.totalPendingRequests++;
        /*var defaultHttpResponseTransform = $http.defaults && $http.defaults.transformResponse;

        if (angular.isArray(transformResponse)) {
          transformResponse = transformResponse.filter(function(transformer) {
            return transformer !== defaultHttpResponseTransform;
          });
        } else if (transformResponse === defaultHttpResponseTransform) {
          transformResponse = null;
        }
        */
				var transformResponse = function(data,headers,status){		
					if(status===200){
						return JSON.parse(data.replace(/(?:\/\*(?:[\s\S]*?)\*\/)|(?:([\s;])+\/\/(?:.*)$)/gm, ''));	
					}
					else{
						return {};	
					}
					
				};
        var httpOptions = {
          cache: iscL10nCache,
          transformResponse: transformResponse
        };
  
        return $http.get(l10n, httpOptions)
          ['finally'](function() {
            handleRequestFn.totalPendingRequests--;
          })
          .then(function(response) {
            if(response.status===200){							
              return response.data;
            }
            else{
             return null; 
            }
          }, handleError);
  
        function handleError(resp) {
          if (!ignoreRequestError) {
            throw l10nMinErr('l10nload', 'Failed to load l10n: {0}', l10n);
          }
          return $q.reject(resp);
        }
      }
  
      handleRequestFn.totalPendingRequests = 0;
  
      return handleRequestFn;
    }];
  }

  angular.module('isc.shared').provider('iscL10nRequest',iscL10nRequestProvider);
  
})(window.angular);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/

(function(iscCore){

'use strict';

angular.module('isc.shared').provider('supportedLocale',function(){

 
 this.defaultLocale = 'US';
 this.supportedLocales = {"IN":"India","US":"United States","UK":"United Kingdom","GB":"Great Britain",
                          "ES":"Spain","PT":"Portugal","KR":"Korea",
                          "KP":"Korea","IT":"Italy","DE":"Germany","RU":"Russia",
	                      "TW":"Taiwan","FR":"France","CN":"China","CA":"Canada","JP":"Japan","PL":"Poland","TR":"Turkey"};
 
 this.$get = function (){
 
   var defaultLocale = this.defaultLocale;
   
   var supportedLocales = this.supportedLocales;
						  
				  
   
   
   return {
      getSupportedLocales : function(){
	     return supportedLocales;
	  },
	  
	  isLocaleSupported : function ( localeCode ){
	    if(supportedLocales[localeCode]){
		   return true;
		}
	  },
	  
	  getDefaultLocale : function(){
	     return defaultLocale;
	  },
   
   }
 };
 
 this.setDefaultLocale = function( deflocale ){
    this.defaultLocale = deflocale.Code;
 };
 
 this.addSupportedLocale = function(addLocale){
    this.supportedLocales[addLocale.Code] = addLocale.Description;
 };


});

})(window.iscCore);

angular.module('isc.shared').config(['supportedLocaleProvider',function(supportedLocaleProvider){
 
      supportedLocaleProvider.setDefaultLocale({"Code":"US","Description":"United States"});
	 //supportedLocaleProvider.addSupportedLocale({"Code":"SL","Description":"Sri Lanka"});
    
}]);


/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp.  2015, 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/







(function(iscCore){
  'use strict';
  
  var _modalMap = {};
  
  iscCore.registerModal = function(modalId,modalData){
		_modalMap[modalId] = modalData;	  
	};
  
	iscCore.getModalData = function(modalId){	  
	  return _modalMap[modalId];
	};
  
})(window.iscCore);








(function(iscCore){
  'use strict';
  
  angular.module('isc.shared').value('modalOptions',{
		closeButtonText: "globals.BUTTON_Close",
		showCloseButton: true,
		actionButtonText: "modal.BUTTON_Ok",
		headerText: "modal.TITLE_Modal_header"
	});
	angular.module("isc.shared").value("modalSettings", {
		size: "md",
		type: "default",
		backdrop: 'static',
		keyboard: true,
		modalFade: true,
		contentTemplate: "./shared/modal/modal-default.tpl.html"
	});
  
  angular.module('isc.shared').provider('iscModal', function() {
  	/**
		 * @ngdoc provider
		 * @name iscModalProvider
		 * @description
		 * Use the iscModalProvider to register the modal views and to load them
		 */
		
    /**
     * @ngdoc method
     * @name iscModalProvider#registerModal
     * @description
     * The registerModal adds the modal details to private modal registry
     * For more information modal config data see ui-bootstrap $uibModal
     * @param {string} modalId Modal Id
     * @param {object} modalData Modal config data
     * @example
        var aboutConf = {
  			  animation: true,
  			  templateUrl: './store/views/about/about.tpl.html',
  			  controller:'iss.views.about.about',
  			  size: 'lg',	
  		};
  	  iscModalProvider.registerModal("iss.views.about.about",aboutConf);
     */
  	this.registerModal = iscCore.registerModal;
    
  	this.getModalData = iscCore.getModalData;
    
  	this.$get = function () {
  		var that = this;
  		return {
  			getModalData : that.getModalData
  		};
  	};
  	this.$get = ['$uibModal','modalOptions','modalSettings','$rootScope','iscI18n', function($uibModal,modalOptions,modalSettings,$rootScope,iscI18n) {
  	   
	    /**
       * @ngdoc service       
       * @name iscModal       
       * @requires $uibModal
       * @requires modalOptions
			 * @requires modalSettings
       * 
       * @description
       * The iscModal is the core service which facilitates show modal popups
       * 
       * 
       * 
       * 
       */
			var that = this;
    	var iscModal = {};
    	
    	/**
    	 * @ngdoc method
    	 * @name iscModal#openModal
    	 * @description The openModal opens the modal-view inside a modal window
    	 * 
    	 * @param modalId {string} View modal id to be opened
    	 * @param resolveData {object} Resolve data used in the modal-view
    	 * @param modalOptions {object} Modal options to be used for showing modal window
    	 * 
    	 * @returns {object} Modal promise object
    	 * 
    	 * @example
          var resolveData = {
            modalInput : function(){
              return {
                input1:"input1",
                input2:"input2"
              }
            }
          }
          iscModal.openModal("modelId",resolveData,modalOptions).then(function action(data){},function dismiss(data)()});
    	 */
    	iscModal.openModal = function(modalId,resolveData,modalOptions){
    		var modalData = that.getModalData(modalId);
    		if(modalData){
    			modalData.resolve = resolveData;
    			if(iscCore.isVoid(modalData.resolve)){
    			  modalData.resolve = {modalInput:function(){return{};}};
    			}
    			return $uibModal.open(modalData).result;
    		}
    		else{
    			console.log("Modal not registered :: "+modalId);
    		}
    		
    	};
    	
    	
    	/**
    	 * @ngdoc method
    	 * @name iscModal#openMessage
    	 * @description The openMessage displays the message in modal window
    	 * 
    	 * @param {object} customOptions options passed to show the message
			 * 
    	 * @returns {object} Modal promise object
    	 * 
    	 * @example
    	    var customOptions = {
    	      options: { 
    						headerText: "modal.TITLE_Succes",
    						action:[
    						  {
    						    actionName:"VIEWSUMMARY",
    						    actionLabel:"modal.BUTTON_View_summary"
    						  }
    						]
    					},
    					settings: { 
    						size: "md", 
    						type: "success" 
    					}, 
    					data: { 
    						text: "Payment was successful" 
    					}
    	    }
    	    iscModal.openMessage(customOptions)
    	 * 
    	 */
    	iscModal.openMessage = function(customOptions){
			$rootScope.ui.showAlertMessage = false; // The alert message panel should be closed when a modal window is opened
			if(customOptions.data && customOptions.data.text && iscI18n.hasKey(customOptions.data.text)) customOptions.data.text = iscI18n.translate(customOptions.data.text);
    	  var options = angular.copy(modalOptions),
				  settings = angular.copy(modalSettings);
			  angular.extend(options, customOptions.options);
			  angular.extend(settings, customOptions.settings);

  			/**
  			 * set contentTemplate
  			 */
  			options.contentTemplate = settings.contentTemplate;

  			/**
  			 * override class
  			 */
  			settings.windowClass = settings.windowClass || "";
  			settings.windowClass += " " + settings.type;
  			settings.windowClass += " " + settings.size;

  			/**
  			 * define modal template
  			 */
  			if (!settings.templateUrl) {
  			  settings.templateUrl = "./shared/modal/modal.tpl.html";  				
				}
  			/**
  			 * define modal controller
  			 */
				if(!settings.controller){
					settings.controller = ["$scope", "$uibModalInstance",function($scope, $uibModalInstance) {
						
						$scope.uiAction = function(actionName){							
							$uibModalInstance.close(actionName);							
						};

						$scope.$on('modal.closing',function(e,args){
							if(args==="escape key press"){
								e.defaultPrevented = true;
							}							
						});
						/**
						 * bind properties
						 */
						$scope.options = options;
						$scope.data = {};
						angular.extend($scope.data, customOptions.data);
					}];
				}
  
  			return $uibModal.open(settings).result;
      	  
    	};
    	
    	/**
    	 * @ngdoc method
    	 * @name iscModal#showErrorMessage
    	 * @description The showErrorMessage displays the error message in modal window
    	 * 
    	 * @param {string} message Error message to be displayed
			 * @param {object} customOptions override options by screens
			 *
			 * @returns {object} Modal promise object
    	 */
    	iscModal.showErrorMessage = function(message,customOptions){
    		var error = { 
    					options: { 
    						headerText: "modal.TITLE_Error",
    						headerIconCss: "app-glyphicons app-icon-error_30",
    						action:[
    						  {
    						    actionName:"OK",
    						    actionLabel:"modal.BUTTON_Ok"
    						  }
    						]
    					},
    					settings: { 
    						size: "md", 
    						type: "error" 
    					}, 
    					data: { 
    						text: message 
    					} 
    				};
				if(customOptions && customOptions.options){
    			angular.extend(error.options, customOptions.options);
    		}
    		if(customOptions && customOptions.data){
    			angular.extend(error.data, customOptions.data);
    		}
    		if(customOptions && customOptions.settings){
    			angular.extend(error.settings, customOptions.settings);
    		}
    		return iscModal.openMessage(error);		
    	};
    	
    	
    	/**
    	 * @ngdoc method
    	 * @name iscModal#showWarningMessage
    	 * @description The showWarningMessage displays the warning message in modal window
    	 * 
    	 * @param {string} message Warning message to be displayed
			 * @param {object} customOptions override options by screens    
			 *
			 * @returns {object} Modal promise object
    	 */
    	iscModal.showWarningMessage = function(message,customOptions){
    		var warning = { 
    					options: { 
    						headerText: "modal.TITLE_Warning",
    						headerIconCss: "app-glyphicons app-icon-warning_30",
    						action:[
    						  {
    						    actionName:"OK",
    						    actionLabel:"modal.BUTTON_Ok"
    						  }
    						]
    					},
    					settings: { 
    						size: "md", 
    						type: "warning" 
    					}, 
    					data: { 
    						text: message 
    					} 
    				};
				if(customOptions && customOptions.options){
    			angular.extend(warning.options, customOptions.options);
    		}
    		if(customOptions && customOptions.data){
    			angular.extend(warning.data, customOptions.data);
    		}
    		if(customOptions && customOptions.settings){
    			angular.extend(warning.settings, customOptions.settings);
    		}
    		return iscModal.openMessage(warning);		
    	};
    	
    	/**
    	 * @ngdoc method
    	 * @name iscModal#showConfirmationMessage
    	 * @description The showConfirmationMessage displays the confirmation message in modal window
    	 * 
    	 * @param {string} message Confirmation message to be displayed
    	 * @param {object} customOptions override options by screens        
			 *
			 * @returns {object} Modal promise object
    	 */
    	iscModal.showConfirmationMessage = function(message,customOptions){
    		var confirm = { 
    					options: { 
    					headerText: "modal.TITLE_Confirmation",
    					headerIconCss: "app-glyphicons app-icon-about_30",
    						action:[
    						  {
    						    actionName:"YES",
    						    actionLabel:"modal.BUTTON_Yes"
    						  },
    						  {
    						    actionName:"NO",
    						    actionLabel:"modal.BUTTON_No"
    						  }
    						]
    					},
    					settings: { 
    						size: "md", 
    						type: "confirmation" 
    					}, 
    					data: { 
    						text: message 
    					} 
    				};
				if(customOptions && customOptions.options){
    			angular.extend(confirm.options, customOptions.options);
    		}
    		if(customOptions && customOptions.data){
    			angular.extend(confirm.data, customOptions.data);
    		}
    		if(customOptions && customOptions.settings){
    			angular.extend(confirm.settings, customOptions.settings);
    		}
    		return iscModal.openMessage(confirm);		
    	};
    	
    	/**
    	 * @ngdoc method
    	 * @name iscModal#showSuccessMessage
    	 * @description The showSuccessMessage displays the success message in modal window
    	 * 
    	 * @param {string} message Success message to be displayed
    	 * @param {object} customOptions override options by screens    	 
			 *
			 * @returns {object} Modal promise object
    	 */
    	iscModal.showSuccessMessage = function(message,customOptions){
    		var success = { 
    					options: { 
    						headerText: "modal.TITLE_Success",
    						headerIconCss: "app-glyphicons app-icon-success_ok_30",
    						action:[
    						  {
    						    actionName:"OK",
    						    actionLabel:"modal.BUTTON_Ok"
    						  }
    						]
    					},
    					settings: { 
    						size: "md", 
    						type: "success" 
    					}, 
    					data: { 
    						text: message 
    					} 
    				};
				if(customOptions && customOptions.options){
    			angular.extend(success.options, customOptions.options);
    		}
    		if(customOptions && customOptions.data){
    			angular.extend(success.data, customOptions.data);
    		}
    		if(customOptions && customOptions.settings){
    			angular.extend(success.settings, customOptions.settings);
    		}
    		return iscModal.openMessage(success);		
    	};
    	
    	
    	/**
    	 * @ngdoc method
    	 * @name iscModal#showInfoMessage
    	 * @description The showInfoMessage displays the success message in modal window
    	 * 
    	 * @param {string} message Info message to be displayed
    	 * @param {object} customOptions override options by screens      	
			 *
			 * @returns {object} Modal promise object
    	 */
    	iscModal.showInfoMessage = function(message,customOptions){
    		var info = { 
    					options: { 
    						headerText: "modal.TITLE_Info",
    						headerIconCss: "app-glyphicons app-icon-about_30",
    						action:[
    						  {
    						    actionName:"OK",
    						    actionLabel:"modal.BUTTON_Ok"
    						  }
    						]
    					},
    					settings: { 
    						size: "md", 
    						type: "information" 
    					}, 
    					data: { 
    						text: message 
    					} 
    				};
				if(customOptions && customOptions.options){
    			angular.extend(info.options, customOptions.options);
    		}
    		if(customOptions && customOptions.data){
    			angular.extend(info.data, customOptions.data);
    		}
    		if(customOptions && customOptions.settings){
    			angular.extend(info.settings, customOptions.settings);
    		}
    		return iscModal.openMessage(info);		
    	};
    	
    	/**
    	 * @ngdoc method
    	 * @name iscModal#showCustomMessage
    	 * @description The showCustomMessage displays the custom message in modal window
    	 * 
    	 * @param {object} customOptions options passed to show the message
			 *
			 * @returns {object} Modal promise object
    	 */
    	iscModal.showCustomMessage = function(options){
    		return iscModal.openMessage(options);		
    	};
		
		/**
    	 * @ngdoc method
    	 * @name iscModal#showA11YAlertMessage
    	 * @description Adds the message provided into the alert panel. This alert message can only read by a screen reader but cannot be seen on the user interface.
    	 * 
    	 * @param {string} message Alert message to be read by the screen reader
    	 * @param {string} messageType Optional parameter. Defaults to 'success'. Other possible value: warning
		 *
    	 */
		iscModal.showA11YAlertMessage = function(message,messageType) {
			if(!messageType) messageType = 'success';
			$rootScope.ui.alertMessageType = messageType;
			$rootScope.ui.showAlertMessage = true;
			$rootScope.ui.isA11YAlertMessage = true;
			$rootScope.ui.alertMessage = message;
		}
		
		/**
    	 * @ngdoc method
    	 * @name iscModal#showAlertMessage
    	 * @description Adds the message provided into the alert panel. The alert panel is closed when the 'Close' button is clicked or when a new mashup call is made. 
    	 * 
    	 * @param {string} message Alert message to be shown to the user
    	 * @param {string} messageType Optional parameter. Defaults to 'success'. Other possible value: warning
		 *
    	 */
		iscModal.showAlertMessage = function(message,messageType) {
			if(!messageType) messageType = 'success';
			$rootScope.ui.alertMessageType = messageType;
			$rootScope.ui.showAlertMessage = true;
			$rootScope.ui.isA11YAlertMessage = false;
			$rootScope.ui.alertMessage = message;
		}
    	
    	return iscModal;
    }];
  });
})(window.iscCore);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp. 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
/**
 * @ngdoc provider
 * @name iscCordova
 * @description
 * Use the `iscCordovaProvider` to register the initialization of cordova plugins
 */


(function(iscCore){
  'use strict';
  angular.module('isc.shared').provider('iscCordova', function() {
    
    var _pluginInitializationCtrls = [];
      
     /**
     * @ngdoc method
     * @name iscCordovaProvider#registerPluginInitialization
     * @description
     * The addTask method adds the function to execute when the deviceready event is fired from cordova
     * @param {array} pluginInitializationFuntion Function which contains logic for cordova plugin initialization
     * @example
        
      	
      	iscCordovaProvider.registerPluginInitialization(["iscBarcodeScanner",function(iscBarcodeScanner){}]);	
     */
    this.registerPluginInitialization = function(ctrlArray){
        _pluginInitializationCtrls.push(ctrlArray);
    };
    
    this.$get = function () {
    	var that = this;
        
        var _initializePlugins = function(){
            
            for(var i=0; i<_pluginInitializationCtrls.length; i++ ){
                var _ctrl = _pluginInitializationCtrls[i];
                angular.element(document).injector().invoke(_ctrl,null,null);
            }
            
        }
        
        return {
      		initializePlugins : _initializePlugins
    	};
    };
  });
})(window.iscCore);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp. 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/


(function(iscCore) {
	"use strict";
	
	var iscPersonaPvdr = {};
	
	var _usePersonaBasedHomePage = false;
	var _sortedProcessedPersonaList = [];
	var _rawListObj = {};
	var _currentPersona = "";
	var _personaSwitchActionMap = {};
	
	var _ootbPersonaList = ["Customer_Service", "Manager_Dashboard", "Order_Fulfillment", "Dojo_Order_Fulfill"];
	var _personaToResourceIdListStr_visiblePortletsOnly = {
		"_oldSpec": ""
	};// old spec portlets will have personaName in this map as "_oldSpec".
	
	iscPersonaPvdr.setUsePersonaBasedHomepageFlag = function(usePersonaHomePage) {
		_usePersonaBasedHomePage = usePersonaHomePage;
	};
	
	iscPersonaPvdr.validateAndSetPersonaList = function(personaList) {
		_rawListObj = personaList;
		if (_rawListObj != null && _rawListObj.CommonCodeList != null && _rawListObj.CommonCodeList.CommonCode != null) {
			_sortedProcessedPersonaList = angular.copy(_rawListObj);
			_sortedProcessedPersonaList = _sortedProcessedPersonaList.CommonCodeList.CommonCode;
			//sort
			_sortedProcessedPersonaList.sort(function(a, b) {
				return (parseInt(a["CodeValue"]) - parseInt(b["CodeValue"]));
			});
			//"CodeName" can not be empty from SBC. But from API can be made blank. Remove entries with empty "CodeName".
			_sortedProcessedPersonaList = _sortedProcessedPersonaList.filter(function(a) {
				return (!iscCore.isVoid(a["CodeName"]));
			});
		}
	};
	
	iscPersonaPvdr.validateAndSetCurrentPersona = function(currentPersona) {
		// "Dojo_Order_Fulfill" does not ever become currentPersona. NOTE: User's persona can be 1st or it will be "Customer_Service".
		var index = 0;
		while (currentPersona === "" || currentPersona === "Dojo_Order_Fulfill") {
			currentPersona = _sortedProcessedPersonaList[index]["CodeName"];
			index++;
		}
		_currentPersona = currentPersona;
	};
	
	iscPersonaPvdr.updateLandingPageStateAndCurrentPersona = function(landingPageState) {
		// Customer persona is handled by customer using setLandingPageState() in custom jsp.
		if (landingPageState === "/manager-dashboard" || _currentPersona === "Manager_Dashboard") {
			_currentPersona = "Manager_Dashboard";
			landingPageState = "/manager-dashboard";
		}
		return landingPageState;
	};
	
	iscPersonaPvdr.registerActionForPersonaSwitch = function(personaName, methodToCall) {
		/* We could have exposed a way for customer to register their state for persona, but we may have a scenario where customer
		 * wants to move out of application or to another url on click of persona. Thus, they must do a 2 step way: call this method
		 * and then setLandingPageState() in custom jsp.
		 */
		var retStatus = false;
		if (!iscPersonaPvdr.isOOTBPersona(personaName) && typeof methodToCall === "function") {
			retStatus = true;
			_personaSwitchActionMap[personaName] = methodToCall;
		}
		return retStatus;
	};
	
	iscPersonaPvdr.isSpecialPersona = function(personaName) {
		// Manager_Dashboard and Dojo_Order_Fulfill - special personas, cant register portlets against this.
		if (personaName === "Manager_Dashboard" || personaName === "Dojo_Order_Fulfill") {
			return true;
		}
		return false;
	};
	
	iscPersonaPvdr.isOOTBPersona = function(personaName) {
		var retVal = false;
		for (var i = 0; i < _ootbPersonaList.length; i++) {
			if (_ootbPersonaList[i] === personaName) {
				retVal = true;
				break;
			}
		}
		return retVal;
	};
	
	iscPersonaPvdr.getPersonaSwitchAction = function(personaName) {
		return _personaSwitchActionMap[personaName];
	};
	
	iscPersonaPvdr.getUsePersonaBasedHomepageFlagValue = function() {
		return _usePersonaBasedHomePage;
	};
	
	iscPersonaPvdr.getPersonaList = function() {
		return _sortedProcessedPersonaList;
	};

	iscPersonaPvdr.getCurrentPersona = function() {
		return _currentPersona;
	};
	
	iscPersonaPvdr.updateCurrentPersona = function(newPersona) {
		_currentPersona = newPersona;
	};
	
	iscPersonaPvdr.setSpecialPersonaPermissions = function(personaName, resourceIdString, override) {
		if (!iscPersonaPvdr.isSpecialPersona(personaName)) {
			console.warn("setSpecialPersonaPermissions() can only be used to add/override permissions for special personas: 'Manager_Dashboard' and 'Dojo_Order_Fulfill'. Received persona as: '%s'. Thus, ignoring permission update. Use portlet extensibility to add new permissions to passed persona.", personaName);
			return;
		}
		iscPersonaPvdr.updatePersonaToResourceIdList(personaName, resourceIdString, override);
	};
	
	iscPersonaPvdr.updatePersonaToResourceIdList = function(personaName, resourceIdToAdd, override) {
		if (iscCore.isVoid(_personaToResourceIdListStr_visiblePortletsOnly[personaName]) || override === true) {
			_personaToResourceIdListStr_visiblePortletsOnly[personaName] = resourceIdToAdd;
		} else {
			_personaToResourceIdListStr_visiblePortletsOnly[personaName] = _personaToResourceIdListStr_visiblePortletsOnly[personaName] + "|" + resourceIdToAdd;
		}
	};
	
	iscPersonaPvdr.getAllPersonaToResourceIdListForVisiblePortlets = function() {
		return _personaToResourceIdListStr_visiblePortletsOnly;
	};
	
	iscCore.iscPersonaPvdr = iscPersonaPvdr;
})(window.iscCore);


(function(iscCore) {
	"use strict";

	/**
	 * @ngdoc provider
	 * @name iscPersonaProvider
	 * @description
	 * Use the 'iscPersonaProvider' to set persona related information like list, default persona and home page mode.
	 */
	angular.module("isc.shared").provider("iscPersona", function() {
		
		/**
		 * @ngdoc method
		 * @name iscPersonaProvider#setUsePersonaBasedHomepageFlag
		 * @description
		 * This sets if we want the home page to use the new persona based layout or old one.
		 * @param usePersonaHomePage {boolean} true to use new persona based home page, false to use old fixed layout.
		 * @example			
				iscPersonaProvider.setUsePersonaBasedHomepageFlag(usePersonaHomePage);
		 */
		this.setUsePersonaBasedHomepageFlag = iscCore.iscPersonaPvdr.setUsePersonaBasedHomepageFlag;
	  	
		/**
		 * @ngdoc method
		 * @name iscPersonaProvider#validateAndSetPersonaList
		 * @description
		 * This method validates to remove personas with empty CodeName and then persists the entire persona list.
		 * @param personaList {array} Json array containing a list of all the available personas.
		 * @example			
				iscPersonaProvider.validateAndSetPersonaList(personaList);
		 */
		this.validateAndSetPersonaList = iscCore.iscPersonaPvdr.validateAndSetPersonaList;
		
		/**
		 * @ngdoc method
		 * @name iscPersonaProvider#validateAndSetCurrentPersona
		 * @description
		 * This sets the persona that will apply to logged in user - for new persona based home page. It computes
		 * value based on some considerations.
		 * @param currentPersona {string} Set the current persona to display for new persona based home page.
		 * 
		 * @example			
				iscPersonaProvider.validateAndSetCurrentPersona(currentPersona);
		 */
		this.validateAndSetCurrentPersona = iscCore.iscPersonaPvdr.validateAndSetCurrentPersona;
		
		/**
		 * @ngdoc method
		 * @name iscPersonaProvider#updateLandingPageStateAndCurrentPersona
		 * @description
		 * This considers the current landing page state and updates the current persona if required. Likewise, the
		 * landingPageState is also updated and returned. This is done mainly when user navigates from dojo and 
		 * selects one of the options there to navigate to Angular. Manager dashboard has a different state from normal
		 * home page. And this method determines all the considerations and sets the correct values for both.
		 * @param landingPageState {string} The landing page state passed.
		 * 
		 * @returns {string} landingPageState - the updated landing page state.
		 * 
		 * @example			
				iscPersonaProvider.updateLandingPageStateAndCurrentPersona(landingPageState);
		 */
		this.updateLandingPageStateAndCurrentPersona = iscCore.iscPersonaPvdr.updateLandingPageStateAndCurrentPersona;
				
		this.registerActionForPersonaSwitch = iscCore.iscPersonaPvdr.registerActionForPersonaSwitch;
		
		this.setSpecialPersonaPermissions = iscCore.iscPersonaPvdr.setSpecialPersonaPermissions;
	
		this.$get = function() {
			
			return {
				
				registerActionForPersonaSwitch: iscCore.iscPersonaPvdr.registerActionForPersonaSwitch,
				
				setSpecialPersonaPermissions: iscCore.iscPersonaPvdr.setSpecialPersonaPermissions,
				
				getUsePersonaBasedHomepageFlagValue: iscCore.iscPersonaPvdr.getUsePersonaBasedHomepageFlagValue,
				
				getPersonaList: iscCore.iscPersonaPvdr.getPersonaList,
				
				getCurrentPersona: iscCore.iscPersonaPvdr.getCurrentPersona,
				
				updateCurrentPersona: iscCore.iscPersonaPvdr.updateCurrentPersona,
				
				getPersonaSwitchAction: iscCore.iscPersonaPvdr.getPersonaSwitchAction,
				
				isSpecialPersona: iscCore.iscPersonaPvdr.isSpecialPersona,
				
				isOOTBPersona: iscCore.iscPersonaPvdr.isOOTBPersona,
				
				updatePersonaToResourceIdList: iscCore.iscPersonaPvdr.updatePersonaToResourceIdList,
				
				getAllPersonaToResourceIdListForVisiblePortlets: iscCore.iscPersonaPvdr.getAllPersonaToResourceIdListForVisiblePortlets
				
			};
		};
	});
})(window.iscCore);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp. 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
 
(function(iscCore) {
	"use strict";
	
	var iscPortletPvdr = {};
	
	var _portletConfig = {};
	var _customPortletConfig = {};
	var _moreTasksPortletConfig = {};
	var _arreyQ22017_ootbPortletNames = ["customerlookupportlet", "findproductsportlet", "instorereceivingportlet", "quickcheckoutportlet", "returnsportlet"];
	
	var _fn_isSpecialPersona = function(personaName) {
		// Manager_Dashboard and Dojo_Order_Fulfill - special personas, cant register portlets against this.
		if (personaName === "Manager_Dashboard" || personaName === "Dojo_Order_Fulfill") {
			return true;
		}
		return false;
	};
	
	var _fn_isQ22017_ootbPortlet = function(portletName) {
		var isOOTBLegacyPortlet = false;
		for (var i = 0; i < _arreyQ22017_ootbPortletNames.length; i++) {
			if (portletName === _arreyQ22017_ootbPortletNames[i]) {
				isOOTBLegacyPortlet = true;
				break;
			}
		}
		return isOOTBLegacyPortlet;
	};
	
	// Adds portletName to config json.
	iscPortletPvdr.registerPortlet = function(name, configJson) {
		if (_portletConfig[name] == null) {
			configJson["portletName"] = name;
			_portletConfig[name] = configJson;
		} else {
			console.warn("A portlet with the name: '%s' already exists! Can't re-register a new portlet with the same name. Ignoring the new entry.", name);
		}
	};
	// Adds portletName to config json.
	iscPortletPvdr.registerCustomPortlet = function(customName, customConfigJson) {
		if (typeof customName !== "string") {
			console.warn("A custom portlet can not have name that has any other type other than string. Ignoring this entry.");
			return;
		} else if (iscCore.isVoid(customName)) {
			console.warn("A custom portlet can not have null or empty string as name. Ignoring this entry.");
			return;
		} else if (customName === "moretasksportlet") {
			// moretasksportlet - name is taken. No other portlet can be reigstered. Even custom. Neither can this be customized at all.
			console.warn("'moretasksportlet' is a special portlet! It can not be customized/overridden. Ignoring entry.");
			return;
		} else if (iscPortletPvdr.isNewSpecPortlet(customConfigJson)) {
			// Does not really matter, if new spec or old or NEW or OVERRIDE. Just here for ease of checking if there personaConfig.personaName, it has some restrictions.
			if (_fn_isSpecialPersona(customConfigJson["personaConfig"]["personaName"])) {
				console.warn("'personaName' can not be 'Manager_Dashboard' or 'Dojo_Order_Fulfill'! Ignoring entry with name: '%s'.", customName);
				return;
			}
		}
			
		if (_customPortletConfig[customName] == null) {
			customConfigJson["portletName"] = customName;
			_customPortletConfig[customName] = customConfigJson;
		} else {
			console.warn("A custom portlet with the name: '%s' already exists! Can't re-register a new custom portlet with the same name. Ignoring the new entry.", customName);
		}
	};
	
	// This method is required only for BC - when "usePersonaBasedHomepage" is false. Caller determines that condition.
	iscPortletPvdr.getAllVisibleSortedPortlets = function() {
		var visibleSortedPortletsArray = [];
		// Customer can override properties of OOTB portlet. We only allow sequenceNumber, showPortlet and resourceId.
		for (var cn in _customPortletConfig) {
			if (iscPortletPvdr.isNewSpecPortlet(_customPortletConfig[cn])) {
				continue;
			}
			if (_portletConfig[cn] == null && _customPortletConfig[cn]["showPortlet"] === true) {
				visibleSortedPortletsArray.push(_customPortletConfig[cn]);
			} else if (_portletConfig[cn] != null) {
				_portletConfig[cn]["sequenceNumber"] = (_customPortletConfig[cn]["sequenceNumber"]) != null ? _customPortletConfig[cn]["sequenceNumber"] : _portletConfig[cn]["sequenceNumber"];
				_portletConfig[cn]["showPortlet"] = (_customPortletConfig[cn]["showPortlet"]) != null ? _customPortletConfig[cn]["showPortlet"] : _portletConfig[cn]["showPortlet"];
				_portletConfig[cn]["resourceId"] = (_customPortletConfig[cn]["resourceId"]) != null ? _customPortletConfig[cn]["resourceId"] : _portletConfig[cn]["resourceId"];
			}
		}
		for (var n in _portletConfig) {
			if (_fn_isQ22017_ootbPortlet(n) && _portletConfig[n]["showPortlet"] === true) {
				visibleSortedPortletsArray.push(_portletConfig[n]);
			}
		}
		visibleSortedPortletsArray.sort(function(a, b) {
			return (a["sequenceNumber"] - b["sequenceNumber"]);
		});
		return visibleSortedPortletsArray;
	};
	
	iscPortletPvdr.isNewSpecPortlet = function(portletDefJson) {
		var isPersonaConfigAnObj = false;
		portletDefJson = portletDefJson || {};
		var personaConfig = portletDefJson["personaConfig"];
		if (!personaConfig) return false;
		var personaConfigName = personaConfig.constructor.name;
		if(personaConfigName){
			isPersonaConfigAnObj = (personaConfigName.toLowerCase() === "object");
		}else {
			isPersonaConfigAnObj = (personaConfig instanceof Object);
		}
		return isPersonaConfigAnObj;
	};
	
	iscPortletPvdr.setConfigForMoreTasksPortlet = function(configJson) {
		_moreTasksPortletConfig = configJson;
	};
	
	iscPortletPvdr.getConfigForMoreTasksPortlet = function() {
		return _moreTasksPortletConfig;
	};
	
	iscPortletPvdr.getPortletConfig = function() {
		return angular.copy(_portletConfig);
	};
	
	iscPortletPvdr.getCustomPortletConfig = function() {
		return angular.copy(_customPortletConfig);
	};
		
	iscCore.iscPortletPvdr = iscPortletPvdr;
	
})(window.iscCore);

(function(iscCore) {
	"use strict";
	
	/**
	 * @ngdoc provider
	 * @name iscPortletPvdrProvider
	 * @description
	 * Use the iscPortletPvdrProvider to set the configuration for all the portlets to be displayed on the home page.
	 */
	
	angular.module("isc.shared").provider("iscPortletPvdr", function() {
		
		/**
		 * @ngdoc method
		 * @name iscPortletPvdrProvider#registerPortlet
		 * @description
		 * This method is used to add a new portlet to the home page. It must only be used for OOTB portlets.
		 * @param name {String} Logical name of the portlet. This must be unique for each portlet in the application. In case of 2 or more portlets having the same name, the 2nd portlet onwards will be ignored.
		 * @param configJson {object} This is the json configuration for various poroperties of the portlet. Supported attributes that are used are:
		 * 		- templateUrl {String} Mandatory. The url of the html template of the portlet.
		 * 		- controller {String} Mandatory. The name of the controller for the portlet.
		 * 		- sequenceNumber {Number} Portlets are sorted in ascending order of this number. Thus, smaller number means portlet will appear in the begining and larger number means portlet will be displayed later in the sequence. Should be given in multiples of 10 for OOTB portlets. For new spec portlets (from 17.3 release onwards) this is superceded by personaConfig.personaSequenceNumber.
		 * 		- showPortlet {Boolean} Mandatory. Flag to indicate if the portlet should be displayed on the UI. Setting it to false will not show the portlet on UI regardless of the user having permission to the resource id.
		 * 		- resourceId {String} The resource permission for the portlet. Multiple resource permissions can be combined with a pipe |. E.g.: 'WSC000015|WSC000012|WSC000028'. Portlet is shown if user has permission to view at least one of the resource ids given.
		 *		- personaConfig {object} This is a new json configuration that determines if a portlet is new spec portlet (17.3 onwards). If not defined, portlet is treated as old spec portlet. It contains the attributes that are necessary to make persona related rendering decisions. Supported attributes are:
		 *			- personaName {String} Mandatory. This is the name of a persona that has been defined in SBC. It corresponds to the CodeName for the CommonCode CodeType "WSC_HOMEPAGE_PERSONA". It is used on the UI to determine if the portlet should be one of the available portlets for the currently selected persona. It is only considered in the list if the personaName matches the currently selected persona. This attribute does not guarantee visibility. Visibility is determined by a combination of showPortlet and resourceId.
		 *			- personaSequenceNumber {Number} Mandatory. This supercedes the sequenceNumber attribute for new spec portlets (17.3 onwards). It must be given in multiples of 5 for OOTB portlets. All visible portlets for the same persona will be arranged in the ascending order of this number.
		 *			- miniViewTemplateUrl {String} Mandatory. The url of the template used to create the mini/small view of the portlet when it overflows into the More Tasks portlet.
		 *			- miniViewController {String} Mandatory. The name of the controller used to make mashup/API calls to display numbers on the mini/small view of the portlet when it overflows into the More Tasks portlet.
		 *		- sitemapConfig {object} This json configuration is used to create the links, associated text and action method to call on click in the sitemap controller. It is mandatory only for OOTB portlets. Custom portlets may choose to ignore this parameter. This may be an array of objects with below mentioned attributes in case your portlet requires more than one sitemap links. Supported arguments are:
		 *			- sitemapTitleKey {String} The title key for the title to display in sitemap screen. We get the globalized value for this key.
		 *			- sitemapLinkKey {String} The link key for the title to display on sitemap screen. We get the globalized value for this key.
		 *			- sitemapLinkActionMethod {String} The method to call on the sitemap controller when the link is clicked.
		 *			- resourceId {String} By default, we use the resourceId defined on the portlet. However, use this attribute in case some other permissions are required. This is only true if your portlet creates multiple sitemaps and each link needs different permissions. If provided, these permissions will take priority. It is assumed that this will be a subset of the portlet permissions.
		 * 		
		 * @example			
				iscPortletPvdrProvider.registerPortlet('findproductsportlet', {
					templateUrl: './store/views/home/find-products-portlet.tpl.html',
					controller: 'store.views.home.find-products-portlet',
					sequenceNumber: 10,
					showPortlet: true,
					resourceId: 'WSC000031',
					personaConfig: {
						personaName: 'Customer_Service',
						personaSequenceNumber: 5,//these are in multiples of 5.
						miniViewTemplateUrl: './store/views/home/find-products-portlet-mini.tpl.html',
						miniViewController: 'store.views.home.find-products-portlet-mini'
					},
					// optional for non-OOTB
					sitemapConfig: {
						sitemapTitleKey: 'home.TITLE_Order',
						sitemapLinkKey: 'home.TITLE_FindProducts',
						sitemapLinkActionMethod: 'uiOpenFindProducts'
					}
				});
		 */
		this.registerPortlet = iscCore.iscPortletPvdr.registerPortlet;
		
		/**
		 * @ngdoc method
		 * @name iscPortletPvdrProvider#registerCustomPortlet
		 * @description
		 * This method is used to add a new portlet to the home page. It must only be used by the customer to register new portlet or override the following OOTB portlet configuration attributes: sequenceNumber, showPortlet, resourceId and personaConfig.
		 NOTE: while using this method, ENSURE that your portlet name does not conflict with any OOTB portlets. This be ensured by adding an "extn_" before or towards the end of the name of the portlet being defined as a new portlet or to override an OOTB portlet. E.g.: instead of naming your portlet as "find-products-portlet.config.js" which will clash with the name of OOTB portlet, change the name of your portlet as "extn_find-products-portlet.config.js" or "find-products-portlet_extn.config.js". Same applies to miniViewTemplateUrl and miniViewController if defined for custom portlet. It is recommended to follow this guideline for all portlets defined, including the old spec portlets (before 17.3).
		 * @param customName {String} Logical name of the portlet. This must be unique for each portlet in the application. In case of 2 or more custom portlets having the same name, the 2nd portlet onwards will be ignored. However, sequenceNumber, showPortlet, resourceId and personaConfig attributes of an OOTB portlet can be overridden using this method by passing the OOTB portlet name. NOTE: The customName can not be "moretasksportlet". This is application reserved.
		 * @param customConfigJson {object} This is the json configuration for various properties of the portlet. Supported attributes that are used are:
		 * 		- templateUrl {String} Mandatory for new custom portlet. The url of the html template of the portlet. Ignored if passed to override an OOTB portlet.
		 * 		- controller {String} Mandatory for new custom portlet. The name of the controller for the portlet. Ignored if passed to override an OOTB portlet.
		 * 		- sequenceNumber {Number} Portlets are sorted in ascending order of this number. Thus, smaller number means portlet will appear in the begining and larger number means portlet will be displayed later in the sequence. Should not be given in multiples of 10 for custom portlets. Can be passed to override corresponding value for an OOTB portlet. For new spec portlets (from 17.3 release onwards) this is superceded by personaConfig.personaSequenceNumber.
		 * 		- showPortlet {Boolean} Mandatory  or new custom portlet. Flag to indicate if the portlet should be displayed on the UI. Setting it to false will not show the portlet on UI regardless of the user having permission to the resource id. Can be passed to override corresponding value for an OOTB portlet.
		 * 		- resourceId {String} Mandatory for new custom portlet. The resource permission for the portlet. Multiple resource permissions can be combined with a pipe |. E.g.: 'EXTN000015|EXTN000012|EXTN000028'. Portlet is shown if user has permission to view at least one of the resource ids given. Can be passed to override corresponding value for an OOTB portlet.
		 *		- personaConfig {object} Mandatory for new custom portlet. This is a new json configuration that determines if a portlet is new spec portlet (17.3 onwards). If not defined, portlet is treated as old spec portlet. It contains the attributes that are necessary to make persona related rendering decisions. Supported attributes are:
		 *			- personaName {String} Mandatory for new custom portlet. This is the name of a persona that has been defined in SBC. It corresponds to the CodeName for the CommonCode CodeType "WSC_HOMEPAGE_PERSONA". It is used on the UI to determine if the portlet should be one of the available portlets for the currently selected persona. It is only considered in the list if the personaName matches the currently selected persona. This attribute does not guarantee visibility. Visibility is determined by a combination of showPortlet and resourceId.
		 *			- personaSequenceNumber {Number} Mandatory for new custom portlet. This supercedes the sequenceNumber attribute for new spec portlets (17.3 onwards). It must be given in multiples of 5 for OOTB portlets. All visible portlets for the same persona will be arranged in the ascending order of this number.
		 *			- miniViewTemplateUrl {String} Mandatory for new custom portlet. The url of the template used to create the mini/small view of the portlet when it overflows into the More Tasks portlet.
		 *			- miniViewController {String} Mandatory for new custom portlet. The name of the controller used to make mashup/API calls to display numbers on the mini/small view of the portlet when it overflows into the More Tasks portlet.
		 * 
		 * @example	
		 *	To register a new portlet (new spec):		
				iscPortletPvdrProvider.registerCustomPortlet('extnfindproductsportlet', {
					templateUrl: './store/views/home/extn_find-products-portlet.tpl.html',
					controller: 'store.views.home.extn_find-products-portlet',
					showPortlet: true,
					resourceId: 'EXTN000031',
					personaConfig: {
						personaName: 'Customer_Service',
						personaSequenceNumber: 11,//these are in non-multiples of 5.
						miniViewTemplateUrl: './store/views/home/extn_find-products-portlet-mini.tpl.html',
						miniViewController: 'store.views.home.extn_find-products-portlet-mini'
					}
			    });
			    
			To override an OOTB portlet (new spec) - change permission, persona and personaSequenceNumber:
				iscPortletPvdrProvider.registerCustomPortlet('findproductsportlet', {
					resourceId: 'EXTN000071',
					personaConfig: {
						personaName: 'Custom_Customer_Service',//this is assumed to be a new persona added to SBC.
						personaSequenceNumber: 11//these are in non-multiples of 5.
					}
			    });
		 */
		this.registerCustomPortlet = iscCore.iscPortletPvdr.registerCustomPortlet;
		
		this.$get = function() {
			/**
		     * @ngdoc service       
		     * @name iscPortletPvdr       
		     * 
		     * @description
		     * The iscPortletPvdr is used to get a sorted list of visible portlets to be displayed on the home page.
		     */
			return {
				/**
				 * @ngdoc method
				 * @name iscPortletPvdr#getAllVisibleSortedPortlets
				 * @description
				 * Returns an array of all the portlets that are marked as visible i.e. showPortlet: true. These portlets are sorted in ascending order of the sequenceNumber attribute.
				 *
				 * @returns {array} visibleSortedPortletsArray
				 */
				getAllVisibleSortedPortlets: iscCore.iscPortletPvdr.getAllVisibleSortedPortlets,
				
				isNewSpecPortlet: iscCore.iscPortletPvdr.isNewSpecPortlet,
				
				setConfigForMoreTasksPortlet: iscCore.iscPortletPvdr.setConfigForMoreTasksPortlet,
				
				getConfigForMoreTasksPortlet: iscCore.iscPortletPvdr.getConfigForMoreTasksPortlet,
				
				getPortletConfig: iscCore.iscPortletPvdr.getPortletConfig,
				
				getCustomPortletConfig: iscCore.iscPortletPvdr.getCustomPortletConfig
				
			};
		};
	});
})(window.iscCore);
/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp. 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/



(function(iscCore){
    
    
    
    angular.module("isc.shared").provider("iscRecommendations",[function(){
        
        /**
		 * 	@ngdoc provider
		 * 	@name iscRecommendationsProvider
		 * 	@description
		 *	Configures the Digital Recommendations options.
		 */
        this.$get = [function(){
			/**
			 * @ngdoc service
			 * @name iscRecommendations
			 *
			 * @description
			 *	Provides utilities for recommendation operations
			 */
			return {
				/**
				 * @ngdoc method
				 * @name iscRecommendations#getItemIdForRecommendationsFromOrderList
				 *
				 * @param orderList {Object} Order List data
				 *
				 * @description
				 * Returns ItemIDs that needs to passed for Digital Recommendations 
				 *
				 * @returns {String} The String containing concatinated Item Ids seperated by '|'
				 */
				getItemIdForRecommendationsFromOrderList : function(orderList){
                    var itemIds = {};
                    var first = true;
                    for(var i=0;i<orderList.OrderList.Order.length;i++){
                        var order = orderList.OrderList.Order[i];
                        for(var j=0;j<order.OrderLines.OrderLine.length;j++){
                            var orderLine = order.OrderLines.OrderLine[j];
                            //if(!Object.hasKey(orderLine.ItemDetails.ItemID,itemIds)){
                            if(!itemIds.hasOwnProperty(orderLine.ItemDetails.ItemID,itemIds)){
                                itemIds[orderLine.ItemDetails.ItemID]=0;
                            }
                            itemIds[orderLine.ItemDetails.ItemID]++;
                        }

                    }
                    console.log(itemIds);
                    return itemIds;
                },
                /**
				 * @ngdoc method
				 * @name iscRecommendations#getItemIdForRecommendationsFromOrderLineList
				 *
				 * @param orderList {Object} Order List data
				 *
				 * @description
				 * Returns ItemIDs that needs to passed for Digital Recommendations 
				 *
				 * @returns {String} The String containing concatinated Item Ids seperated by '|'
				 */
                getItemIdForRecommendationsFromOrderLineList : function(orderLineList){
                    var itemIds = {};
                    for(var j=0;j<orderLineList.OrderLines.OrderLine.length;j++){
                        var orderLine = orderLineList.OrderLines.OrderLine[j];
                        //if(!Object.hasKey(orderLine.ItemDetails.ItemID,itemIds)){
                        if(!itemIds.hasOwnProperty(orderLine.ItemDetails.ItemID,itemIds)){
                            itemIds[orderLine.ItemDetails.ItemID]=0;
                        }
                        itemIds[orderLine.ItemDetails.ItemID]++;
                    }
                    console.log(itemIds);
                    return itemIds;
                },
                
                /**
				 * @ngdoc method
				 * @name iscRecommendations#getRecommendationsInputFromOrderLineList
				 *
				 * @param orderLineList {Object} Order Line List data
                 * @param noOfItemsToInclude {Number} No of uniquie Items to include in the json input
				 *
				 * @description
				 * Returns JSON object containing input for YCD_GetStoreRecommendedItemList service formed by OrderLineList data
				 *
				 * @returns {Object} The JSON object containing input for YCD_GetStoreRecommendedItemList service formed by OrderLineList data
				 */
                getRecommendationsInputFromOrderLineList : function(orderLineList,noOfItemsToInclude){
                    var recommendationsInput = {
                        Recommendations:{
                            ItemList:{
                                Item:[]
                            }
                        }
                    };
                    var itemIds = {};
                    var count = 0;
                    if(orderLineList.OrderLineList.TotalNumberOfRecords>0){
                        for(var j=0;j<orderLineList.OrderLineList.OrderLine.length;j++){
                            var orderLine = orderLineList.OrderLineList.OrderLine[j];
                            //if(!Object.hasKey(orderLine.ItemDetails.ItemID,itemIds)){
                            if(!itemIds.hasOwnProperty(orderLine.ItemDetails.ItemID,itemIds)){
                                count++;
                                itemIds[orderLine.ItemDetails.ItemID]=0;
                                recommendationsInput.Recommendations.ItemList.Item.push({ItemID:orderLine.ItemDetails.ItemID,UnitOfMeasure:orderLine.ItemDetails.UnitOfMeasure});
                            }
                            itemIds[orderLine.ItemDetails.ItemID]++;
                            if(count > noOfItemsToInclude -1 ){
                                break;
                            }
                        }
                    //console.log(itemIds);
                    }
                    
                    return recommendationsInput;
                },
				
				/**
				 * @ngdoc method
				 * @name iscRecommendations#getRecommendationsInputForOrder
				 *
				 * @param order {Object} order data containing list of all order lines
                 * @param noOfItemsToInclude {Number} No of uniquie items to include in the recommendation JSON input
				 *
				 * @description
				 * Returns JSON object containing input for YCD_StoreGetRecommendedItemList service. This JSON object will have list of all purchased products that will decide the recommended products. If an OrderLine is cancelled, its products are not considered for recommendations. This check is made for OrderLine's OrderedQty which will have value of zero in case of Cancelled line.
				 *
				 * @returns {Object} JSON object containing input for YCD_StoreGetRecommendedItemList service
				 */
				getRecommendationsInputForOrder : function(order,noOfItemsToInclude){
					var recommendationsInput = {
                        Recommendations:{
                            ItemList:{
                                Item:[]
                            }
                        }
                    };
                    var itemIds = {};
                    var count = 0;
                    if(order.OrderLines.TotalNumberOfRecords>0){
                        for(var j=0;j<order.OrderLines.OrderLine.length;j++){
                            var orderLine = order.OrderLines.OrderLine[j];
                            
							if(orderLine.OrderedQty > 0) {
								if(!itemIds.hasOwnProperty(orderLine.ItemDetails.ItemID,itemIds)){
									count++;
									itemIds[orderLine.ItemDetails.ItemID]=0;
									recommendationsInput.Recommendations.ItemList.Item.push({ItemID:orderLine.ItemDetails.ItemID,UnitOfMeasure:orderLine.ItemDetails.UnitOfMeasure});
								}
								itemIds[orderLine.ItemDetails.ItemID]++;
								if(count > noOfItemsToInclude -1 ){
									break;
								}
							}
                        }
                    }
                    return recommendationsInput;
				}
                
                
			};
		}];
        
        
    }])
    
    
    
})(window.iscCore);
/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp. 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/


(function(iscCore){
  'use strict';
  var _taskMap = {};
  
  iscCore.addTask = function(entity,flowName,config){
  	if(_taskMap[entity]===undefined){
  		_taskMap[entity]={};
  	}
  	_taskMap[entity][flowName] = config;
  };

  iscCore.getTask = function(entity){	  
	  return _taskMap[entity];
  };
  
  var _getTasks = function(entity,entityModel,filterFn){
		var relatedTasks = [];
		if(entityModel){
			var taskMap = iscCore.getTask(entity);				
			for(var key in taskMap){					
				var tasks = taskMap[key].tasks;
				for(var task in tasks){
					var _task = tasks[task].getTask(entityModel);
					if(filterFn(_task)){
                        var hasPermission = (!iscCore.isVoid(_task.resourcePermission) && iscCore.hasPermission(_task.resourcePermission)) || iscCore.isVoid(_task.resourcePermission);
						var hasRuleEnabled = (!iscCore.isVoid(_task.ruleName) && iscCore.isRuleEnabled(_task.ruleName)) || iscCore.isVoid(_task.ruleName);
                        if(hasPermission && hasRuleEnabled){
                            relatedTasks.push(_task);
                        }
						
					}
				}
			}
		}	
		return relatedTasks;
	};
    
    var _sortTasks = function(tasks){
        
    }
	
	iscCore.getAllTasks = function(entity,entityModel){
        
        var tasks = _getTasks(entity,entityModel,function(task){
                    return (!task.isHidden && !task.isDefault);		
                });
            
        tasks.sort(function(a, b){
                return a.sequence - b.sequence;
            });
		return tasks;
	};
	
	iscCore.getDefaultTask = function(entity,entityModel){
		return _getTasks(entity,entityModel,function(task){
			return task.isDefault;		
		});		
	};
	
	iscCore.getNextTasks = function(entity,entityModel){
		return _getTasks(entity,entityModel,function(task){
			return (!task.isDisabled && !task.isHidden);			
		});
	};
	iscCore.getPrimaryTasks = function(entity,entityModel){
		return _getTasks(entity,entityModel,function(task){
			return (task.isPrimary && !task.isDisabled);			
		});
	};
  
})(window.iscCore);




/**
 * @ngdoc provider
 * @name iscTasksProvider
 * @description
 * Use the `iscTasksProvider` to register the related tasks for entities
 */


(function(iscCore){
  'use strict';
  angular.module('isc.shared').provider('iscTask', function() {
    
    
     /**
     * @ngdoc method
     * @name iscTasksProvider#addTask
     * @description
     * The addTask method adds the task to registry based on entity and flow name
     * @param {string} entity Entity name
     * @param {string} flowName Flow name
     * @param {object} config Configuration object for task provider
     * @example
        var summaryTaskConfig = {
      		'tasks':[
      			{
      				'taskId':'viewShipment',
      				'taskName':'View Shipment Details',		
      				getTask:function(shipment){
      					var task = {};					
      					task.taskId = "viewShipment";
      					task.taskName = "shipmentsummary.ACTION_View_shipment_details";
      					task.actionUrl = "#/shipmentdetails/"+shipment.ShipmentKey;
      					task.isDisabled = false;
      					task.isPrimary = false;
      					task.isHidden = false;
      					task.isDefault = true;
      								
      					return task;
      				}
      			}
      		]
      	};
      	
      	iscTasksProvider.addTask('SHIPMENT','VIEWSUMMARY',summaryTaskConfig);	
     */
    this.addTask = iscCore.addTask;
    
    this.$get = function () {
    	var that = this;    
        return {
      		getAllTasks : iscCore.getAllTasks,
  	      getDefaultTask : iscCore.getDefaultTask,
  	      getNextTasks : iscCore.getNextTasks,
  	      getPrimaryTasks : iscCore.getPrimaryTasks
    	};
    };
  });
})(window.iscCore);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/



(function(iscCore){
  'use strict';
	var _resourceJson = {};
  
  iscCore.setResourcePermission = function(resourceJson){
		_resourceJson = resourceJson;		
	};
	
	iscCore.hasPermission = function(resourceId){
		if ( !resourceId ) {
			return true;
		}		
		if ( !_resourceJson ) {
			console.warn("resource set is undefined... returning false");
			return false;
		}		
		var permissions = _resourceJson[resourceId];
		var hasAnyPermissions = (permissions !== undefined);
		return hasAnyPermissions;		
	};
	
	iscCore.hasPermissionToOneOfTheResources = function(resourceIdArrStr) {
		var resourcesArray = (!resourceIdArrStr || resourceIdArrStr.indexOf("|") == -1) ? [resourceIdArrStr] : resourceIdArrStr.split("|");
		var hasPermissionValue = false;
		if (resourcesArray.length > 1) {
			for (var z = 0; z < resourcesArray.length; z++) {
				if (iscCore.hasPermission(resourcesArray[z])) {
					hasPermissionValue = true;
					break;
				}
			}
		} else {
			if (iscCore.hasPermission(resourceIdArrStr)) {
				hasPermissionValue = true;
			}
		}
		return hasPermissionValue;
	};
  
  
})(window.iscCore);






(function(iscCore){
  'use strict';

  
  /**
   * @ngdoc provider
   * @name iscResourcePermissionProvider
   * @description
   * Use the `iscResourcePermissionProvider` to register the resource permissions
   */

  angular.module('isc.shared').provider('iscResourcePermission', function() {
  	/**
  	 * @ngdoc method
  	 * @name iscResourcePermission#setResourcePermission
  	 * @description The setResourceJson set the resource permission in the re the modal-view inside a modal window
  	 * 
  	 * @param {object} resourceJson Resource list as json object
  	 */
  	this.setResourcePermission = iscCore.setResourcePermission;
  	
  	this.$get = function(){
  	  /**
       * 
       * @ngdoc service
       * @name iscResourcePermission
       * 
       * @description
       * The iscResourcePermission is the core service which facilitates checking resource permissions
       */
  	  return {
  	    /**
      	 * @ngdoc method
      	 * @name iscResourcePermission#hasPermission
      	 * @description The hasPermission checks for the given resource id , user has permission to it or not
      	 * 
      	 * @param {string} resourceId Resource id
      	 * @returns {boolean} Returns true if user has permission to the given resource id else returns false
      	 */
  	    hasPermission : iscCore.hasPermission,
  	    
  	    /**
      	 * @ngdoc method
      	 * @name iscResourcePermission#hasPermissionToOneOfTheResources
      	 * @description The hasPermissionToOneOfTheResources allows multiple resource ids separated by a '|' icon
      	 * e.g.: 'WSC000053|WSC000057|WSC000058'. It validates if the user has permission to atleast one of these
      	 * resources or not. It will also validate for a single resource id as well, though it is recommended to
      	 * use hasPermission() if this is known in advance.
      	 * 
      	 * @param {string} resourceIdArrStr Multiple resource ids separated by a '|'.
      	 * @returns {boolean} Returns true if user has permission to atleast one of the given resource ids else
      	 * returns false.
      	 */
  	    hasPermissionToOneOfTheResources : iscCore.hasPermissionToOneOfTheResources
  	  };
  	};
  	
  	
  	}	
  );

})(window.iscCore);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp.  2015, 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
(function(iscCore){
'use strict';

angular.module('isc.shared').provider('iscStateParams', function() {
	/**
	 * 	@ngdoc provider
	 * 	@name iscStateParamsProvider
	 *
	 * 	@description
	 *
	 *	Holds the parameters associated with the current state.
	 *
	 */
	 
	this.$get = function() {
		/**
		 * @ngdoc service
		 * @name iscStateParams
		 *
		 * @description
		 *	Holds the parameters associated with the current state.
		 *	Though there are many parameters associated with a state, this service returns only the stateData.params and stateData.options set for a state by the 'iscState' service.
		 *
		 * @example
		 *	angular.module('store', [])
			.controller('MainCtrl', ['iscStateParams',function(iscStateParams) {
				this.iscStateParams = iscStateParams;
			}]);
		 *
		 *	<!-- If the state transformation passes the 'params' and 'options', 
		 *
		 *	then the same can be printed on the view like this: -->
		 *	<!-- <pre>iscStateParams = {{MainCtrl.iscStateParams}}</pre> -->
		 *	<!--If the state transformation does not pass values for 'params' and 'options', 
		 *
		 * 'iscStateParams' will print en empty JSON object.-->
		 */
		return {}; 
	};
});

angular.module('isc.shared').provider('iscState', function() {
	/**
	 * 	@ngdoc provider
	 * 	@name iscStateProvider
	 *
	 * 	@description
	 *
	 *	Configures the states and the default state to load 
	 *	(when loading the page for the first time or when no state match is found).
	 *
	 */
	
	/**
	 * @ngdoc property
	 * @name iscStateProvider#states
	 * @description
	 *
	 * A JSON object to maintain the information regarding all the states.
	 * Key: unique path for a state
	 * Value: A JSON object containing values for templateUrl, addToHistory, controller and controllerAs
	 * @example
	 *	states = {"/home": {"controller":"store.home.controller","controllerAs":"HomeCtrl","addToHistory":"false",
	 "templateUrl":"./store/views/home/home.tpl.html"}}
	 */
	var states = {};
	
	/**
	 * @ngdoc property
	 * @name iscStateProvider#stateStack
	 * @description
	 *
	 * An array of states. This stack is used to push and pop states so that the "Back" button functionality can be achieved
	 */
	var stateStack = [];
	
	/**
	 * @ngdoc property
	 * @name iscStateProvider#currentStateInfo
	 * @description
	 * A JSON object to maintain the information regarding the current state : the path, parameters and options associated with a state
	 * @example
	 *	currentStateInfo = {"state" : "/home", 
	 "params" : {{"controller":"store.home.controller"}},"options":{"reload":"true"}
	 */
	var currentStateInfo ={};
	
	/**
	 * @ngdoc method
	 * @name iscStateProvider#state
	 *
	 * @param path {String} Unique path for a state. An error is thrown if a state is configured more than once.
	 * @param stateInfo {Object} The information regarding a state. Possible keys are: templateUrl, addToHistory,controller and controllerAs
	 * 'templateUrl' {String} corresponds to the HTML template associated with the state.
	 *	The URL to the template is relative to the deployment directory
	 * 'addToHistory'{Boolean} flag that denotes if the current state needs to be added to 'stateStack' or not
	 * 	If a state is not added to the stack, then on clicking the 'Back' button, the template corresponding to the state will not be loaded
	 * 	If this flag is not specified or if it is set to 'true', the state is added to the 'stateStack'
	 * 	'controller' {String} The controller associated with the template
	 * 	'controllerAs' {String} Logical name for the controller
	 *
	 * @returns {Object} self
	 *
	 * @description
	 * Configures all the states for the application.
	 */
	
	this.state = function(path, stateInfo) {
		var isPathDuplicate = this._checkPathPresent(path);
        if(!stateInfo.hasOwnProperty("addToHistory")){
           console.debug("State :"+path+" :: addToHistory property is missing")
        }
        if(!stateInfo.hasOwnProperty("resourceId")){
           console.debug("State :"+path+" :: resourceId property is missing")
        }
        if(!stateInfo.hasOwnProperty("templateUrl")){
           console.debug("State :"+path+" :: templateUrl property is missing")
        }
		if(!isPathDuplicate) {
			var stateCopy = angular.copy(stateInfo);
			states[path] = stateCopy;
		} else {
			//TODO: For now just logging the error. Need to figure the way to throw error and stopping the application to load
			console.error("The path : "+path+" was already configured.");
		}
		return this;
	}
	
	/**
	 * @ngdoc method
	 * @name iscStateProvider#otherwise
	 *
	 * @param path {String} Default path to redirect the application if no state matches or if no state is defined
	 * 
	 * @returns {Object} self
	 *
	 * @description
	 * Configures the default state for the application.
	 */
	
	this.otherwise = function(path) {
		if (path) {
			states.defaultPath = path; 
		}	
		return this;
	}
	
	/**
	 * @ngdoc method
	 * @name iscStateProvider#_checkPathPresent
	 *
	 * @param path {String} The state that needs to be checked for duplication
	 * 
	 * @returns {Boolean} True if the state is configured, False if not
	 *
	 * @description
	 * Returns a boolean that indicates if a given state is configured or not.
	 */
	
	this._checkPathPresent = function(path) {
		var pathIsDuplicate = false;
		angular.forEach(states, function(stateInfo,statePath) {
			if (path === statePath) {
				pathIsDuplicate = true;
			}
		});
		return pathIsDuplicate;
	}
	
	/**
	 * @ngdoc method
	 * @name iscStateProvider#extendState
	 *
	 * @param path {String} State whose configuration detail needs to be changed
	 * @param extensionInfo {String} Similar to the 'stateInfo' JSON object of the 'state' method 
	 * Only the existing properties of a state can be modified.
	 * 
	 * @returns {Object} self
	 *
	 * @description
	 * Extends the configuration data for an existing state. 
	 * A check is made to see if the state is configured before changing the configuration. An error is thrown otherwise.
	 */
	
	this.extendState = function(path, extensionInfo) {
		var isPathPresent = this._checkPathPresent(path);
		if(isPathPresent) {
			angular.forEach(extensionInfo, function(extensionValue, extensionKey) {
				if(states[path][extensionKey])
					states[path][extensionKey] = extensionValue;
			});
		} else {
			//TODO: For now just logging the error.
			console.error("The path : "+path+" to be extended is not configured before.");
		}
		return this;
	}
	
	this.$get = ['$rootScope','$templateRequest','$q','iscResourcePermission','iscStateParams', function($rootScope,$templateRequest,$q,iscResourcePermission,iscStateParams) {
		/**
		 * @ngdoc service
		 * @name iscState
		 * @requires $rootScope
		 * @requires $templateRequest
		 * @requires $q
		 * @requires iscResourcePermission
		 * @requires iscStateParams
		 *
		 * @description
		 *	Helps to deep-link URLs to controllers and views (HTML templates).
		 *	Listens to the '$stateChangeStart' event emitted on the $rootScope and tries to find the state to transition to.
		 * 	The states have to be configured through the 'iscStateProvider'. 
		 *	This service is usually used in conjunction with the 'isc-view' directive to load the corresponding template and iscStateParams service.
		 *
		 *	@example
		 *	<div isc-view class="view-animate"></div>
		 *
		 *	angular.module('store')
			.config(['iscStateProvider',function(iscStateProvider) {
			iscStateProvider
			  .state('ordersummary', {
				templateUrl: './store/views/order/order-summary/order-summary.tpl.html',
				controller: 'store.views.order.order-summary.order-summary',
				controllerAs: 'OrderSummaryCtrl',
				addToHistory: false
			  })
			  .extendState('/home', {
				controller: 'HomeCtrl'
			  })
			  .otherwise('/home');
			}]);
		 *	
		 *  <!-- The state change can happen either declaratively or programatically 
		 *
		 *  using the 'iscState' service and directive. -->
		 *	<!-- When such a change happens, the chosen 'templateUrl' is loaded 
		 * 
		 *  on to the HTML element with the 'isc-view' directive. -->
		 *	@returns {Object} iscState
		 */
		
		/**
		 * @ngdoc event
		 * @name iscState#$stateChangeStart
		 * @eventType Emit on root scope
		 * @description
		 * Emitted either declaratively or programatically by using the 'iscState' service. The state to transition to is passed as input.
		 * 'iscState' service listens to this event and calls the 'prepareState' method with the state that needs to be transitioned to.
		 *
		 * @param {Object} angularEvent Synthetic event object
		 * @param {Object} stateData Current state information is embedded in this JSON object
		 */
		
		/**
		 * @ngdoc event
		 * @name iscState#$backButtonClicked
		 * @eventType Emit on root scope
		 * @description
		 * Emitted by a controller when the 'Back' button in the application is clicked.
		 * 'iscState' service listens to this event and calls the 'recomputeState' method.
		 *
		 * @param {Object} angularEvent Synthetic event object
		 */
		
		/**
		 * @ngdoc event
		 * @name iscState#$homeButtonClicked
		 * @eventType emit on root scope
		 * @description
		 * Emitted by a controller when the 'Home' button in the application is clicked.
		 * 'iscState' service listens to this event and calls the 'loadDefaultState' method.
		 *
		 * @param {Object} angularEvent Synthetic event object
		 */
		
		/**
		 * @ngdoc event
		 * @name iscState#$stateChangeBegin
		 * @eventType Broadcast on root scope
		 * @description
		 * Broadcasted before a state change is attempted and a template is loaded. 
		 * If there are some configurations that are needed in the view, the sunbscriber of this event can achieve it in the 'iscView' directive.
		 *
		 * @param {Object} angularEvent Synthetic event object
		 * @param {Object} nextState Future state information
		 * @param {Object} lastState Current state information
		 */
		 
		/**
		 * @ngdoc event
		 * @name iscState#$stateChangeSuccess
		 * @eventType broadcast on root scope
		 * @description
		 * Broadcasted after a state change successfully happens. 
		 * This means that the template HTML to be loaded for the state has been successfully fetched and the resource permission for the view is present.
		 *
		 * @param {Object} angularEvent Synthetic event object
		 * @param {Object} nextState Future state information
		 * @param {Object} lastState Current state information
		 */
		
		/**
		 * @ngdoc event
		 * @name iscState#$stateChangeError
		 * @eventType broadcast on root scope
		 * @description
		 * Broadcasted if a state change fails. 
		 * This means that the template HTML to be loaded for the state could not be fetched.
		 *
		 * @param {Object} angularEvent Synthetic event object
		 * @param {Object} nextState Future state information
		 * @param {Object} lastState Current state information
		 */
		 
		var iscState = {
			states : states,
			stateStack : stateStack,
			currentStateInfo : currentStateInfo
		}
		var preparedState,template;
	
		$rootScope.$on('$stateChangeStart', prepareState);
		//$rootScope.$on('$backButtonClicked', recomputeState);
		$rootScope.$on('$homeButtonClicked', loadDefaultState);
		$rootScope.$on('$backButtonClicked', handleBackButton);
		
		/**
		 * @ngdoc method
         * @name iscState#goToState
         *
		 * @param state {String} The state path to transition to
		 * @param params {Object} State parameters for the state change
		 * @param options {Object} Any additional options to pass
		 *
         * @description
		 * Triggers a state change. 
		 *	@example
		 * 	<!-- Declarative way to naviagate to a specific state when a link is clicked. -->
		 *	<!-- The html will use the 'iscState' directive as below:  -->
		 *	<a href="#" isc-ui-state="/home">Home</a>
		 *	
		 *	<!-- The state needs to be configured as: -->
		 *	iscStateProvider
		 *     .state('/home', {
		 *		templateUrl: './store/views/home.html',
		 *		controller: 'HomeCtrl',
		 *		controllerAs: 'Home'
		 *	})
		 *
		 *	<!-- Passing additional parameters and options along with the state transfer -->
		 *	
		 *	<a href="#" isc-ui-state="/home" 
		 *
		 *  isc-ui-state-params="{Key1: 'Value1',Key2: 'Value2'}"
		 *
		 *  isc-ui-state-options="{'reload':true}">Home</a>
		 *	
		 *	<!-- 'isc-ui-state-params' and 'isc-ui-state-options' 
		 *  
		 *  attributes take a JSON object as input -->
		 *	<!-- 'isc-ui-state-params' typically takes any input that needs
		 *
		 *  to be passed on to the controller -->
		 *	<!-- 'isc-ui-state-options' is typically for any option that has
		 *
		 *  been missed as part of controller input passed through the params -->
		 *	<!-- Currently, there is no list of acceptable options that can be passed -->
		 *	
		 *	<!-- Programmatic way to trigger state transfer -->
		 *	<button ng-click="goToStateHandler()"> Order Capture </button>
		 *	
		 *	<!-- The controller for the button will programatically call the state change method -->
		 *	module.controller('HomeCtrl', ['$scope','iscState', function($scope,iscState) {
		 *	$scope.goToStateHandler = function() {
		 *		iscState.goToState('ordercapture',stateParams,stateOptions);
		 *	}
		 *	}]);
		 *	<!--'stateParams' and 'stateOptions' are JSON objects like in the declarative example -->
		 *
         */
		
		iscState.goToState = function goToState(state,params,options) {
			
			if(!iscCore.isVoid(states[state]) && ((!iscCore.isVoid(states[state].resourceId) &&  iscResourcePermission.hasPermission(states[state].resourceId)) || iscCore.isVoid(states[state].resourceId))){
					updateCurrentStateInfo(state,params,options);
					$rootScope.$emit("$stateChangeStart",currentStateInfo);
			}
			else{
				console.error("Either state is not defined or user doesnot have permission to the state - "+state);
			}
		};
		
		iscState.goToPreviousState = function goToPreviousState() {
			//$rootScope.$emit("$backButtonClicked");
			recomputeState();
		};
		/**
		 * @ngdoc method
         * @name iscState#updateCurrentStateInfo
         *
		 * @param state {String} The state path to transition to
		 * @param params {Object} State parameters associated with the state
		 * @param options {Object} Any additional options passed with the state change
		 *
         * @description
		 * Updates the 'currentStateInfo' object with the current values of state, params and options.
         */
		
		function updateCurrentStateInfo(state,params,options) {
			currentStateInfo.state = state;
			currentStateInfo.params = params;
			currentStateInfo.options = options;
		}
		
		iscState._isDefaultState = function(state){
            return state.state === states.defaultPath;
        }
        
		return iscState;
		
		/**
		 * @ngdoc method
         * @name iscState#loadDefaultState
		 *
         * @description
		 *	Loads the default state configured through '.otherwise' in the iscStateProvider.
		 *  It is the handler for the '$homeButtonClicked' event emitted on the $rootScope.
		 *	Some usecases for this method include: when the 'Home' button is clicked or when the browser 'Refresh' button is clicked.
		 *	During this method execution, the stateStack is emptied and the 'Back' button of the application is hidden.
		 *	Check is done to see if the current page is already the default page. In that case, the page is not reloaded.
         */
		
		function loadDefaultState() {
			var lastState = iscState.currentState;
			//stateStack = [];
            stateStack.splice(0, stateStack.length)
			showOrHideBackButton();
			if(lastState && lastState.path) {
				var redirectPath = states.defaultPath;
				if(lastState.path !== redirectPath){ //If we are already on Home page, do not load it again on click of Home
					var nextState = getDefaultStateInfo();
					iscState.currentState = nextState;
					publishState(nextState,lastState);
				} else if (lastState.path === redirectPath && arguments[0] != null && arguments[0]["forceRefresh"] === true) {
					var nextState = getDefaultStateInfo();
					nextState["options"] = arguments[0];
					nextState["params"] = arguments[1];
					iscState.currentState = nextState;
					publishState(nextState,lastState);
				}
			} else { // for page refresh or when the page loads the first time
				var nextState = getDefaultStateInfo();
				iscState.currentState = nextState;
				publishState(nextState,lastState);
			}
			updateCurrentStateInfo(states.defaultPath,{},{});
		}
		
		
		function handleBackButton(e,args){
		  if($rootScope.$broadcast('$handleBackButton',args).defaultPrevented){
		    console.log("$handleBackButton prevented");
		  }
		  else{
		    recomputeState();
		  }
		}
		
		/**
		 * @ngdoc method
         * @name iscState#recomputeState
		 *
         * @description
		 *	Handles the 'Back' button click. The application moves to the previous page.
		 *  It is the handler for the '$backButtonClicked' event emitted on the $rootScope.
		 *	During this method execution, the 'Back' button of the application is hidden if stateStack gets empty.
		 *	Check is done to see if the current page is already the default page. In that case, the page is not reloaded.
         */
		
		function recomputeState() {
			var lastState = iscState.currentState;
			var poppedState = stateStack.pop();
			showOrHideBackButton();
			var nextState;
			if(poppedState) {
				nextState = iscState.currentState = poppedState;
				if(nextState.options){
					nextState.options.backButtonClicked = true;
				}else{
					nextState.options = {backButtonClicked :true};
				}
				publishState(nextState,lastState);
			} else {
				var redirectPath = states.defaultPath;
				if(lastState.path && (lastState.path !== redirectPath))	{ //If we are already on Home page, do not load it again
					nextState = getDefaultStateInfo();
					iscState.currentState = nextState;
				}
			}
		}
		
		/* The logic below checks for the number of listeners present for '$backButtonClicked' event and if any 
		of the listeners set $screenIsDirty property on $rootScope, back button handling is stopped. 
		Checking in the code as of now, as we may use this logic in the future.
		
		function recomputeState() {
			// Check to see if there are other listeners for the event doing dirty check and wait for the listeners' response
			if($rootScope.$$listenerCount["$backButtonClicked"] > 1) {
				$rootScope.$watch('$backButtonClicked', function() {
					if($rootScope.$screenIsDirty !== true) {
						handleBackButtonClick();
					} else {
						//TO DO: Logging into the console for now.
						console.log("The screen is dirty and hence the back button won't work!");
					}
				});
			} else {
					handleBackButtonClick();
			}				
			
		}
		
		function handleBackButtonClick () {
			var lastState = iscState.currentState;
			var poppedState = stateStack.pop();
			showOrHideBackButton();
			var nextState;
			if(poppedState) {
				nextState = iscState.currentState = poppedState;
				publishState(nextState,lastState);
			} else {
				var redirectPath = states.defaultPath;
				if(lastState.path && (lastState.path !== redirectPath))	{ //If we are already on Home page, do not load it again
					nextState = getDefaultStateInfo();
					iscState.currentState = nextState;
				}
			}
		}*/
		
		/**
		 * @ngdoc method
         * @name iscState#getDefaultStateInfo
		 *
         * @description
		 *	Returns the details of the default state from the 'states' object.
		 * @returns {Object} defaultState
         */
		
		function getDefaultStateInfo () {
			var redirectPath = states.defaultPath;
			var nextState = {};
			angular.forEach(states, function(stateInfo,path) {
				if (path === redirectPath) {
					nextState.path = path;
					nextState.stateInfo = stateInfo;
				}
			});
			return nextState;
		}
		
		/**
		 * @ngdoc method
         * @name iscState#showOrHideBackButton
		 *
         * @description
		 *	Checks if the 'Back' button in the application needs to be hidden or not.
		 *	It sets the '$showBackButtonForStates' flag on the $rootScope based upon the length of 'stateStack'. 
		 *
		 *	@example
		 *	<button ng-show="$root.$showBackButtonForStates" 
		 *
		 *  ng-click="backButtonClickHandler()"> Back </button>
         */
		 
		function showOrHideBackButton() {
			if(stateStack.length > 0) {
				$rootScope.$showBackButtonForStates = true;
			} else {
				$rootScope.$showBackButtonForStates = false;
			}
		}
		
		/**
		 * @ngdoc method
         * @name iscState#prepareState
		 *
		 * @param {Object} event is an angularEvent Synthetic event object
		 * @param {Object} stateData passed that contains the following keys with values:
		 * state - the path of the next state to load
		 * params - the parameters corresponding to the state to load
		 * options - any additional options associated with the state
		 *
         * @description
		 *	Handles the '$stateChangeStart' event emitted on the $rootScope. This event is emitted by the 'iscState' service.
		 *	It loops through the 'states' array to fetch the next state to be loaded based upon the 'state' passed as input in 'stateData'.
		 *	If no such state is found or if 'stateData' is empty, the defaultState configured through '.otherwise' of the 'iscStateProvider' is loaded. 
		 *	If the 'addToHistory' flag was set to false for the lastState, then it is not pushed to the 'stateStack'. Else it is pushed.
         */
		 
		function prepareState(event,stateData) {
			if(!$rootScope.$broadcast("$beforeStateChange",stateData).defaultPrevented){
				if(stateData) {
					var stateToChange = stateData.state;
					if(stateToChange) {
						if(stateToChange===states.defaultPath){
							loadDefaultState(stateData.options, stateData.params);
							return;
						}
						var lastState = iscState.currentState;
						if(lastState) {
							if(lastState.stateInfo && lastState.stateInfo.addToHistory !== false) {
								var historyToPush = {path: lastState.path , stateInfo: lastState.stateInfo,params:lastState.params,options:lastState.options };
								stateStack.push(historyToPush);
								showOrHideBackButton();
							}
						}
						preparedState = {};

						//Loop the states array to get the matching state 
						angular.forEach(states, function(stateInfo,path) {
							if (path === stateToChange) {
								preparedState.path = path;
								preparedState.stateInfo = stateInfo;
								preparedState.params = stateData.params;
								preparedState.options = stateData.options;
							}
						});

						if(preparedState.path) {
							var nextState = iscState.currentState = preparedState;
                            _removeLastStateIfSame(nextState);
							publishState(nextState,lastState);		
						} else { // No state matched. Show the default state
							loadDefaultState();
						}

					} else {
						// TODO Logging into console as of now. Need to change this later
						console.log("The state to be transitioned to : "+stateToChange+" is not valid!");
						loadDefaultState();
					}
				} else {
					loadDefaultState();
				}
			}
		}
		
        function _removeLastStateIfSame(nextState){
            var lastState = iscState.stateStack[iscState.stateStack.length-1];
            if(lastState.path === nextState.path){
                iscState.stateStack.pop();
            }
        };
        
		/**
		 * @ngdoc method
         * @name iscState#publishState
		 *
		 * @param {Object} nextState contains the information of the state that needs to be loaded.
		 * @param {Object} lastState contains the information of the state that needs to be replaced with the newState
		 *
         * @description
		 *	Fetches the template that needs to be loaded. The template information is present in the 'nextState.stateInfo.templateUrl' variable.
		 *	Checks resourceId permission to access the template that is to be loaded.
		 *	If the template is fetched properly and if the resourceId check is a success, publishes the '$stateChangeSuccess' event.
		 *	'iscView' directive listens to the '$stateChangeSuccess' and loads the template into the corresponding HTML element.
		 *	Copies the currentState's params and options values into the 'iscStateParams' service so that they can be accessed from anywhere.
         */
		
		function publishState(nextState,lastState) {
			$rootScope.$broadcast('$stateChangeBegin', nextState, lastState);
			$q.when(nextState).
			then(function() {
				if(nextState) {
					var nextStateParams = nextState.stateInfo;
					var locals = {};
					if(nextStateParams) {
						if (angular.isDefined(nextStateParams.templateUrl)) {
							template = $templateRequest(nextStateParams.templateUrl);
						}
						if (angular.isDefined(template)) {
							locals['template'] = template;
						}
					}
					return $q.all(locals);
				}
			}).then(function(locals) {
				if (locals.template && (nextState == iscState.currentState)) {
					var resourceId = nextState.stateInfo.resourceId;
					var paramsToCopy = {'params':nextState.params,'options':nextState.options}
					if(resourceId) {
						if(iscResourcePermission.hasPermission(resourceId)){
							iscState.currentState.template = locals.template;
							angular.copy(paramsToCopy, iscStateParams);
							$rootScope.$broadcast('$stateChangeSuccess', nextState, lastState);
						} else {
							// TODO: Error is logged to the console as of now. Need to change
							console.error("Resource Id : "+resourceId+" does not have permission to access template: "+locals.template);
						}
					} else {
						iscState.currentState.template = locals.template;
						angular.copy(paramsToCopy, iscStateParams);
						$rootScope.$broadcast('$stateChangeSuccess', nextState, lastState);
					}
				}
			}, function(error) {
				$rootScope.$broadcast('$stateChangeError', nextState, lastState, error);
			});	
		}
	}];
});
})(window.iscCore);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp.  2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/


(function(iscCore){
  'use strict';
  var _rules = {};
  
  iscCore.setRule = function(ruleId,ruleJson){
		_rules[ruleId] = ruleJson;		
	};
	
	iscCore.getRule = function(ruleId){
		return _rules[ruleId];		
	};
	
	iscCore.isRuleEnabled = function(ruleId){
		if ( !ruleId ) {
			return true;
		}
		if ( !_rules ) {
			console.warn("resource set is undefined... returning false");
			return false;
		}
		var rule = _rules[ruleId];
		var isRuleEnabled = (rule.Rules.RuleSetValue === "Y");
		return isRuleEnabled;
	};
  
    iscCore.getRuleSetValue = function(ruleId){
        if ( !ruleId ) {
			return "";
		}
		if ( !_rules ) {
			console.warn("resource set is undefined... returning false");
			return "";
		}
        if ( !_rules[ruleId]){
            return "";
        }
        return _rules[ruleId].Rules.RuleSetValue;
    }
})(window.iscCore);


(function(iscCore){
  'use strict';
	/**
   * @ngdoc provider
   * @name iscRuleProvider
   * @description
   * Use the `iscRuleProvider` to register the rules for the application
   */
  angular.module('isc.shared').provider('iscRule', function() {
  	/**
  	 * @ngdoc method
  	 * @name iscRuleProvider#setRule
  	 * @description Sets the rule data for the specified rule id
  	 * 
  	 * @param {string} ruleId Rule id
		 * @param {object} ruleData Rule data
  	 */
  	this.setRule = iscCore.setRule;
  	
  	this.$get = function(){
			/**
       * 
       * @ngdoc service
       * @name iscRuleService
       * 
       * @description
       * The iscRule is the core service which facilitates checking rules
       */
  	  return {
				/**
      	 * @ngdoc method
      	 * @name iscRuleService#getRule
      	 * @description Returns the rule data for the specified rule id
      	 * 
      	 * @param {string} ruleId Rule id
      	 * @returns {object} Rule data
				 * @example
				 		iscRule.getRule(ruleId);
      	 */
  	    getRule : iscCore.getRule,
  	    /**
      	 * @ngdoc method
      	 * @name iscRuleService#getRuleSetValue
      	 * @description Returns the rule set value data for the specified rule id
      	 * 
      	 * @param {string} ruleId Rule id
      	 * @returns {String} Rule Set Value data
		 * @example
				 		iscRule.getRuleSetValue(ruleId);
      	 */
  	    getRuleSetValue : iscCore.getRuleSetValue,
				/**
      	 * @ngdoc method
      	 * @name iscRuleService#isRuleEnabled
      	 * @description Checks rule is enabled or not and returns the flag
      	 * 
      	 * @param {string} ruleId Rule id
      	 * @returns {boolean} true if rule is enabled else false
				 * @example
				 		iscRule.isRuleEnabled(ruleId);
      	 */
  	    isRuleEnabled : iscCore.isRuleEnabled
  	  };
  	};
  });

})(window.iscCore);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/


(function(iscCore) {
	'use strict';

	iscCore.getTemplateForPaymentType = function(paymentType) {
		var capturePaymentTemaplatesForPaymentType = {
			'CHECK' : './shared/payment/payment-capture/templates/payment-capture-check.tpl.html',
			'REFUND_CHECK' : './shared/payment/payment-capture/templates/payment-capture-check.tpl.html',
			'PRE_PAID' : './shared/payment/payment-capture/templates/payment-capture-prepaid.tpl.html'
		};
		var capturePaymentTemaplatesForPaymentTypeGroup = {
			'CREDIT_CARD' : './shared/payment/payment-capture/templates/payment-capture-cc.tpl.html',
			'CUSTOMER_ACCOUNT' : './shared/payment/payment-capture/templates/payment-capture-cacc.tpl.html',
			'STORED_VALUE_CARD' : './shared/payment/payment-capture/templates/payment-capture-svc.tpl.html',
			'OTHER' : './shared/payment/payment-capture/templates/payment-capture-other.tpl.html'
		};
		var paymentTypeGroup = paymentType.PaymentTypeGroup;
		var paymentType = paymentType.PaymentType;
		if(capturePaymentTemaplatesForPaymentType[paymentType]){
			return capturePaymentTemaplatesForPaymentType[paymentType];
		} else if (capturePaymentTemaplatesForPaymentTypeGroup[paymentTypeGroup]){
			return capturePaymentTemaplatesForPaymentTypeGroup[paymentTypeGroup];
		}
		else {
			return null;
		}
	};

})(window.iscCore);

(function(iscCore){
  'use strict';

  
  /**
   * @ngdoc provider
   * @name  iscPaymentInputTemplateProvider
   * @description
   * Use the `iscPaymentInputTemplateProvider` to register the list of input templates specific to a payment type
   */

  angular.module('isc.shared').provider('iscPaymentInputTemplate', function() {
  	
  	this.$get = function(){
  	  /**
       * 
       * @ngdoc service
       * @name iscPaymentInputTemplate
       * 
       * @description
       * The iscPaymentInputTemplate is the core service which facilitates getting input template for capture payment
       */
  	  return {
  	    /**
      	 * @ngdoc method
      	 * @name iscPaymentInputTemplate#getTemplateForPaymentType
      	 * @description The getTemplateForPaymentType checks for the payment type (or payment type group) and returns the appropriate html input template
      	 * 
      	 * @param {object} paymentType object
      	 * @returns {string} Returns html input template name along with relative path
      	 */
  	    getTemplateForPaymentType : iscCore.getTemplateForPaymentType
  	  };
  	};
  	
  	
  	}	
  );

})(window.iscCore);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp. 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/




(function(iscCore){
    
    angular.module("isc.shared").provider("iscShipmentStatus",[function(){
        
		var _shipmentStatusConfig = {};
		 
		this.addShipmentStatusConfig = function(flowName,StatusCode,StatusBundleKey) {
			
			var statusConfig = {
				'StatusCode':StatusCode,
				'StatusBundleKey':StatusBundleKey
				
			};
			
			var tmpConfig = _shipmentStatusConfig[flowName];
			 
			if(iscCore.isVoid(tmpConfig)){
				var statusList = {};
				statusList.StatusList={}
				statusList.StatusList.Status = [];
				statusList.StatusList.Status[0] = {};
				statusList.StatusList.Status[0] = statusConfig;
				_shipmentStatusConfig[flowName] = statusList; 
			}else {
				var statusArray = tmpConfig.StatusList.Status;
				statusArray.push(statusConfig);
				_shipmentStatusConfig[flowName] = tmpConfig;
			}
			
		};
		
        this.$get = [function(){
			
			return {
				
				getShipmentStatusConfig : function(key){
					return _shipmentStatusConfig[key];
                },

				getShipmentStatusCodeList : function(key){
					var statusCodeArray = []
					var statusConfig = _shipmentStatusConfig[key];
					if(!iscCore.isVoid(statusConfig)){
						var statusConfigList = statusConfig.StatusList.Status;
						for(var i=0; i<statusConfigList.length; i++){
							statusCodeArray.push(statusConfigList[i].StatusCode);
						}
					}
					return statusCodeArray;
				}
                
				
			};
		}];
        
        
    }])
    
    
    
})(window.iscCore);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp. 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/

/**
 * @ngdoc service
 * @name iscAppointment
 * 
 * 
 * @description  Handles common tasks related to Appointment calendar widgets. 
 * 
 */
angular.module('isc.shared').factory('iscAppointment', ['iscTimezone','$filter','iscI18n',
    function(iscTimezone,$filter,iscI18n) {
  
        var iscAppointment = {};	
        /**
         *@ngdoc method
         *@name iscAppointment#isTimeInRange
         *@description This method checks the given time is range or not
         * 
         *@param {String} givenTime Date/Time which needs to checked for range
         *@param {String} startTime Start time which needs to checked for range
         *@param {String} endTime End time which needs to checked for range
         *@returns {Boolean}  True if the givenTime is within range else false 
         */
        iscAppointment.isTimeInRange = function(givenTime,startTime,endTime){
            var _givenTime = Number(givenTime.replace(/:/g, ''));
            var _startTime = Number(startTime.replace(/:/g, ''));
            var _endTime = Number(endTime.replace(/:/g, ''));

            return (_givenTime >= _startTime && _givenTime < _endTime);
        },
            
        iscAppointment._getTimeSlots = function(slotArray,timeRange){
            var timeStringArray = [];
            var slots = slotArray.Slot;
            
            if(!iscCore.isVoid(slots)){
                var offset = slotArray.TimezoneOffset;//iscTimezone.getTimezoneOffset(slotArray.TimeZone);
                for(var i=0;i<slots.length;i++){
                    var slot = slots[i];
                    if(iscAppointment.isTimeInRange(slot.StartTime,timeRange.StartTime,timeRange.EndTime)){
                        if(!iscCore.isVoid(slot.AvailableDates) && !iscCore.isVoid(slot.AvailableDates.AvailableDate) && slot.AvailableDates.AvailableDate[0].CapacityAvailable == "Y"){
                            var utcStartDate = slot.AvailableDates.AvailableDate[0].Date+"T"+slot.StartTime;
                            //utcStartDate = $filter('date')(utcStartDate, 'yyyy-MM-ddTHH:mm:ss', offset);
                            timeStringArray.push({
                                "timeString": slot.StartTime,
                                slot:{
                                    StartTime:slot.StartTime,
                                    EndTime:slot.EndTime,
                                    Date:slot.AvailableDates.AvailableDate[0].Date,
                                    StartDate:slot.AvailableDates.AvailableDate[0].Date+"T"+slot.StartTime+offset,
                                    EndDate:slot.AvailableDates.AvailableDate[0].Date+"T"+slot.EndTime+offset,
                                    UTCStartDate:utcStartDate,
                                    TimezoneOffset:offset,
                                    timerange:$filter('date')('2000-01-01T'+slot.StartTime,'shortTime')+" - "+$filter('date')('2000-01-01T'+slot.EndTime,'shortTime')
                                }
                            });
                        }
                    }
                }
            }
            
            return timeStringArray;
        }
        
        iscAppointment._getSlotGroups = function(slotArray){
            var slots = slotArray.Slot;
            var slotGroups = [];
            var slotGroupObj = {};
            if(!iscCore.isVoid(slots)){
                for(var i=0;i<slots.length;i++){
                    if(!iscCore.isVoid(slots[i].ParentSlotKey) && !slotGroupObj.hasOwnProperty(slots[i]['ParentServiceSlotDesc'])){
                        slotGroupObj[slots[i]['ParentServiceSlotDesc']] = true;
                        
                        slotGroups.push({
                            "label":slots[i]['ParentServiceSlotDesc'],
                            "StartTime":slots[i]['ParentStartTime'],
                            "EndTime":slots[i]['ParentEndTime'],
                            "iconCls": "app-icon-"+slots[i]['ParentServiceSlotDesc'].toLowerCase(),
                            "labelTimeSlot":$filter('date')('2000-01-01T'+slots[i]['ParentStartTime'],'shortTime')+" - "+$filter('date')('2000-01-01T'+slots[i]['ParentEndTime'],'shortTime')
                        });
                        
                    }
                    
                }
            }
            if(slotGroups.length === 0){
                slotGroups.push({
                    "label":iscI18n.translate("timeslot.LABEL_Avaiable_slot"),
                    "StartTime":"00:00:00",
                    "EndTime":"24:00:00",
                    "iconCls": "app-icon-clock_30",
                    "labelTimeSlot":""//$filter('date')('2000-01-01T00:00:00','shortTime')+" - "+$filter('date')('2000-01-01T24:00:00'],'shortTime')
                });
            }
            return slotGroups;
        }
        
        /**
         *@ngdoc method
         *@name iscAppointment#getSlotGroupData
         *@description This method forms the time slot groug data for iscTimeSelector directive
         *
         *@param {object} slotArray Object containing slot data
         *
         *@returns {Object} Slot group data
         */
        iscAppointment.getSlotGroupData = function(slotArray){
            
            var slotGroups = iscAppointment._getSlotGroups(slotArray);
            
            var slotGroupData = {
                hasAnyAvailableSlot:false,
                "slotArray": []
            }
            var isPreviousSelected = false;
            
            for(var i=0;i<slotGroups.length;i++){
                var slots = iscAppointment._getTimeSlots(slotArray,slotGroups[i]);
                slotGroups[i].availableSlotsArray = slots;
                slotGroups[i].isSelected = !isPreviousSelected && slots.length > 0
                slotGroupData.slotArray.push(slotGroups[i]);
                
                var isPreviousSelected = slots.length > 0;
                if(!slotGroupData.hasAnyAvailableSlot && slots.length > 0){
                    slotGroupData.hasAnyAvailableSlot = true;
                }
            }
            
            return slotGroupData;
        }
        
        /**
         *@ngdoc method
         *@name iscAppointment#getTimeSlotData
         *@description This method forms the time slot date
         *
         *@param {String} startTime Start time for time slot
         *@param {String} endTime End time for time slot
         *@param {String} timezoneOffset Timezone offset for the time slot
         *
         *@returns {Object} Time slot data
         */
        iscAppointment.getTimeSlotData = function(startTime,endTime,timezoneOffset){
            var startDate = $filter('date')(startTime, 'yyyy-MM-ddTHH:mm:ss', timezoneOffset);
            var endDate = $filter('date')(startTime, 'yyyy-MM-ddTHH:mm:ss', timezoneOffset);
            var slotData = {
                slot:{
                    StartTime:startTime.substring(11,19),
                    EndTime:endTime.substring(11,19),
                    Date:startDate.substring(0,10),
                    StartDate:startTime,
                    EndDate:endTime,
                    UTCStartDate:startDate,
                    TimezoneOffset:timezoneOffset,
                }
            }
            return slotData;
        }
        /**
         *@ngdoc method
         *@name iscAppointment#getCalenderWeekData
         *@description This method forms the input for iscDateSelector directive
         *
         *@param {Object} calenderData Calender date from the api output
         *
         *@returns {Array} Array of the date objects
         */
        iscAppointment.getCalenderWeekData = function(calenderData){
            var weeklyScheduleToPublish = [];
            if(calenderData.Calendar.Dates.Date.length > 0) {
                for(var i=0; i< calenderData.Calendar.Dates.Date.length; i++) {
                    var currentDate = calenderData.Calendar.Dates.Date[i];
                    var currentDateObj = {};
                    currentDateObj.date = currentDate.Date;
                    currentDateObj.startTime = currentDate.EarliestShiftStartTime;
                    currentDateObj.endTime = currentDate.LastShiftEndTime;
                    currentDateObj.isWorkingDay = currentDate.Type;
                    weeklyScheduleToPublish.push(currentDateObj);
                }
            }
            return weeklyScheduleToPublish;
        }
        /**
         *@ngdoc method
         *@name iscAppointment#isAppointmentTimePassed
         *@description This method checks the start time has passed the current time
         *
         *@param {String} startTime Start time which needs to checked
         *@param {String} timezoneOffset Timezone offset against which the time needs to be compared
         *@returns {Boolean} True if the startTime has passed the current time else false 
         */
        iscAppointment.isAppointmentTimePassed = function(startTime, timezoneOffset) {
        	
        	var isAppointmentInPast  = false;
        	
        	if(startTime) {
        		
        		var startDateTime = $filter('date')(startTime, 'yyyy-MM-ddTHH:mm:ss', timezoneOffset);
                var currentDateTime = $filter('date')(new Date(), 'yyyy-MM-ddTHH:mm:ss', timezoneOffset);
                
        		if(startDateTime < currentDateTime) {
        			isAppointmentInPast = true;
        		}
        	} 
        	
        	return isAppointmentInPast;
        }
        
        return iscAppointment;
}]);
     
/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp. 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/


/**
 * @ngdoc service
 * @name iscInStoreAppointment
 * 
 * 
 * @description  Handles common tasks related to in-store appointments flow.
 * 
 */
angular.module('isc.shared').factory('iscInStoreAppointment', ['$http','$filter','$q','iscAppInfo','iscMashup','iscModal','iscWizard','iscI18n','iscTimezone','$rootScope','iscAppContext','iscState',
    function($http,$filter,$q,iscAppInfo,iscMashup,iscModal,iscWizard,iscI18n,iscTimezone,$rootScope,iscAppContext,iscState) {
  
        var iscInStoreAppointment = {};	
     
        /**
         * @description This method launches appointment wizard
         * 
         *  @param {Object} wizardInput - sales order model
         */
        iscInStoreAppointment.openCreateAppointmentWizard = function(wizardInput){
        	iscState.goToState('manage-appointment', wizardInput, {});
        };
        
        /**
         * @description This method launches store appointment calendar view screen
         */
        iscInStoreAppointment.viewStoreApppointmentCalendar = function(){
        	iscState.goToState('storeAppointmentCalendar',{},{});
        };
        
        /**
         * @description This method checks is work order is cancelled internally by system.
         * 
         *  @param {Object} workOrder - work order model
         */
        iscInStoreAppointment.isSystemCancelledWorkOrder = function(workOrder) {
        	 return (!iscCore.isVoid(workOrder) && iscCore.isVoid(workOrder.WorkOrderServiceLines) && workOrder.Status.match("1600"));
        };
        
        /**
         * @description This method returns logged in store's timezone
         */
        iscInStoreAppointment.getCurrentStoreTimezoneOffset = function() {
       	 return iscTimezone.getTimezoneOffset(iscAppContext.getFromContext("storeLocaleTimeZone"));
       };
        
       /**
        * @description This method returns logged in store's address
        */
        iscInStoreAppointment.getCurrentStoreAddress = function() {
        	
        	var storeAddress = iscAppContext.getFromContext('storeAddress');
			if(storeAddress && storeAddress.ShipNodePersonInfo) {
				return storeAddress.ShipNodePersonInfo;
			} else {
				return {};
			}
        	
        };
        
        /**
         * @description This method returns service description of the appointment
         * 
         * @param {Object} workOrderAppointment - work order appointment model
         */
        iscInStoreAppointment.getServiceDescriptionForAppointment = function(workOrderAppointment) {
        	
        	if(workOrderAppointment && workOrderAppointment.WorkOrderAppointment.WorkOrder.WorkOrderServiceLines.WorkOrderServiceLine[0]) {
        		return workOrderAppointment.WorkOrderAppointment.WorkOrder.WorkOrderServiceLines.WorkOrderServiceLine[0].ItemShortDescription;
        	}
        	
        	return null;
        };
        
        /**
         * @description This method returns customer display name of the appointment
         * 
         * @param {Object} workOrderAppointment - work order appointment model
         */
        iscInStoreAppointment.getCustomerDisplayNameForAppointment = function(workOrderAppointment) {
        	
        	if(workOrderAppointment && workOrderAppointment.WorkOrderAppointment.WorkOrder.Order) {
        		return iscI18n.translate("address.LABEL_Display_name", {'firstname':workOrderAppointment.WorkOrderAppointment.WorkOrder.Order.CustomerFirstName,'lastname':workOrderAppointment.WorkOrderAppointment.WorkOrder.Order.CustomerLastName});
        	}
        	
        	return null;
        };
        
        /**
         * @description This method check if work order is in OPEN/SCHEDULED status and returns accordingly.
         * 
         * @param {Object} workOrder - work order model
         */
        iscInStoreAppointment.isWorkOrderOpen = function(workOrder) {
        	
        	 if(workOrder.Status && workOrder.Status.Status && (workOrder.Status.Status.match("1400") || workOrder.Status.Status.match("1600") || iscCore.isVoid(workOrder.WorkOrderServiceLines.WorkOrderServiceLine))){
        		 return true;
        	 } else {
        		 return false;
        	 }
        	
        };
        
        /**
         * @description This method launches appointment summary
         * 
         * @param {Object} salesOrder - sales order model
         */
        iscInStoreAppointment.openAppointmentSummary = function(salesOrder) {
        	iscState.goToState('appointment-summary',{input:{'Order':salesOrder}},{});
        };
        
        /**
         * @description This method launches appointment list
         * 
         * @param {Object} customer - customer details model
         * @param {Object} filterOptions - customer search criteria
         */
        iscInStoreAppointment.openAppointmentList = function(customer,filterOptions) {
        	iscState.goToState('appointmentlist',{input:{'customerDetails':customer,'FilterOptions':filterOptions}},{});
        };
        
        /**
         * @description This method creates input for getWorkOrderList API
         * 
         * @param {String} orderHeaderKey - sales order header key
         * @param {String} workOrderKey - work order header key
         */
        iscInStoreAppointment.getWorkOrderListInput = function(orderHeaderKey, workOrderKey) {
        	
        	var getWorkOrderList = {WorkOrder:{OrderHeaderKey:orderHeaderKey}};
        	if(!iscCore.isVoid(workOrderKey)) {
        		getWorkOrderList.WorkOrder.WorkOrderKey = workOrderKey;
        	}
        	return getWorkOrderList;
        };
        
        /**
         * @description This method creates input for changeOrder API for adding notes when a single appointment is marked as complete
         * 
         * @param {String} orderHeaderKey - sales order header key
         * @param {String} workOrderKey - work order header key
         */
        iscInStoreAppointment.getAddNotesInputForAppointmentComplete = function(workOrder) {
        	
        	var order = {Order:{OrderHeaderKey:workOrder.OrderHeaderKey,Notes:{Note:[]}}};
        	order.Order.Notes.Note[0] = {NoteText:iscI18n.translate("completeAppointment.MSG_AppointmentCompleteNoteText", {'itemDesc':workOrder.WorkOrderServiceLines.WorkOrderServiceLine[0].ItemShortDescription,'userId':iscAppContext.getFromContext('currentLoginID')})};
        	return order;
        };
        
        /**
         * @description This method creates input for changeOrder API for adding notes when an multiple appointment is marked as complete
         * 
         * @param {Array} workOrderArray - work order object array
         */
        iscInStoreAppointment.getAddNotesInputForMultiAppointmentComplete = function(workOrderArray) {
        	
    		var order = {Order:{OrderHeaderKey:"",Notes:{Note:[]}}};
        	
        	for(var i=0;i<workOrderArray.length;i++) {
				 var workOrder = workOrderArray[i];
				 order.Order.OrderHeaderKey = iscCore.isVoid(order.Order.OrderHeaderKey) ? workOrder.OrderHeaderKey : order.Order.OrderHeaderKey;
				 order.Order.Notes.Note[i] = {NoteText:iscI18n.translate("completeAppointment.MSG_AppointmentCompleteNoteText", {'itemDesc':workOrder.WorkOrderServiceLines.WorkOrderServiceLine[0].ItemShortDescription,'userId':iscAppContext.getFromContext('currentLoginID')})};
			 }
        	
        	return order;
        	
        };
        
        /**
         * @description This method creates input for confirmWorkOrder API for marking multiple appointment complete
         * 
         * @param {Array} workOrderArray - work order object array
         */
        iscInStoreAppointment.getConfirmWorkOrderInput = function(workOrder) {
        	
        	var confirmWorkOrder = {WorkOrder:{WorkOrderKey:workOrder.WorkOrderKey}};
        	confirmWorkOrder.WorkOrder.WorkOrderAppointments = {WorkOrderAppointment:[]};
        	confirmWorkOrder.WorkOrder.WorkOrderServiceLines = {WorkOrderServiceLine:[]};
        	confirmWorkOrder.WorkOrder.WorkOrderAppointments.WorkOrderAppointment[0] = {WorkOrderApptKey:workOrder.WorkOrderAppointments.WorkOrderAppointment[0].WorkOrderApptKey};
        	confirmWorkOrder.WorkOrder.WorkOrderServiceLines.WorkOrderServiceLine[0] = {WorkOrderServiceLineKey:workOrder.WorkOrderServiceLines.WorkOrderServiceLine[0].WorkOrderServiceLineKey};
        	
        	console.log(confirmWorkOrder);
        	
        	return confirmWorkOrder;
        	
        };
        
        /**
         * @description This method creates input for cancelling work order.
         * 
         * @param {Object} workOrder - work order object
         */
        iscInStoreAppointment.getCancelWorkOrderInput = function(workOrder) {
        	
        	var cancelWorkOrder = {WorkOrder:{WorkOrderKey:workOrder.WorkOrderKey}};
        	cancelWorkOrder.WorkOrder.ReasonCode = workOrder.CancelReasonCode;
        	cancelWorkOrder.WorkOrder.ReasonText = iscI18n.translate("cancelAppointment.MSG_CancelReasonText", {'cancelReason':workOrder.CancelReasonDescription});
        	cancelWorkOrder.WorkOrder.OrderHeaderKey = workOrder.OrderHeaderKey;
        	cancelWorkOrder.WorkOrder.OrderLineKey = workOrder.WorkOrderServiceLines.WorkOrderServiceLine[0].OrderLineKey;
        	cancelWorkOrder.WorkOrder.OrderLineNoteText = iscI18n.translate("cancelAppointment.MSG_OrderLineCancellationNote", {'cancelReason':workOrder.CancelReasonDescription,'itemDesc':workOrder.WorkOrderServiceLines.WorkOrderServiceLine[0].ItemShortDescription,'userId':iscAppContext.getFromContext('currentLoginID')});

        	console.log(cancelWorkOrder);
        	
        	return cancelWorkOrder;
        	
        };
        
        /**
         * @description This method creates input for mdofiyWorkOrder API for booking an appointment slot
         * 
         * @param {Object} workOrder - work order object
         */
        iscInStoreAppointment.getScheduleAppointmentInput = function(workOrder){
            var hasAppointmentChanged = true;
            
            var scheduleAppointmentInput = {
                WorkOrder:{
                    WorkOrderKey:workOrder.WorkOrderKey,
                    //NodeKey:workOrder.selectedShipNode.ShipNode,
                    WorkOrderAppointments:{
                        WorkOrderAppointment:{
                            PromisedApptStartDate:workOrder.selectedTimeSlot.slot.StartDate,
                            PromisedApptEndDate:workOrder.selectedTimeSlot.slot.EndDate
                        }
                    }
                    /*WorkOrderServiceLines:{
                        WorkOrderServiceLine:{
                            WorkOrderServiceLineKey:workOrder.WorkOrderServiceLines.WorkOrderServiceLine[0].WorkOrderServiceLineKey,
                            OrderLine:{
                                OrderLineKey:workOrder.WorkOrderServiceLines.WorkOrderServiceLine[0].OrderLine.OrderLineKey,
                                ShipNode:workOrder.selectedShipNode.ShipNode
                            }
                        }
                    }*/
                }
            }
            if(workOrder.WorkOrderAppointments && workOrder.WorkOrderAppointments.WorkOrderAppointment){
                scheduleAppointmentInput.WorkOrder.WorkOrderAppointments.WorkOrderAppointment.WorkOrderApptKey = workOrder.WorkOrderAppointments.WorkOrderAppointment[0].WorkOrderApptKey;
                
                /**
                 * Check this condition in case of change store
                 */
                if(scheduleAppointmentInput.WorkOrder.WorkOrderAppointments.WorkOrderAppointment.PromisedApptStartDate === workOrder.WorkOrderAppointments.WorkOrderAppointment[0].PromisedApptStartDate){
                    hasAppointmentChanged = false;
                }
                
            }
            
            return hasAppointmentChanged?scheduleAppointmentInput:null;
        };
        
        /**
         * @description This method creates input for deleting sales order
         * 
         * @param {Object} salesOrder - sales order object
         */
        iscInStoreAppointment.getDeleteAppointmentSalesOrderInput = function(salesOrder){
        	var deleteSalesOrderInput = {Order:{OrderHeaderKey:salesOrder.Order.OrderHeaderKey}};
        	return deleteSalesOrderInput;
        };
        
        /**
         * @description This method creates input for deleting sales order line
         * 
         * @param {Object} workOrder - work order object
         */
        iscInStoreAppointment.deleteAppointmentInput = function(workOrder){
            var deleteAppointmentInput = {
                Order:{
                    OrderHeaderKey:workOrder.OrderHeaderKey,
                    OrderLines:{
                        OrderLine:[
                            {
                                OrderLineKey:workOrder.WorkOrderServiceLines.WorkOrderServiceLine[0].OrderLine.OrderLineKey
                            }
                        ]
                    }
                }
            }
            return deleteAppointmentInput;
        };
        
        /**
         * @description This method creates input for deleting sales order line
         * 
         * @param {String} orderHeaderKey - sales order header key
         * @param {String} orderLineKey - order line key 
         */
        iscInStoreAppointment.getDeleteOrderLineInput = function(orderHeaderKey, orderLineKey) {
        	
        	var deleteOrderLineInput =  {Order:{OrderHeaderKey:orderHeaderKey,OrderLines:{OrderLine:[]}}}
        	deleteOrderLineInput.Order.OrderLines.OrderLine[0] = {OrderLineKey:orderLineKey};
        	
        	return deleteOrderLineInput;
        };
        
        /**
         * @description This method checks if sales order is in draft or confirmed status
         * 
         * @param {Object} salesOrder - sales order model
         */
        iscInStoreAppointment.isDraftAppointmentSalesOrder = function(salesOrder) {
        	
        	var isDraftSalesOrder = false;
        	salesOrder = iscCore.isVoid(salesOrder) ? iscWizard.getWizardModel('createAppointmentOrderModel') : salesOrder;
        	isDraftSalesOrder = (!iscCore.isVoid(salesOrder) && !iscCore.isVoid(salesOrder.Order) && salesOrder.Order.DraftOrderFlag == "Y") ? true : false; 
        	return isDraftSalesOrder;
        };
        
        /**
         * @description This method creates input for getWorkOrderList API
         * 
         * @param {Object} shipNodeDetails - store model
         * @param {Object} workOrder - work order model
         */
        iscInStoreAppointment.getStoreWorkOrderByserviceInput = function(shipNodeDetails, workOrder) {
        	
        	var getWorkOrderListInput = {WorkOrder:{OrderHeaderKey:workOrder.OrderHeaderKey, NodeKey:shipNodeDetails.ShipnodeKey,WorkOrderServiceLines:{WorkOrderServiceLine:[]}/*,PersonInfoShipTo:{}*/}};
			
			if(!iscCore.isVoid(workOrder) && !iscCore.isVoid(workOrder.WorkOrderServiceLines) && !iscCore.isVoid(workOrder.WorkOrderServiceLines.WorkOrderServiceLine)
					&& !iscCore.isVoid(workOrder.WorkOrderServiceLines.WorkOrderServiceLine[0]) && !iscCore.isVoid(workOrder.WorkOrderServiceLines.WorkOrderServiceLine[0].OrderLine)) {
				
				var orderLine = workOrder.WorkOrderServiceLines.WorkOrderServiceLine[0].OrderLine;
				
				if(!iscCore.isVoid(orderLine.ItemDetails)) {
					getWorkOrderListInput.WorkOrder.WorkOrderServiceLines.WorkOrderServiceLine[0] = {ItemID:orderLine.ItemDetails.ItemID,Uom:orderLine.ItemDetails.UnitOfMeasure};
				}
				
			}
			
			if(!iscCore.isVoid(workOrder.Instructions) && !iscCore.isVoid(workOrder.Instructions.Instruction[0])) {
				getWorkOrderListInput.WorkOrder.ServiceInstructions = workOrder.Instructions.Instruction[0].InstructionText;
			}
			
			if(shipNodeDetails && shipNodeDetails.ShipNodePersonInfo) {
				getWorkOrderListInput.WorkOrder.PersonInfoShipTo = shipNodeDetails.ShipNodePersonInfo;
			}
			
			return getWorkOrderListInput;
        	
        };
     
        return iscInStoreAppointment;
}]);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp. 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/


angular.module('isc.shared').factory('iscCalendarCommonService', ["$filter", function($filter) {
	
	var iscCalendarCommonService = {};
	
	iscCalendarCommonService.compareAndSort = function(event1, event2) {// we are referring to flexibleCompare() method in calendar.js.
		// OOTB considerations are done and this comes after.
		// Event without a user "name" will always come last, even if there are some events with "name" that are "complete". Obviously, without user "name" and "open" are last.
		var openWeight = "0";// makes open bubble up.
		var completeWeight = "1";
		var name1 = "z";// "0" < "z" and thus, real name will start with 0 or 1 and will bubble up because of -1 return.
		var name2 = "z";
		var isNameNotVoid = false;
		
		if (event1.customerDetails != null && event1.customerDetails.name != null) {
			name1 = event1.customerDetails.name;
			isNameNotVoid = true;
		}
		if (isNameNotVoid && event1.status.toLowerCase() === "open") {
			name1 = openWeight + name1;
		} else if (isNameNotVoid) {
			name1 = completeWeight + name1;
		}
		isNameNotVoid = false;
		if (event2.customerDetails != null && event2.customerDetails.name != null) {
			name2 = event2.customerDetails.name;
			isNameNotVoid = true;
		}
		if (isNameNotVoid && event2.status.toLowerCase() === "open") {
			name2 = openWeight + name2;
		} else if (isNameNotVoid) {
			name2 = completeWeight + name2;
		}
		return name1.localeCompare(name2);
	};
	
	// Need to consider timezones.
	iscCalendarCommonService.areSameMomentDays = function(moment1, moment2, ignoreTimezone) {
		return (moment1.format("YYYY-MM-DD") === moment2.format("YYYY-MM-DD"));
	};
	
	iscCalendarCommonService.isCurrentDayAHolidayInWeek = function(currentDayMoment, weekArray) {
		var returnVal = false;
		if (!(currentDayMoment == null || weekArray == null || weekArray.length == null)) {
			for (var i = 0; i < weekArray.length; i++) {
				if (iscCalendarCommonService.areSameMomentDays(currentDayMoment, weekArray[i]["currentDayMoment"]) && weekArray[i]["isHoliday"] === true) {
					returnVal = true;
					break;
				}
			}
		}
		return returnVal;
	};
	
	iscCalendarCommonService.getMomentForTimezone = function(dateString, timezoneOffset, getStartOfDay) {
		if (iscCore.isVoid(dateString)) {//null, undefined, ""
			dateString = undefined;
		}
		var retMoment = new moment($filter('date')(new moment(dateString).format('YYYY-MM-DDTHH:mm:ss'), 'yyyy-MM-ddTHH:mm:ss', timezoneOffset));//include time component as well.
		return (getStartOfDay === true ? retMoment.set({"hours": 0, "minutes": 0, "seconds": 0}) : retMoment);
	};
	
	iscCalendarCommonService.getMomentWithStartOfDayTimeForLocal = function(dateString) {// We will not consider timezoneOffset.
		if (iscCore.isVoid(dateString)) {//null, undefined, ""
			dateString = undefined;
		} else if (dateString.indexOf("T") != -1) {//if it has time component, remove it.
			dateString.substring(0, dateString.indexOf("T"));
		}
		return new moment(dateString);
	};
	
	iscCalendarCommonService.getMomentStringWithoutTime = function(momentDateInstance) {
		return momentDateInstance.clone().format("YYYY-MM-DD");
	};
	
	return iscCalendarCommonService;
	
}]);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp. 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/


angular.module('isc.shared').factory('iscCalendarDayAgendaViewOverridesService', ["iscCalendarDayAgendaViewPvdr", "iscCalendarCommonService", function(iscCalendarDayAgendaViewPvdr, iscCalendarCommonService) {
	
	var iscCalendarDayAgendaViewOverridesService = {};
	
	var _fn_override_renderFgSegsIntoContainers = function(TimeGrid, calendarJsonProps, param_const_threshold) {
		TimeGrid.prototype.renderFgSegsIntoContainers = function(segs, containerEls) {
			var segsByCol;
			var col;
			
			// Nimit change start
			segs = _fn_getNewSegsArray(this, segs, calendarJsonProps, param_const_threshold);
			// Nimit change end
			
			segs = this.renderFgSegEls(segs); // will call fgSegHtml
			segsByCol = this.groupSegsByCol(segs);
			
			for (col = 0; col < this.colCnt; col++) {
				this.updateFgSegCoords(segsByCol[col]);
			}

			this.attachSegsByCol(segsByCol, containerEls);

			return segs;
		};
	};
	
	var _fn_getNewSegsArray = function(timeGridInstance, segs, calendarJsonProps, param_const_threshold) {
		//var currentMoment = timeGridInstance.view.calendar.moment();
		//var dateStringOnly = currentMoment.stripTime().format();
		var dateStringOnly = calendarJsonProps.selectedDayString;
		var moment_timeSlotIncrement = moment.duration(iscCalendarDayAgendaViewPvdr.getCalendarMinTimeSlotDuration());
		var moment_dayFirstSlot = timeGridInstance.view.calendar.moment(dateStringOnly + "T" + calendarJsonProps.minTime);
		var moment_dayLastSlot = timeGridInstance.view.calendar.moment(dateStringOnly + "T" + calendarJsonProps.maxTime);
		
		var allIntervals_StartEnd_Array = [];
		var index = 0;
		// Fix issue where _i is 9am still - good to read text so, should keep updating.
		do {
			var currStart = (index === 0) ? moment_dayFirstSlot : allIntervals_StartEnd_Array[index - 1]["end"];
			currStart = timeGridInstance.view.calendar.moment(currStart.format());
			var currEnd = currStart.clone().add(moment_timeSlotIncrement);
			currEnd = timeGridInstance.view.calendar.moment(currEnd.format());
			allIntervals_StartEnd_Array[index] = {
				"start": currStart,
				"end": currEnd,
				"event": {
					"allDay": false,
					"start": currStart,
					"end": currEnd,
					"_buttonId": calendarJsonProps.id + "_popoverBtn",
					"_calendarId": calendarJsonProps.id,
				},
				"col": 0,
				"dayIndex": 0,
				"isStart": true,
				"isEnd": true,
				"eventStartMS": currStart.valueOf(),
				"eventDurationMS": moment_timeSlotIncrement.valueOf()
			};
			index++;
		} while(moment_dayLastSlot > allIntervals_StartEnd_Array[index - 1]["end"]);
		// For cases when the moment_dayLastSlot is not a multiple of moment_timeSlotIncrement.
		if (allIntervals_StartEnd_Array[index - 1]["end"] > moment_dayLastSlot) {
			allIntervals_StartEnd_Array.pop();
		}
		
		var intervalsIndexToEventsCount_Array = [];
		var intervalsExceedingThresholdEventsNumber_Array = [];
		for (var i = 0; i < allIntervals_StartEnd_Array.length; i++) {
			var currentIntervalObj = allIntervals_StartEnd_Array[i];
			var count = 0;
			for (var j = 0; j < segs.length; j++) {
				if (currentIntervalObj.start < segs[j].end && currentIntervalObj.end > segs[j].start) {
					count++;
				}
			}
			intervalsIndexToEventsCount_Array.push(count);
			if (count > param_const_threshold) {
				currentIntervalObj["event"]["thresholdExceededBy"] = count - param_const_threshold;
				intervalsExceedingThresholdEventsNumber_Array.push(currentIntervalObj);
				segs.push(currentIntervalObj);
			}
		}
		return segs;
	};
	
	var _fn_override_compareEventSegs = function(TimeGrid) {
		// Unfortunately even after providing custom "eventOrder" method, we need to override because we need +event at end. Remove, if we are not doing that after ux review.
		TimeGrid.prototype.compareEventSegs = function(seg1, seg2) {
			//Both seg1 and seg2 can not be the +event ones.
			if (seg1["event"]["thresholdExceededBy"] != null) {
				return 1;
			} else if(seg2["event"]["thresholdExceededBy"] != null) {
				return -1;
			} else if (seg1["event"]["thresholdExceededBy"] != null && seg2["event"]["thresholdExceededBy"] != null) {
				//Both seg1 and seg2 can not be the +event ones. log this.
				console.warn("calendar-day-agenda-view.directive.js - TimeGrid.prototype.compareEventSegs - unexpected scenario. seg1 and seg2 null.");
				return 0;
			} else {
				return seg1.eventStartMS - seg2.eventStartMS || // OOTB-earlier events go first
					seg2.eventDurationMS - seg1.eventDurationMS || // OOTB-tie? longer events go first
					seg2.event.allDay - seg1.event.allDay || // OOTB-tie? put all-day events first (booleans cast to 0/1)
					iscCalendarCommonService.compareAndSort(seg1.event, seg2.event);//custom.
			}
		}
	};
	
	var _fn_override_generateFgSegHorizontalCss = function(TimeGrid, param_const_threshold, param_const_threshold_const) {
		// Generates an object with CSS properties/values that should be applied to an event segment element.
		// Contains important positioning-related properties that should be applied to any event element, customized or not.
		TimeGrid.prototype.generateFgSegHorizontalCss = function(seg) {
			var shouldOverlap = this.view.opt('slotEventOverlap');
			var backwardCoord = seg.backwardCoord; // the left side if LTR. the right side if RTL. floating-point
			var forwardCoord = seg.forwardCoord; // the right side if LTR. the left side if RTL. floating-point
			var props = this.generateSegVerticalCss(seg); // get top/bottom first
			var left; // amount of space from left edge, a fraction of the total width
			var right; // amount of space from right edge, a fraction of the total width
			
			// Nimit change start
			/*
				forwardCoord - in LTR, represents how far the right edge is as a fraction.
				backwardCoord - in LTR, represents how far the left edge is as a fraction.
				1. In LTR, forwardCoord > backwardCoord
				2. 1/(forwardCoord - backwardCoord) will give the number of levels/events.
				3. forwardCoord/(forwardCoord - backwardCoord) will give the level of current seg.
				4. forwardPressure - number of events after event.
				5. level - the number or index of current event. Starts from 0.
			*/
			//var numberOfLevels = Math.abs(Math.round(1/(forwardCoord - backwardCoord)));
			//var currentSegLevel = Math.abs(Math.round(forwardCoord/(forwardCoord - backwardCoord)));
			//var numberOfLevels = seg.forwardPressure + 1;
			var currentSegLevel = seg.level + 1;
			if (currentSegLevel > param_const_threshold) {
				forwardCoord = 1;
				backwardCoord = 1.1;
			} else {
				forwardCoord = param_const_threshold_const * currentSegLevel;
				backwardCoord = forwardCoord - param_const_threshold_const;
			}
			if (seg["event"]["thresholdExceededBy"] != null) {
				forwardCoord = 1;
				backwardCoord = (param_const_threshold * param_const_threshold_const);
			}
			// Nimit change end
			
			if (shouldOverlap) {
				// double the width, but don't go beyond the maximum forward coordinate (1.0)
				forwardCoord = Math.min(1, backwardCoord + (forwardCoord - backwardCoord) * 2);
			}

			if (this.isRTL) {
				left = 1 - forwardCoord;
				right = backwardCoord;
			}
			else {
				left = backwardCoord;
				right = 1 - forwardCoord;
			}

			props.zIndex = seg.level + 1; // convert from 0-base to 1-based
			props.left = left * 100 + '%';
			props.right = right * 100 + '%';

			if (shouldOverlap && seg.forwardPressure) {
				// add padding to the edge so that forward stacked events don't cover the resizer's icon
				props[this.isRTL ? 'marginLeft' : 'marginRight'] = 10 * 2; // 10 is a guesstimate of the icon's width
			}

			return props;
		}
	};
	
	iscCalendarDayAgendaViewOverridesService.overrideCoreMethods = function(calendarJsonProps, param_const_threshold, param_const_threshold_const) {
		var FC = $.fullCalendar;	// a reference to FullCalendar's root namespace
		var TimeGrid = FC.TimeGrid;	// the class that all views must inherit from
		
		_fn_override_renderFgSegsIntoContainers(TimeGrid, calendarJsonProps, param_const_threshold);
		
		_fn_override_compareEventSegs(TimeGrid);
		
		_fn_override_generateFgSegHorizontalCss(TimeGrid, param_const_threshold, param_const_threshold_const);
	
	};
	
	return iscCalendarDayAgendaViewOverridesService;
	
}]);
/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp. 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/


angular.module('isc.shared').factory('iscCalendarDayAgendaViewService', ["iscCalendarDayAgendaViewPvdr", "iscI18n", function(iscCalendarDayAgendaViewPvdr, iscI18n) {
	
	var iscCalendarDayAgendaViewService = {};
	
	var _fn_getPopupPosition = function(calViewInstance, popupHolderEl, origEl) {
		var position = "bottom";
		
		var elem4boundary_y_AND_height = _fn_getCalElemFor_y_height(calViewInstance);
		var elem4boundary_y_AND_height__y2 = elem4boundary_y_AND_height.offset().top + elem4boundary_y_AND_height.outerHeight();
		var popupHolderEl_height = popupHolderEl.outerHeight();
		var origEl_y2 = origEl.offset().top + origEl.outerHeight();
		
		if (((origEl_y2 < elem4boundary_y_AND_height__y2) && ((elem4boundary_y_AND_height__y2 - origEl_y2) < popupHolderEl_height)) || (origEl_y2 > elem4boundary_y_AND_height__y2)) {
			position = "top";
		}
		return position;
	};
	
	var _fn_getCalElemFor_y_height = function(calViewInstance) {
		return jQuery(calViewInstance.el[0]);
	};
	
	var _fn_getCalElemFor_x_width = function(calViewInstance) {
		return _fn_getCalElemFor_y_height(calViewInstance).find(".fc-body .fc-widget-content .fc-time-grid-container .fc-time-grid table tbody .fc-day.fc-widget-content");
	};
	
	var _fn_setTitleForPopup = function(elemOfInterest, calEvent) {
		var startTime = calEvent.start.format(iscCalendarDayAgendaViewPvdr.getCalendarPopupTimeFormat());
		var endTime = calEvent.end.format(iscCalendarDayAgendaViewPvdr.getCalendarPopupTimeFormat());
		elemOfInterest.html(iscI18n.translate("calendar.TITLE_allEventsHeader", {'startTime': startTime, 'endTime': endTime}));
	};
	
	var _fn_getScrollBarWidth = function() {
		var outerElem = $('<div>').css({visibility: 'hidden', width: 100, overflow: 'scroll'}).appendTo('body'),
			widthWithScroll = $('<div>').css({width: '100%'}).appendTo(outerElem).outerWidth();
		outerElem.remove();
		return 100 - widthWithScroll;
	};
	
	var _fn_calcArrow_y = function(elemClicked_jq_coord_y1, elemClicked_jq_coord_y2, CONST_marginVertical, popup_coord_y1, popupHeight, allEventsPopupEl_arrow) {
		var availableHeight = elemClicked_jq_coord_y2 - elemClicked_jq_coord_y1;
		var arrowElemHeight = allEventsPopupEl_arrow.outerHeight(true);
		var y_arrow = elemClicked_jq_coord_y1 + availableHeight/2;//set top of arrow to midpoint - absolute wrt page.
		//if top/bottom of the arrow is outside or located on the margin for popup, then do not show it - set it as -100. Check for this and add add display: none to hide.
		if ((y_arrow - arrowElemHeight/2) < (popup_coord_y1 + CONST_marginVertical/2)) {
			y_arrow = -100;
		} else if ((y_arrow + arrowElemHeight/2) > (popup_coord_y1 + popupHeight - CONST_marginVertical/2)) {
			y_arrow = -100;
		} else {
			y_arrow = y_arrow - popup_coord_y1 - CONST_marginVertical/2;//relative wrt popup elem.
			y_arrow = y_arrow - arrowElemHeight/2;//move top of arrow higher to account for height of arrow itself - so arrow is in exact middle.
		}
		return y_arrow;
	};
	
	var _fn_getVariousCoordsForAllEventsPopup = function(allEventsPopupEl_holder, allEventsPopupEl, allEventsPopupEl_arrow, calViewInstance, clickedEl, eventCount, CONST_threshold, singleEventHeight, singleEventWidth) {
		var CONST_heightExtraPerRow = 4; //unable to understand why this is present or how to remove it, but it exists in html.
		
		var popupHeightIncludingMargin = allEventsPopupEl_holder.outerHeight(true);
		var popupContentInnerHeight = allEventsPopupEl.innerHeight();
		var popupContentHeightOnly = allEventsPopupEl.height();
		var CONST_extraHeightOutsideContent = popupHeightIncludingMargin - popupContentInnerHeight;
		var CONST_paddingVertical = popupContentInnerHeight - popupContentHeightOnly;
		var CONST_marginVertical = popupHeightIncludingMargin - allEventsPopupEl_holder.outerHeight();
		
		var popupWidthIncludingMargin = allEventsPopupEl_holder.outerWidth(true);
		var popupContentInnerWidth = allEventsPopupEl.innerWidth();
		var popupContentWidthOnly = allEventsPopupEl.width();
		var CONST_extraWidthOutsideContent = popupWidthIncludingMargin - popupContentInnerWidth;
		var CONST_paddingHorizontal = popupContentInnerWidth - popupContentWidthOnly;
		
		var elem4boundary_x_AND_width = _fn_getCalElemFor_x_width(calViewInstance);
		var elem4boundary_y_AND_height = _fn_getCalElemFor_y_height(calViewInstance);
		var elemClicked_jq = jQuery(clickedEl);
		
		var popupContent_width = elem4boundary_x_AND_width.outerWidth();
		var popupContent_height = elem4boundary_y_AND_height.outerHeight();
		if (eventCount < CONST_threshold) {//events can be displayed in one line - unlikely scenario.
			popupContent_width = (singleEventWidth * eventCount);
			popupContent_height = singleEventHeight;
		} else {
			popupContent_width = (singleEventWidth * CONST_threshold);
			popupContent_height = singleEventHeight * Math.ceil(eventCount/CONST_threshold);
		}
		popupContent_height = popupContent_height + (CONST_heightExtraPerRow * Math.ceil(eventCount/CONST_threshold));
		if ((popupContent_height + CONST_extraHeightOutsideContent + CONST_paddingVertical) > elem4boundary_y_AND_height.outerHeight()) {
			popupContent_height = elem4boundary_y_AND_height.outerHeight() - (CONST_extraHeightOutsideContent + CONST_paddingVertical);
			popupContent_width = popupContent_width + _fn_getScrollBarWidth();
		}
		var popupHeight = popupContent_height + CONST_extraHeightOutsideContent + CONST_paddingVertical;
		
		var popup_coord_x1 = elem4boundary_x_AND_width.offset().left;
		var popup_coord_x2_max = elemClicked_jq.offset().left;
		if ((popupContent_width + CONST_extraWidthOutsideContent + CONST_paddingHorizontal) > (popup_coord_x2_max - popup_coord_x1)) {
			popup_coord_x1 = popup_coord_x1 - (popupContent_width + CONST_extraWidthOutsideContent + CONST_paddingHorizontal - (popup_coord_x2_max - popup_coord_x1));
			// x1 should not go into negatives. As of today, it is unexpected and not designed for.
		}
		
		var coord_y1_min = elem4boundary_y_AND_height.offset().top;
		var coord_y2_max = elem4boundary_y_AND_height.offset().top + elem4boundary_y_AND_height.outerHeight();
		var coord_y1_elemClicked_jq = elemClicked_jq.offset().top;
		var coord_y2_elemClicked_jq = coord_y1_elemClicked_jq + elemClicked_jq.outerHeight();
		var coord_yMid_elemClicked_jq = (coord_y1_elemClicked_jq + coord_y2_elemClicked_jq)/2;
		
		var y_arrowElem = 0;
		var popup_coord_y1 = 0;
		if (coord_y1_elemClicked_jq < coord_y1_min && coord_y2_elemClicked_jq >= coord_y1_min) {// if elemClicked_jq top y1 is located above coord_y1_min.
			popup_coord_y1 = coord_y1_min;
			y_arrowElem = _fn_calcArrow_y(coord_y1_min, coord_y2_elemClicked_jq, CONST_marginVertical, popup_coord_y1, popupHeight, allEventsPopupEl_arrow);// get arrow y location
		} else if (coord_y1_elemClicked_jq <= coord_y2_max && coord_y2_elemClicked_jq > coord_y2_max) {// if elemClicked_jq top y1 is visible but bottom y2 is locared below coord_y2_max.
			popup_coord_y1 = (coord_y2_max - popupHeight);
			y_arrowElem = _fn_calcArrow_y(coord_y1_elemClicked_jq, coord_y2_max, CONST_marginVertical, popup_coord_y1, popupHeight, allEventsPopupEl_arrow);// get arrow y location
		} else {
			if ((coord_yMid_elemClicked_jq + popupHeight/2) > coord_y2_max) {
				popup_coord_y1 = (coord_y2_max - popupHeight);
			} else if ((coord_yMid_elemClicked_jq - popupHeight/2) < coord_y1_min) {
				popup_coord_y1 = coord_y1_min;
			} else {
				popup_coord_y1 = (coord_yMid_elemClicked_jq - popupHeight/2);
			}
			y_arrowElem = _fn_calcArrow_y(coord_y1_elemClicked_jq, coord_y2_elemClicked_jq, CONST_marginVertical, popup_coord_y1, popupHeight, allEventsPopupEl_arrow);// get arrow y location
		}
		
		return {//round off all decimals to higher integer.
			contentHeight: Math.ceil(popupContent_height + CONST_paddingVertical),
			contentWidth: Math.ceil(popupContent_width + CONST_paddingHorizontal),
			popupTop: Math.ceil(popup_coord_y1),
			popupLeft: Math.ceil(popup_coord_x1),
			arrowTop: Math.ceil(y_arrowElem)
		};
	};
	
	iscCalendarDayAgendaViewService.getElementStringForCalEvent = function(calEvent, element) {
		var calEventElemStr = "<a>";
		if (calEvent.thresholdExceededBy == null) {
			var eventName = (!iscCore.isVoid(calEvent.eventName)) ? calEvent.eventName : "";
			var translatedStatus = (!iscCore.isVoid(calEvent.status)) ? iscI18n.translate(calEvent.statusBundleKey) : "";
			var customerName = (!iscCore.isVoid(calEvent.customerDetails) && !iscCore.isVoid(calEvent.customerDetails.name)) ? calEvent.customerDetails.name : "";
			var email = (!iscCore.isVoid(calEvent.customerDetails) && !iscCore.isVoid(calEvent.customerDetails.email)) ? calEvent.customerDetails.email : "";
			var separatorChar = "|";
			var mobile = (!iscCore.isVoid(calEvent.customerDetails) && !iscCore.isVoid(calEvent.customerDetails.mobile)) ? calEvent.customerDetails.mobile : "";
			if (email === "" || mobile === "") {
				separatorChar = "";
			}
			var cssClazzToAdd = "cal-event-open";
			if (calEvent.status === "COMPLETE") {
				cssClazzToAdd = "cal-event-complete";
			}
			if (iscCore.isVoid(customerName) || (typeof customerName === "string" && customerName.trim() === "")) {//complete for an unknown customer name should not be possible. But we are still handling it and showing it as unknown css.
				cssClazzToAdd = "cal-event-unknown";
			}
			var eventDuration = "";
			if (calEvent.end != null && calEvent.start != null) {
				var startTime = calEvent.start.format(iscCalendarDayAgendaViewPvdr.getCalendarPopupTimeFormat());
				var endTime = calEvent.end.format(iscCalendarDayAgendaViewPvdr.getCalendarPopupTimeFormat());
				eventDuration = iscI18n.translate("calendar.LABEL_eventDuration", {'startTime': startTime, 'endTime': endTime});
			}
			calEventElemStr = '<a href="javascript:void(0);" class="' + element.attr("class") + " " + cssClazzToAdd + '" style="' + element.attr("style") + '">' +
				'<div class="fc-content">' +
					'<div class="service-details">' +
						'<div class="grp-hdr-text-h1">' + eventName + '</div>' +
						'<div class="grp-hdr-text-h2 event-duration">' + eventDuration + '</div>' +
						'<div class="grp-hdr-text-h2 status-italic">' + translatedStatus + '</div>' +
					'</div>' +
					'<div class="customer-details">' +
						'<div class="grp-hdr-text-h2">' + customerName + '</div>' +
						'<div>' + 
							'<span class="inline-block grp-hdr-text-h2">' + mobile + '</span>' +
							'<span class="inline-block separator-elem grp-hdr-text-h2">' + separatorChar + '</span>' +
							'<span class="inline-block grp-hdr-text-h2">' + email + '</span>' +
						'</div>' +
					'</div>' +
				'</div>' +
				'<div class="fc-bg"></div>' +
				'<div class="fc-resizer fc-end-resizer"></div>' +
			'</a>';
		} else {
			var clazzToAdd = "cal-events-more";
			calEventElemStr = '<a href="javascript:void(0);" class="' + element.attr("class") + " " + clazzToAdd + '" style="' + element.attr("style") + '">' +
				'<div class="grp-hdr-text-h1 center-align">+' + calEvent.thresholdExceededBy + '</div>' +
				'<div class="fc-bg"></div>' +
				'<div class="fc-resizer fc-end-resizer"></div>' +
			'</a>';
		}
		return calEventElemStr;
	};
	
	iscCalendarDayAgendaViewService.transformStringToCorrectTypeAndReturnValue = function(inputValue) {
		var returnVal = inputValue;
		if (typeof inputValue !== "string") {
			returnVal = inputValue;
		} else if (inputValue === "true" || inputValue === "false") {
			// boolean
			returnVal = JSON.parse(inputValue);
		} else if (inputValue.indexOf("{") === 0 || inputValue.indexOf("[") === 0) {
			// json
			returnVal = inputValue.replace(/\'/g, '\"');
			returnVal = JSON.parse(returnVal);
		} else {
			// number
			returnVal = Number(inputValue);
			if (isNaN(returnVal)) {
				returnVal = inputValue;
			}
		}
		return returnVal;
	};
	
	iscCalendarDayAgendaViewService.getAnchorElemFromJSEvent = function(jsEvent) {
		var reqdElem = [];
		if (jsEvent != null && jsEvent.target != null) {
			var reqdElem = jQuery(jsEvent.target);
			var reqdElem_tagName = reqdElem.prop("tagName");
			while (reqdElem != null && reqdElem[0] != null && reqdElem_tagName.toUpperCase() != "A") {
				reqdElem = reqdElem.parent();
				reqdElem_tagName = reqdElem.prop("tagName");
			}
		}
		return reqdElem;
	};
	
	iscCalendarDayAgendaViewService.getCssArrayUsedToHideHolderAndMask = function() {
		return ["zindexZeroInvisible", "visibilityHidden", "absoluteOffScreen"];
	};
	
	iscCalendarDayAgendaViewService.getCssArrayUsedToShowHolder = function() {
		return ["zindexHigh", "block-component", "absoluteOnScreen"];
	};
	
	iscCalendarDayAgendaViewService.getCssArrayUsedToShowMask = function() {
		return ["zindexModerate", "block-component", "absoluteOnScreenFullScreen", "show-cursor-default", "popupMaskAndOpacity"];
	};
	
	iscCalendarDayAgendaViewService.removeClazzes = function(elem, clazzArrey) {
		elem = jQuery(elem);
		clazzArrey = (clazzArrey != null && clazzArrey.length != null) ? clazzArrey : [clazzArrey];
		if (clazzArrey.length === 0) {
			elem.removeClass();
		} else {
			for (var i = 0; i < clazzArrey.length; i++) {
				if (clazzArrey[i] != null) {
					elem.removeClass(clazzArrey[i]);
				}
			}
		}
	};
	
	iscCalendarDayAgendaViewService.addClazzes = function(elem, clazzArrey) {
		elem = jQuery(elem);
		clazzArrey = (clazzArrey != null && clazzArrey.length != null) ? clazzArrey : [clazzArrey];
		for (var i = 0; i < clazzArrey.length; i++) {
			if (clazzArrey[i] != null) {
				elem.addClass(clazzArrey[i]);
			}
		}
	};
	
	iscCalendarDayAgendaViewService.getAllRequiredElementsForPopup = function(idPrefix, middleString, appendHeaderAtLast) {
		var requiredElementsForPopup = [
			jQuery(("#" + idPrefix + middleString + "_holder")),
			jQuery(("#" + idPrefix + middleString + "")),
			jQuery(("#" + idPrefix + middleString + "_arrow")),
			jQuery(("#" + idPrefix + middleString + "_mask"))
		];
		if (appendHeaderAtLast === true) {
			requiredElementsForPopup.push(jQuery(("#" + idPrefix + middleString + "_header")));
		}
		return requiredElementsForPopup;
	};
	
	iscCalendarDayAgendaViewService.showDetailsPopupForEvent = function(clonedEl, origEl, calViewInstance) {
		origEl = jQuery(origEl);
		var clonedEl_jq = jQuery(clonedEl);
		
		var allElemArray = iscCalendarDayAgendaViewService.getAllRequiredElementsForPopup(calViewInstance.options.id, "_calEvent_moreDetails");
		var moreDetailsPopupEl_holder = allElemArray[0];
		var moreDetailsPopupEl = allElemArray[1];
		var moreDetailsPopupEl_arrow = allElemArray[2];
		var moreDetailsPopupEl_mask = allElemArray[3];
		
		if (moreDetailsPopupEl.length === 1) {
			iscCalendarDayAgendaViewService.addClazzes(moreDetailsPopupEl_holder, ["block-component"]);
			clonedEl_jq.attr("style", "");
			iscCalendarDayAgendaViewService.addClazzes(clonedEl_jq, ["add-top-margin-border"]);
			moreDetailsPopupEl.append(clonedEl);
			
			iscCalendarDayAgendaViewService.removeClazzes(moreDetailsPopupEl_holder, iscCalendarDayAgendaViewService.getCssArrayUsedToHideHolderAndMask());
			iscCalendarDayAgendaViewService.addClazzes(moreDetailsPopupEl_holder, iscCalendarDayAgendaViewService.getCssArrayUsedToShowHolder());
			
			moreDetailsPopupEl_holder.css({"width": origEl.outerWidth()});
			
			var popupPosition = _fn_getPopupPosition(calViewInstance, moreDetailsPopupEl_holder, origEl);
			var clazzToAddToArrow = "cal-popup-more-details-arrow";
			var clazzToAddToBorder = clazzToAddToArrow;
			var origEl_offset = origEl.offset();
			var left = origEl_offset.left;
			var top = origEl_offset.top + origEl.outerHeight();
			
			if (popupPosition === "top") {
				clazzToAddToArrow = "cal-popup-more-details-arrow-top";
				top = origEl_offset.top - moreDetailsPopupEl_holder.outerHeight();
				iscCalendarDayAgendaViewService.removeClazzes(clonedEl_jq, ["add-top-margin-border"]);
				iscCalendarDayAgendaViewService.addClazzes(clonedEl_jq, ["add-bottom-margin-border"]);
			}
			moreDetailsPopupEl_holder.css({"top": top, "left": left});
			clazzToAddToBorder = clazzToAddToArrow;
			if (clonedEl_jq.hasClass("cal-event-open")) {
				clazzToAddToBorder = clazzToAddToBorder + "-cal-event-open";
			} else if (clonedEl_jq.hasClass("cal-event-complete")) {
				clazzToAddToBorder = clazzToAddToBorder + "-cal-event-complete";
			} else if (clonedEl_jq.hasClass("cal-event-unknown")) {
				clazzToAddToBorder = clazzToAddToBorder + "-cal-event-unknown";
			}
			iscCalendarDayAgendaViewService.addClazzes(moreDetailsPopupEl_arrow, [clazzToAddToArrow, clazzToAddToBorder]);
		}
		if (moreDetailsPopupEl_mask.length === 1) {
			iscCalendarDayAgendaViewService.removeClazzes(moreDetailsPopupEl_mask, iscCalendarDayAgendaViewService.getCssArrayUsedToHideHolderAndMask());
			iscCalendarDayAgendaViewService.addClazzes(moreDetailsPopupEl_mask, iscCalendarDayAgendaViewService.getCssArrayUsedToShowMask());
		}
	};
	
	iscCalendarDayAgendaViewService.showAllEventsPopupForEvents = function(calEvent, clonedAnchorElemArray, origEl, calViewInstance, CONST_threshold, CONST_threshold_popup_const) {
		var allElemArray = iscCalendarDayAgendaViewService.getAllRequiredElementsForPopup(calViewInstance.options.id, "_calEvents_allEvents", true);
		var allEventsPopupEl_holder = allElemArray[0];
		var allEventsPopupEl = allElemArray[1];
		var allEventsPopupEl_header = allElemArray[4];
		var allEventsPopupEl_arrow = allElemArray[2];
		var allEventsPopupEl_mask = allElemArray[3];
		
		if (allEventsPopupEl.length === 1) {
			//allEventsPopupEl_holder.attr("style", "display: block;");
			iscCalendarDayAgendaViewService.removeClazzes(allEventsPopupEl_holder, iscCalendarDayAgendaViewService.getCssArrayUsedToHideHolderAndMask());
			iscCalendarDayAgendaViewService.addClazzes(allEventsPopupEl_holder, iscCalendarDayAgendaViewService.getCssArrayUsedToShowHolder());
			//iscCalendarDayAgendaViewService.addClazzes(allEventsPopupEl, ["add-right-margin"]);
			
			var singleEventWidth = Math.ceil(_fn_getCalElemFor_x_width(calViewInstance).outerWidth(true) * CONST_threshold_popup_const);
			var actualHeight = 0;
			var actualWidth = 0;
			var maxHeight = 0;
			for (var i = 0; i < clonedAnchorElemArray.length; i++) {
				jQuery(clonedAnchorElemArray[i]).attr("style", "");
				jQuery(clonedAnchorElemArray[i]).css({"display": "inline-block", "width": singleEventWidth});
				allEventsPopupEl.append(clonedAnchorElemArray[i]);
				if (maxHeight < jQuery(clonedAnchorElemArray[i]).outerHeight()) {// Find max height. Set all the elements to same height.
					maxHeight = jQuery(clonedAnchorElemArray[i]).outerHeight();
					actualWidth = jQuery(clonedAnchorElemArray[i]).outerWidth(true);
				}
			}
			for (var i = 0; i < clonedAnchorElemArray.length; i++) {
				jQuery(clonedAnchorElemArray[i]).css({"height": maxHeight});
				if (i === clonedAnchorElemArray.length - 1) {
					actualHeight = jQuery(clonedAnchorElemArray[i]).outerHeight(true);
				}
			}
			_fn_setTitleForPopup(allEventsPopupEl_header, calEvent);
			// Set css to make margin-right as 0 so that arrow can be shown.
			var popupCoords = _fn_getVariousCoordsForAllEventsPopup(allEventsPopupEl_holder, allEventsPopupEl, allEventsPopupEl_arrow, calViewInstance, origEl, clonedAnchorElemArray.length, CONST_threshold, actualHeight, actualWidth);
			allEventsPopupEl_holder.css({"top": popupCoords.popupTop, "left": popupCoords.popupLeft});
			allEventsPopupEl.css({"width": popupCoords.contentWidth, "height": popupCoords.contentHeight});
			if (popupCoords.arrowTop != -100) {
				allEventsPopupEl_arrow.css({"top": popupCoords.arrowTop});
			} else {
				allEventsPopupEl_arrow.css({"display": "none"});
			}
			
		}
		if (allEventsPopupEl_mask.length === 1) {
			iscCalendarDayAgendaViewService.removeClazzes(allEventsPopupEl_mask, iscCalendarDayAgendaViewService.getCssArrayUsedToHideHolderAndMask());
			iscCalendarDayAgendaViewService.addClazzes(allEventsPopupEl_mask, iscCalendarDayAgendaViewService.getCssArrayUsedToShowMask());
		}
	};
	
	return iscCalendarDayAgendaViewService;
	
}]);
/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp.  2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/

/**
 * @ngdoc service
 * @name iscCustomer
 * 
 * 
 * @description 
 * Handles all the common tasks related to customer. 
 * 
 */
angular.module('isc.shared').factory('iscCustomer', ['$http','$filter','$q','iscAppInfo','iscModal','iscI18n','iscMashup','iscState','iscObjectUtility','iscAppContext','$rootScope','iscResourcePermission',
 function($http,$filter,$q,iscAppInfo,iscModal,iscI18n,iscMashup, iscState,iscObjectUtility,iscAppContext,$rootScope,iscResourcePermission) {
  
   var customerService = {};	 
   
   /**
	 * @ngdoc method
	 * @name iscOrder#stampDisplayStatusOnOrderList
	 * @description Stamps Display address on the customer based on the priority DefaultBillTo or DefaultShipTo or CustomerAdditionalAddress
	 * @param {Object} customer - customer model. 
	 */
   customerService.getDisplayAddressForCustomer = function(customer) {
	 
	   var customerAddress = null;
   	
	   	if(!iscCore.isVoid(customer) && !iscCore.isVoid(customer.CustomerContactList) && !iscCore.isVoid(customer.CustomerContactList.CustomerContact[0])) {
	   		
	   		var customerContact = customer.CustomerContactList.CustomerContact[0];
	   		
	   		if(!iscCore.isVoid(customerContact.DefaultBillToAddress) && !iscCore.isVoid(customerContact.DefaultBillToAddress.PersonInfo)) {
	   			customerAddress = customerContact.DefaultBillToAddress.PersonInfo;
	   		}
	   		
	   		if(iscCore.isVoid(customerAddress) && !iscCore.isVoid(customerContact.DefaultShipToAddress) && !iscCore.isVoid(customerContact.DefaultShipToAddress.PersonInfo)) {
	   			customerAddress = customerContact.DefaultShipToAddress.PersonInfo;
	   		}
	   		
	   		if(iscCore.isVoid(customerAddress) && !iscCore.isVoid(customerContact.CustomerAdditionalAddressList) 
	   				&& !iscCore.isVoid(customerContact.CustomerAdditionalAddressList.CustomerAdditionalAddress[0]) 
	   					&& !iscCore.isVoid(customerContact.CustomerAdditionalAddressList.CustomerAdditionalAddress[0].PersonInfo)) {
	   			customerAddress = customerContact.CustomerAdditionalAddressList.CustomerAdditionalAddress[0].PersonInfo;
	   		}
	   		
	   	}
	   	
	   	customer.DisplayCustomerAddress = customerAddress;
	   	
	   	return customer;
	   
   };
    
   return customerService;
 }]);




/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp. 2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
/**
 * @ngdoc service
 * @name iscDateFilterComboBox
 * 
 * @description Configures the date range options for a date filter pop-up. The date range options are particular to a screen. 
 * 
 */
angular.module('isc.shared').factory('iscDateFilterComboBox', 
 function() {
	var dateFilterComboBoxService = {};
  
	dateFilterComboBoxService._DATE_FILTER_COMBO_OPTIONS = {};
  
	/**
	 * @ngdoc method
	 * @name iscDateFilterComboBox#addComboOptions
	 * @description Adds the date range options for the combobox which is used along with the datepicker pop-up
	 * @param calleeId {String} Unique id assigned to the screen/directive where the datepicker pop-up is included
	 * @param comboOptionsArray {Array} Array of objects containing the key-value pairs for the date ranges. An object inside the array contains the values for the following keys: labelBundleKey, startDateDisplay, startDate, endDateDisplay and endDate
	 */
	dateFilterComboBoxService.addComboOptions = function(calleeId,comboOptionsArray) {	
		dateFilterComboBoxService._DATE_FILTER_COMBO_OPTIONS[calleeId] = comboOptionsArray;
	}
	
	/**
	 * @ngdoc method
	 * @name iscDateFilterComboBox#getComboOptions
	 * @description Gets the date range options for the combobox which were configured using the addComboOptions method
	 * @param calleeId {String} Unique id assigned to the screen/directive where the datepicker pop-up is included
	 * @returns comboOptionsArray {Array} Array of objects containing the key-value pairs for the date ranges
	 */
	dateFilterComboBoxService.getComboOptions = function(calleeId) {
		return dateFilterComboBoxService._DATE_FILTER_COMBO_OPTIONS[calleeId];
	}
  
  return dateFilterComboBoxService;
});

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp. 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/

/**
 * @ngdoc service 
 * @name iscDialChartD3Service
 * @requires iscDialChartD3Pvdr
 * @requires iscManagerDashboardService
 * @requires iscI18n
 * 
 * @description 
 * This service is used by iscDialChartD3 directive and contains common functions to process the manager dashboard data for dial charts.
 */

angular.module('isc.shared').factory('iscDialChartD3Service', ['iscDialChartD3Pvdr', 'iscManagerDashboardService', 'iscI18n', function(iscDialChartD3Pvdr, iscManagerDashboardService, iscI18n) {
	var _idToConfigAndScopeMap = {};
	var _blankJson = {
		"name": "blank",
		"label": iscI18n.translate("dialchart.LABEL_blankArea"),
		"value": 0.01,
		"unitValueInnerPadding": 0,
		"radiusInnerPadding": 0,
		"clazz": "regionPadClazz"
	};
	var _noChartDataConfig = {
		"name": "noChartData",
		"label": iscI18n.translate("dialchart.LABEL_noData"),
		"unitValueInnerPadding": 0,
		"radiusInnerPadding": 0.35,
		"clazz": "noChartDataClazz"
	};
	var iscDialChartD3Service = {};
	
	var _convertConfigJsonToRegionArray = function(config, fulfillmentMethod, isSla) {
		var regionArray = [];
		for (var i = 0; i < config.displayStatuses.length; i++) {
			var aDisplayStatus = config.displayStatuses[i];
			var cssClass = aDisplayStatus["ui_chartConfig"]["cssClass"];
			if (isSla && (cssClass == null || cssClass.trim() == "")) {
				cssClass = _getCssClassForSLA(aDisplayStatus, fulfillmentMethod);
			}
			var iconClass = _getIconClass(aDisplayStatus, fulfillmentMethod, cssClass);
			regionArray.push({
				"name": aDisplayStatus["statusName"],
				"label": iscI18n.translate(aDisplayStatus["ui_chartConfig"]["labelKey"]),
				"class": cssClass,
				"iconClass": iconClass,
				"unitValueInnerPadding": aDisplayStatus["ui_chartConfig"]["unitValueInnerPadding"],
				"radiusInnerPadding": aDisplayStatus["ui_chartConfig"]["radiusInnerPadding"]
			});
		}
		return regionArray;
	};
	
	var _getCssClassForSLA = function(aDisplayStatus, fulfillmentMethod) {
		var classToReturn = "";
		var currentCommonCodeJson = iscManagerDashboardService.getCommonCodeListData();
		// We pick css class from aDisplayStatus["statusUIDefaults"]. That is why we have defined that attribute.
		var statusUIDefaults = aDisplayStatus["statusUIDefaults"];
		if (currentCommonCodeJson != null) {
			currentCommonCodeJson = currentCommonCodeJson[fulfillmentMethod];
			for (var i = 0; i < currentCommonCodeJson.length; i++) {
				var aCommonCode = currentCommonCodeJson[i];
				if (aCommonCode["NonLocalizedCodeShortDescription"] === statusUIDefaults) {
					classToReturn = aCommonCode["CssClassName"];
					break;
				}
			}
		}
		return classToReturn;
	};
	
	var _getIconClass = function(aDisplayStatus, fulfillmentMethod, cssClass) {
		if (cssClass == null) {
			cssClass = _getCssClassForSLA(aDisplayStatus, fulfillmentMethod);
		}
		return cssClass;
	};
	
	var _getStatusCss = function(aShipment, fulfillmentMethod, view, selectedStatus) {
		// NOTE: css is getting hard coded here on 3 categories: notStarted, inProgress and complete. If customer adds others, they will always get according to these 3 only.
		var statusCode = aShipment["Status"]["Status"];
		var returnStatusName = "";
		var cssClass = "additional";
		var mgrDashboardConfig = iscDialChartD3Pvdr.getManagerDashboardConfig();
		if (fulfillmentMethod === "bopus") {
			fulfillmentMethod = "pickupInStore";
		} else {
			fulfillmentMethod = "shipFromStore";
		}
		var bopusOrSfsConfig = mgrDashboardConfig[fulfillmentMethod];
		var displayStatuses = bopusOrSfsConfig["shipmentStatus"]["displayStatuses"];
		for (var i = 0; i < displayStatuses.length; i++) {
			var aDisplayStatus = displayStatuses[i];
			var combinedStatusArray = aDisplayStatus["combinedStatusArray"];
			for (var j = 0; j < combinedStatusArray.length; j++) {
				if (combinedStatusArray[j] === statusCode) {
					returnStatusName = aDisplayStatus["statusName"];
					break;
				}
			}
			if (returnStatusName != "") {
				break;
			}
		}
		if (returnStatusName === "notStarted") {
			cssClass = "initial";
		} else if (returnStatusName === "inProgress") {
			cssClass = "inprogress";
		} else if (returnStatusName === "complete") {
			cssClass = "completed";
		}
		return cssClass;
	};
	
	var _getIconClassForAShipment = function(aShipment, fulfillmentMethod, view, selectedStatus) {
		cssClass = aShipment.SLACssClass;
		return cssClass;
	};
	
	/**
	 * @ngdoc method
	 * @name iscDialChartD3Service#addIconClassAttrAndStatusCssToShipmentArray
	 * @description Method adds correct icon for shipment status and status css class based on which the shipment status color is displayed for all shipments.
	 * 
	 * @param {array} shipmentArray Array of shipment objects.
	 * @param {string} fulfillmentMethod fulfillment method: either bopus or sfs.
	 * @param {string} view the current selected view: either sla or orderstatus.
	 * @param {string} selectedStatus currently selected status tab on the UI. Out of the box it may correspond to one among: lowPriority, dueSoon, overdue, complete, inProgress or notStarted.
	 *
	 * @returns {array} Returns updated shipment array.
	 */
	iscDialChartD3Service.addIconClassAttrAndStatusCssToShipmentArray = function(shipmentArray, fulfillmentMethod, view, selectedStatus) {
		for (var i = 0; i < shipmentArray.length; i++) {
			var aShipment = shipmentArray[i];
			aShipment["iconClass"] = _getIconClassForAShipment(aShipment, fulfillmentMethod, view, selectedStatus);
			aShipment["Status"]["statusCss"] = _getStatusCss(aShipment, fulfillmentMethod, view, selectedStatus);
		}
		return shipmentArray;
	};
	
	/**
	 * @ngdoc method
	 * @name iscDialChartD3Service#getLegendJsonConfigArray
	 * @description Method returns json config with status name, class and numbers to be used for creating legend.
	 * 
	 * @param {string} fulfillmentMethod fulfillment method: either bopus or sfs.
	 * @param {string} viewName the current selected view: either sla or orderstatus.
	 * @param {array} valuesArray array of values corresponding to each category. This is optional and if not passed, defaulted to 0.
	 *
	 * @returns {object} json config with status name, class and numbers to be used for creating legend.
	 */
	iscDialChartD3Service.getLegendJsonConfigArray = function(fulfillmentMethod, viewName, valuesArray) {
		var fulfillmentMethod_code = fulfillmentMethod;
		var viewName_code = viewName;
		var mgrDashboardConfig = iscDialChartD3Pvdr.getManagerDashboardConfig();
		if (fulfillmentMethod_code === "bopus") {
			fulfillmentMethod_code = "pickupInStore";
		} else {
			fulfillmentMethod_code = "shipFromStore";
		}
		if (viewName_code === "orderstatus") {
			viewName_code = "shipmentStatus";
		}
		
		var bopusOrSfsConfig = mgrDashboardConfig[fulfillmentMethod_code];
		var displayStatuses = bopusOrSfsConfig[viewName_code]["displayStatuses"];
		var legendJsonArray = [];
		for (var i = 0; i < displayStatuses.length; i++) {
			var aDisplayStatus = displayStatuses[i];
			var cssClass = aDisplayStatus["ui_chartConfig"]["cssClass"];
			var value = 0;
			if (viewName === "sla" && (cssClass == null || cssClass.trim() == "")) {
				cssClass = _getCssClassForSLA(aDisplayStatus, fulfillmentMethod);
			}
			var iconClass = _getIconClass(aDisplayStatus, fulfillmentMethod, cssClass);
			if (valuesArray != null && valuesArray[i] != null) {
				value = valuesArray[i];
			}
			legendJsonArray.push({
				"statusName": aDisplayStatus["statusName"],
				"cssClass": cssClass,
				"iconClass": iconClass,
				"label": iscI18n.translate(aDisplayStatus["ui_chartConfig"]["labelKey"]),
				"value": value
			});
		}
		return legendJsonArray;
	};
	
	/**
	 * @ngdoc method
	 * @name iscDialChartD3Service#updateIdToConfigAndScopeMap
	 * @description Method updates the new configuration json for the passed id.
	 * 
	 * @param {string} id Id of the chart whose configuration json needs to be updated.
	 * @param {object} config New json config to be updated for the given id.
	 */
	iscDialChartD3Service.updateIdToConfigAndScopeMap = function(id, config) {
		_idToConfigAndScopeMap[id] = config;
	};
	
	/**
	 * @ngdoc method
	 * @name iscDialChartD3Service#getConfigAndScopeFromMap
	 * @description Method returns the config json for the passed id.
	 * 
	 * @param {string} id Id of the chart whose configuration json needs to be fetched.
	 *
	 * @returns {object} config json for the passed id.
	 */
	iscDialChartD3Service.getConfigAndScopeFromMap = function(id) {
		return _idToConfigAndScopeMap[id];
	};
	
	/**
	 * @ngdoc method
	 * @name iscDialChartD3Service#updateChartDataInConfigAndScopeMap
	 * @description Method updates the chartData in configJson for the passed id.
	 * 
	 * @param {string} id Id of the chart whose chartData needs to be updated.
	 * @param {object} chartData Json data for the chart.
	 */
	iscDialChartD3Service.updateChartDataInConfigAndScopeMap = function(id, chartData) {
		_idToConfigAndScopeMap[id]["configJson"]["chartData"] = chartData;
	};
	
	/**
	 * @ngdoc method
	 * @name iscDialChartD3Service#getBlankJsonDataWithPassedValue
	 * @description Method returns a json object with required configuration to create a blank/padding region on the dial chart.
	 * 
	 * @param {number} value The padding to be applied. It is a percentage number and must be passed without %.
	 *
	 * @returns {object} Returns json object with required configuration to create a blank/padding region on the dial chart.
	 */
	iscDialChartD3Service.getBlankJsonDataWithPassedValue = function(value) {
		var retBlankJson = {};
		angular.copy(_blankJson, retBlankJson);
		retBlankJson["value"] = value;
		return retBlankJson;
	};
	
	/**
	 * @ngdoc method
	 * @name iscDialChartD3Service#getNoChartDataConfig
	 * @description Method returns json object to be used in a chart when there is no data to display.
	 * 
	 * @returns {object} Returns json object to be used in a chart when there is no data to display.
	 */
	iscDialChartD3Service.getNoChartDataConfig = function() {
		return angular.copy(_noChartDataConfig);
	};
	
	/**
	 * @ngdoc method
	 * @name iscDialChartD3Service#getDialChartRegionsConfigFromMgrDbConfig
	 * @description Method returns an array of json objects with configuration attributes like status name, padding, css class etc. that are required to for the regions of dial chart.
	 * 
	 * @param {string} id Chart id based on which configuration will be obtained and converted.
	 *
	 * @returns {array} Returns array of json objects with required configuration to create dial chart regions.
	 */
	iscDialChartD3Service.getDialChartRegionsConfigFromMgrDbConfig = function(id) {
		var mgrDashboardConfig = iscDialChartD3Pvdr.getManagerDashboardConfig();
		
		if (mgrDashboardConfig == null) {
			return null;
		}
		
		var sfs_orderStatus_json = mgrDashboardConfig["shipFromStore"]["shipmentStatus"],
			sfs_sla_json = mgrDashboardConfig["shipFromStore"]["sla"],
			bopus_orderStatus_json = mgrDashboardConfig["pickupInStore"]["shipmentStatus"],
			bopus_sla_json = mgrDashboardConfig["pickupInStore"]["sla"],
			returnArray = [];
			
		if (id === sfs_orderStatus_json["ui_chartId"]) {
			returnArray = _convertConfigJsonToRegionArray(sfs_orderStatus_json, "sfs", false);
		} else if (id === sfs_sla_json["ui_chartId"]) {
			returnArray = _convertConfigJsonToRegionArray(sfs_sla_json, "sfs", true);
		} else if (id === bopus_orderStatus_json["ui_chartId"]) {
			returnArray = _convertConfigJsonToRegionArray(bopus_orderStatus_json, "bopus", false);
		} else if (id === bopus_sla_json["ui_chartId"]) {
			returnArray = _convertConfigJsonToRegionArray(bopus_sla_json, "bopus", true);
		}
		// because we need the ltr legend to align with the clockwise (rtl) chart.
		return returnArray.reverse();
	};
	
	/**
	 * @ngdoc method
	 * @name iscDialChartD3Service#correctDataForChartDisplay
	 * @description The chart has regions created clockwise while everything else is left to right. This needs the data to be reversed before it is displayed on chart. This method contains the logic to reverse the data.
	 * 
	 * @param {array} inputArray json array containing data to be displayed.
	 *
	 * @returns {array} Array of json objects reversed so that they can be displayed on the correct region on the chart.
	 */
	iscDialChartD3Service.correctDataForChartDisplay = function(inputArray) {
		var reverseArray = [];
		angular.copy(inputArray, reverseArray);
		reverseArray.reverse();
		return reverseArray;
	};
	
	return iscDialChartD3Service;
	
}]);
/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
 /**
 * @ngdoc service
 * @name iscItemVariationService
 * @requires $http
 * @requires $q
 * @requires iscAppInfo
 * @requires iscModal
 * @requires iscI18n
 * @requires $rootScope
 * @description  Handles all the common tasks to be performed on selection of a variation attribute. 
 * 
 */
angular.module('isc.shared').factory('iscItemVariation', ['$http','$q','iscAppInfo','iscModal','iscI18n','$rootScope',
 function($http,$q,iscAppInfo,iscModal,iscI18n,$rootScope) {
  
   var _allowedcombinationList = [];
   var _itemAttributeMap = [];
   var _validcombinationList = [];
   var _selectedCombination = [];
   var itemVariationService = {};
   var _variationList = {};
   /**
   *@ngdoc method
  * @name iscItemVariationService#Combination
   *@description Object used to store the combination of variation product.
   */
   itemVariationService.Combination = function(){
      return {
         attributeValuesMap :{}, 
         
         getAttributeValue : function(attributeId){
            return this.attributeValuesMap[attributeId];
         },
         
         setAttributeValue : function(atributeId, attributeValue){
            this.attributeValuesMap[atributeId] = attributeValue;
         },
         
         getAttributeValuesMap : function(){
            return this.attributeValuesMap;
         },

         setAttributeValuesMap: function(attrValuesMap){
            this.attributeValuesMap = attrValuesMap;
         },
         
         setItemID : function(itemID){
            this.itemID = itemID;
         },
         
         getItemID : function(){
            return this.itemID;
         },
         setAttributeCombination : function(allowedComb){
            var itemAttributeList = allowedComb.ItemAttributeList.ItemAttribute;
            for(var j=0; j<itemAttributeList.length; j++){
               var iAttribute = itemAttributeList[j];
               this.setAttributeValue(iAttribute.ItemAttributeName, iAttribute.DisplayAttributeValue);
               }
            }
         }
   };
   /**
   *@ngdoc method
   *@name iscItemVariationService#setVariationList
   *@description Stores the variation list of variation product.
   */
   itemVariationService.setVariationList = function(varList){
      this._variationList = varList;
   }
   /**
   *@ngdoc method
   *@name iscItemVariationService#getNewCombinationObj
   *@description Create a new combination object to store item attributes.
   *@return Object Combination object.
   */
   itemVariationService.getNewCombinationObj = function(){
      return this.Combination();
   };
   /**
   *@ngdoc method
   *@name iscItemVariationService#getAllowedCombinationList
   *@description Returns the allowed combination array of variation product.
   *@return Array Allowed combinations of a variation product.
   */
   itemVariationService.getAllowedCombinationList = function(){
      return this._allowedcombinationList;
   };
   /**
   *@ngdoc method
   *@name iscItemVariationService#populateAllowedCombinationList
   *@description Creates an array of combination object,sets properties by iterating through allowed combination list of variation product.
   *@return Array Allowed combinations of a variation product.
   */
   itemVariationService.populateAllowedCombinationList = function(variationList){
      var combinationList = [];
      if(!iscCore.isVoid(variationList.AllowedCombinationList)){
         var allowedCombArray = variationList.AllowedCombinationList.AllowedCombination;
         var len = allowedCombArray.length;
         for(var i = 0; i < len; i++){
               var newCombination = this.Combination();
               newCombination.setItemID(allowedCombArray[i].ItemID);
               newCombination.setAttributeCombination(allowedCombArray[i]);
               combinationList.push(newCombination);
         }
      }
      this._allowedcombinationList = combinationList;
   };
  /**
   *@ngdoc method
   *@name iscItemVariationService#getValidCombinationList
   *@description Creates an array of combination objects by comparing allowed combination with selected combination in view.
   *@return Array Allowed combination objects after comparing with selected attributes in view.
   */
   itemVariationService.getValidCombinationList = function(selectedComb){
       var selectedAttrValueMap = selectedComb.getAttributeValuesMap();
       var validCombinationList=[];
       var combinationList = this._allowedcombinationList; 
        for(var j=0; j<combinationList.length; j++){
          var combination = combinationList[j];
          exactMatchFound = this.compareObjects(selectedAttrValueMap,combination.getAttributeValuesMap());
         if(exactMatchFound){
               validCombinationList.push(combination);
         }
      }
      this._validCombinationList = validCombinationList;
      return validCombinationList;
   };
  /**
   *@ngdoc method
   *@name iscItemVariationService#populateItemAttrMap
   *@description Creates map of objects with key set to item attribute id and value set to all the assigned values of the attribute.
   */
   itemVariationService.populateItemAttrMap = function(variationList){
      this._itemAttributeMap = [];
      var length = variationList.AttributeList.Attribute.length;
      for(var i = 0; i < length; i++){
        var obj = {};
        var attribute = variationList.AttributeList.Attribute[i];
        var attrId = attribute.AttributeID;
        obj[attrId] = attribute.AssignedValueList.AssignedValue;
        this._itemAttributeMap.push(obj);
      }
   };
  /**
   *@ngdoc method
   *@name iscItemVariationService#getKeysLength
   *@description Iterates through the object properties and returns the length of the properties.
   *@param obj Object with key value
   *@return {Number} len no of properties present in object.
   */
   itemVariationService.getKeysLength = function(obj){
      var len = 0;
      for(key in obj){
        if(obj.hasOwnProperty(key)){
          len++;
        }
      }
       return len;
    };
  /**
   *@ngdoc method
   *@name iscItemVariationService#compareObjects
   *@description compares allowed combination object with selected combination(attributes selected in view), returns true
   * if properties present in selected combination are present in allowed combination,false otherwise.
   * Eg: selectedCombination{Size:M,Color:Red} and allowedCombination{Size:M,Color:Red,Brand:Levis}. Returns true,if
   * all properties in selected combination is present in allowed combination
   *@param obj1 Object with key value
   *@param obj2 
   *@return {Boolean} true, if all selected combination properties are present in allowed combination properties.
   */
   itemVariationService.compareObjects = function(obj1,obj2){
      if(!iscCore.isVoid(obj1) && 
        !iscCore.isVoid(obj2)){
        var index = 0;
        var matchFound = true;
        var keysLength = this.getKeysLength(obj1);
        while(matchFound && index < keysLength){
          for(var key in obj1){
            index++;
            matchFound = false;
            if(obj1[key] === obj2[key]){
              matchFound = true;
            }
            else{
              matchFound = false;
              break;
            }
          }
        }
        return matchFound;
      }
   };
 
 
  /**
   *@ngdoc method
   *@name iscItemVariationService#getVariantItemCombination
   *@description Returns the combination object having itemid same as id passed in argument.
   *@param {String} variantItemId Unique identifier of child item of variation product.
   *@return {Object} allowed combination object having item id same as value passed in args.
   */
   itemVariationService.getVariantItemCombination = function(variantItemId){
      var combination = null;
      if(!iscCore.isVoid(this._allowedcombinationList)){
        var length = this._allowedcombinationList.length;
        for(var i =0; i < length; i++){
            var combination = this._allowedcombinationList[i];
            if(variantItemId === combination.itemID){
              return combination;
            }
        }
      }
      return combination;
   };
  /**
   *@ngdoc method
   *@name iscItemVariationService#isVariantItemShown
   *@description Validates if product details shown is same as combination selected in view.
   *@param {String} VariantItemId Unique identifier of child item of variation product.
   *@param {Object} Combination object having attributes selected in view.
   *@return {Boolean} isVariantItemShown True, if item id of selected combination matches with item id shown in product details. 
   */
   itemVariationService.isVariantItemShown = function(variantItemId,selectedComb){
    var isVariantItemShown = false;
      if(!iscCore.isVoid(variantItemId)){
         var combination = this.getVariantItemCombination(variantItemId);
         if(angular.equals(combination.getAttributeValuesMap(),selectedComb.getAttributeValuesMap())){
            isVariantItemShown = true;
            return isVariantItemShown;
         }
      }
      return isVariantItemShown;
   };
  
  

   /**
   *@ngdoc method
   *@name iscItemVariationService#isValuePresentInAllowedArray
   *@description Returns true if value is present in allowed value array,false otherwise.
   *@param {String} value Display attribute value
   *@param {Array} arr Assigned value array that are available.
   */
   itemVariationService.isValuePresentInAllowedArray = function(value,arr){
    var isValuePresent = false;
      for(var i = 0; i < arr.length; i++){
        if(value === arr[i]){
            isValuePresent = true;
            return isValuePresent;
        }
      }
      return isValuePresent;
   };
  /**
   *@ngdoc method
   *@name iscItemVariationService#markSelectedForAttributes
   *@description Iterates through selected combination,sets attribute and value present in selected combination
   *object as selected by iterating through product's variation list.
   *@param {Object} Combination object having attributes selected in view.
   */
   itemVariationService.markSelectedForAttributes = function(selectedComb){
    var attrValuesMap = selectedComb.getAttributeValuesMap();
      for(var key in attrValuesMap){
        var length = this._variationList.AttributeList.Attribute.length;
        for(var i = 0; i < length; i++){
          var attribute = this._variationList.AttributeList.Attribute[i];
          var attrId = attribute.AttributeID;
          if(key === attribute.AttributeID){
            var assignedValueList = attribute.AssignedValueList.AssignedValue;
            for(var j =0; j < assignedValueList.length; j++){
              var assignedValue = assignedValueList[j];
              if(assignedValue.DisplayAttributeValue === attrValuesMap[key]){
                assignedValue.Selected = true;
				assignedValue.categorySelection = 'Selected';
              }
              else{
                assignedValue.Selected = false;
				assignedValue.categorySelection = 'Not selected';
              }
            }
          }
        }
      }
   };
 
   return itemVariationService;
 }]);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp.  2015, 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
/**
 * @ngdoc service
 * @name iscItem
 * @requires iscI18n
 * @requires $filter
 * @requires $rootScope
 * 
 * 
 * @description 
 * Handles all the common tasks related to Item/product. 
 * 
 */

angular.module('isc.shared').factory('iscItem', [
	'iscI18n',
	'$filter',
	'$rootScope',
	'iscWizard',
	'iscAppContext',
	function(iscI18n, $filter, $rootScope, iscWizard, iscAppContext) {
		
		var itemService = {};
   
		/**
		 * @ngdoc method
		 * @name iscItem#fetchAvailability
		 * @description Traverses through the output of getAlternateStoreAvailability api, fetches and forms the Item availability as per the UI requirement.
		 * 
		 * @param {object} obj getAlternateStoreAvailability(storeSelection_getAlternateStoreAvailability) mashup output model
		 * @return {Object} Model with the Item availability as per the UI requirement.
		 * 
		 */
		itemService.fetchAvailability = function(obj) {
			var obj = obj;
			for(var i=0;i < obj.Page.Output.AlternateStores.NodeList.Node.length;i++) {
				var node = obj.Page.Output.AlternateStores.NodeList.Node[i];
				node.DistanceWithUOM = iscI18n.translate('storeSearch.LABEL_Distance', {
					distance: $filter('number')(node.DistanceFromShipToAddress,1),
					uom: node.DistanceUOMDesc
				});
				
				var availability = node.Availability;
				if (availability) {
					if (availability.IsAvailable!="Y") {
						node.availInfo = "OUTOFSTOCK";
						node.Available = "false";
					} else {
						if (availability.IsFutureAvailability=="Y") {
							node.availInfo = "AVIALABLEBY";
							node.availDate = iscI18n.translate('storeSearch.LABEL_Available_By', {
								availdate: $filter('date')(availability.AvailableDate, 'fullDate')
							});
						} else {
							node.availInfo = "INSTOCK";
							node.availDate = iscI18n.translate('storeSearch.LABEL_today');
						}
					}
				} else {
					node.availInfo = "OUTOFSTOCK";
					node.Available = "false";
				}
				//console.log("node.availInfo" +node.availInfo);
			}
			return obj;
		};
		
		
		/**
		 * @ngdoc method
		 * @name iscItem#getResetAvailabilityObjAndDeliveryMethod
		 * @description Reset UI attributes used to display product availability information in the view.
		 */
		itemService.getResetAvailabilityObjAndDeliveryMethod = function() {
			return {
				"availability": {
					itemShpAvailableDate: "",
					itemShpAvailableText: "",
					itemShpAvailable: false,
					itemShpAvailableToday: false,
					
					//pick ui attributes
					itemPickAvailable: false,
					itemPickAvailableText: "",
					itemPickAvailableDate: "",

					//carry ui attributes.
					itemCarryAvailable: false,
					itemCarryAvailableDate: ""
				},
				"deliveryMethod": ""
			};
		};
		
		/**
		 * @ngdoc method
		 * @name iscItem#handleItemAvailability
		 * @description Sets the availability related UI attributes to display using data obtained from mashup output.
		 * 
		 * @param {Object} availabilities - Object having product availability information.
		 * @param {Object} selectedShipNode - Object having details about selected ship node.
		 * @param {String} isShippingAllowed - Indicates if shipping is allowed for the item.
		 * @param {String} isPickupAllowed - Indicates if pick-up is allowed for the item.
		 * @return {Object} Model with updated availability information.
		 * 
		 */
		itemService.handleItemAvailability = function(availabilities, selectedShipNode, isShippingAllowed, isPickupAllowed) {
			var resetAvailabilityObjAndDeliveryMethodObj = this.getResetAvailabilityObjAndDeliveryMethod(),
				availabilityFromModel = null;
			var isAvailabilityRealtimeData = availabilities.IsAvailabilityRealTimeData;
			if (availabilities.Availability instanceof Array) {
				// TODO: not very efficient. But code already exists and is verified.
				availabilityFromModel = _getAvailabilityInfoBasedOnDelMethod(availabilities, "CARRY");
				resetAvailabilityObjAndDeliveryMethodObj = _handleCarryAvailabilityInfo(availabilityFromModel, resetAvailabilityObjAndDeliveryMethodObj);
				
				availabilityFromModel = _getAvailabilityInfoBasedOnDelMethod(availabilities, "SHP");
				resetAvailabilityObjAndDeliveryMethodObj = _handleShpAvailabilityInfo(availabilityFromModel, resetAvailabilityObjAndDeliveryMethodObj, isShippingAllowed,isAvailabilityRealtimeData);
				
				availabilityFromModel = _getAvailabilityInfoBasedOnDelMethod(availabilities, "PICK");
				resetAvailabilityObjAndDeliveryMethodObj = _handlePickAvailabilityInfo(availabilityFromModel, resetAvailabilityObjAndDeliveryMethodObj, selectedShipNode, isPickupAllowed);
			} else {
				availabilityFromModel = availabilities.Availability;
				resetAvailabilityObjAndDeliveryMethodObj = _processAvailabilityInfo(availabilityFromModel, resetAvailabilityObjAndDeliveryMethodObj, selectedShipNode, isShippingAllowed, isPickupAllowed,isAvailabilityRealtimeData);
			}
			return resetAvailabilityObjAndDeliveryMethodObj;
		};

		var _getAvailabilityInfoBasedOnDelMethod = function(availabilities, deliveryMethod) {
			var availability = null;
			if (availabilities.Availability instanceof Array) {
				var availabilityArr = availabilities.Availability;
				for (var i = 0; i < availabilityArr.length; i++) {
					availability = availabilityArr[i];
					if (availability.DeliveryMethod === deliveryMethod || (deliveryMethod === "CARRY" && iscCore.isVoid(availability.DeliveryMethod))) {
						return availability;
					}
				}
			}
		};
		
		var _processAvailabilityInfo = function(availability, availAndDeliveryObj, selectedShipNode, isShippingAllowed, isPickupAllowed,isAvailabilityRealtimeData) {
			if (!iscCore.isVoid(availability)) {
				var deliveryMethod = availability.DeliveryMethod;
				if (!iscCore.isVoid(deliveryMethod)) {
					if (deliveryMethod === "CARRY") {
						availAndDeliveryObj = _handleCarryAvailabilityInfo(availability, availAndDeliveryObj);
					}
					if (deliveryMethod === "SHP") {
						availAndDeliveryObj = _handleShpAvailabilityInfo(availability, availAndDeliveryObj, isShippingAllowed,isAvailabilityRealtimeData);
					}
					if (deliveryMethod === "PICK") {
						availAndDeliveryObj = _handlePickAvailabilityInfo(availability, availAndDeliveryObj, selectedShipNode, isPickupAllowed);
					}
				}
			}
			return availAndDeliveryObj;
		};
		
		var _handleCarryAvailabilityInfo = function(availability, availAndDeliveryObj) {
			var hasAnyUnavailableQty = "",
				isAvailableToday = "";
			
			if (!iscCore.isVoid(availability)) {
				hasAnyUnavailableQty = availability.HasAnyUnavailableQty;
				isAvailableToday = availability.IsAvailableToday;
			}
			if (hasAnyUnavailableQty === "N") {
				// item available, set delivery method to carry.
				// if item available to carry from store,then set delivery method to carry.
				if (availAndDeliveryObj.deliveryMethod === "") {
					availAndDeliveryObj.deliveryMethod = "CARRY";
				}
				if (isAvailableToday === "Y") {
					// available today. (today at store desc)
					availAndDeliveryObj.availability.itemCarryAvailable = true;
					availAndDeliveryObj.availability.itemCarryAvailableDate = iscI18n.translate("globals.LABEL_ItemAvailableTodayAtStore", {
						"date": $filter("date")(availability.ProductAvailDate, "mediumDate"),
						"shipNodeDesc": availability.ShipNodeDescription
					});
					if (!iscCore.isVoid(availability.AvailableQuantity)) {
						availAndDeliveryObj.availability.itemAvailableQty =availability.AvailableQuantity;
					}
				}
			} else {
				availAndDeliveryObj.availability.itemCarryAvailable = false;
				availAndDeliveryObj.availability.itemCarryAvailableDate = "";
			}
			return availAndDeliveryObj;
		};
		
		var _handleShpAvailabilityInfo = function(availability, availAndDeliveryObj, isShippingAllowed,isAvailabilityRealtimeData) {
			var hasAnyUnavailableQty = "",
				earliestShpDate = "";
				
			if (!iscCore.isVoid(availability)) {
				hasAnyUnavailableQty = availability.HasAnyUnavailableQty;
				earliestShpDate = availability.EarliestShipDate;
			}
			if (hasAnyUnavailableQty === "N") {
				// item available.
				if (isShippingAllowed === "Y" && availAndDeliveryObj.deliveryMethod === "") {
					availAndDeliveryObj.deliveryMethod = "SHP";
				}
				
				if(isAvailabilityRealtimeData === 'Y'){
                    
					availAndDeliveryObj.availability.itemShpAvailableText = earliestShpDate;
					availAndDeliveryObj.availability.itemShpAvailableDate = earliestShpDate;
					
                }else if (isAvailabilityRealtimeData === 'N'){
                	availAndDeliveryObj.availability.itemShpAvailableText = availability.ProductAvailDate;
                	availAndDeliveryObj.availability.itemShpAvailableDate = availability.ProductAvailDate;
                	
                } 
				
				/*availAndDeliveryObj.availability.itemShpAvailableText = earliestShpDate;
				availAndDeliveryObj.availability.itemShpAvailableDate = earliestShpDate;*/
				
				availAndDeliveryObj.availability.itemShpAvailable = true;
				if (availability.IsAvailableToday === "Y") {
					// item available today. show within 24hrs.
					availAndDeliveryObj.availability.itemShpAvailableToday = true;
				}
			} else {
				availAndDeliveryObj.availability.itemShpAvailable = false;
				availAndDeliveryObj.availability.itemShpAvailableText = "";
			}
			return availAndDeliveryObj;
		};

		var _handlePickAvailabilityInfo = function(availability, availAndDeliveryObj, selectedShipNode, isPickupAllowed) {
			// This method can add "selectedShipNode" to "availAndDeliveryObj".
			var hasAnyUnavailableQty = "",
				isAvailableToday = "",
				distance = "",
				sameStore = false;
				
			if (!iscCore.isVoid(availability)) {
				hasAnyUnavailableQty = availability.HasAnyUnavailableQty;
				isAvailableToday = availability.IsAvailableToday;
			}
			
			if (hasAnyUnavailableQty === "N") {
				// item available.
				if (!iscCore.isVoid(availability.ShipNode)) {
					if (iscAppContext.getFromContext("storeName") === availability.ShipNode) {
						// item available in same store. stamp ship node,else force user to select store.
						selectedShipNode.shipNode = availability.ShipNode;
						selectedShipNode.shipNodeDesc = availability.ShipNodeDescription;
						sameStore = true;
						availAndDeliveryObj.selectedShipNode = selectedShipNode;
					}
				}

				if (isPickupAllowed === "Y" && availAndDeliveryObj.deliveryMethod === "") {
					availAndDeliveryObj.deliveryMethod = "PICK";
				}
				availAndDeliveryObj.availability.itemPickAvailable = true;
				availAndDeliveryObj.availability.itemPickAvailableDate = availability.ProductAvailDate;
				if (isAvailableToday === "Y") {
					if (sameStore) {
						//available today,same store (today,date at ship node desc)
						availAndDeliveryObj.availability.itemPickAvailableText = iscI18n.translate("globals.LABEL_ItemAvailableTodayAtStore", {
							"date": $filter("date")(availability.ProductAvailDate, "mediumDate"),
							"shipNodeDesc": selectedShipNode.shipNodeDesc
						});
					} else {
						// available today,diff store (today,date within 25 miles)
						availAndDeliveryObj.availability.itemPickAvailableText = iscI18n.translate("addItems.LABEL_ItemPickAvailableTodayDiffStore", {
							"date": $filter("date")(availability.ProductAvailDate, "mediumDate"),
							"distance": $filter("number")(availability.Distance, 2),
							"distanceUOM": availability.DistanceUOMDesc
						});
					}
				} else {
					if (sameStore) {
						// available in future (future date at ship node desc)
						availAndDeliveryObj.availability.itemPickAvailableText = iscI18n.translate("addItems.LABEL_ItemPickAvailableNotTodaySameStore", {
							"date": $filter("date")(availability.ProductAvailDate, "fullDate"), 
							"shipNodeDesc": selectedShipNode.shipNodeDesc
						});
					} else {
						// available in future (future date within distance.)
						availAndDeliveryObj.availability.itemPickAvailableText = iscI18n.translate("addItems.LABEL_ItemPickAvailableNotTodayDiffStore", {
							"date": $filter("date")(availability.ProductAvailDate, "fullDate"), 
							"distance": $filter("number")(availability.Distance, 2),
							"distanceUOM": availability.DistanceUOMDesc
						});
					}
				}
			} else {
				availAndDeliveryObj.availability.itemPickAvailable = false;
				availAndDeliveryObj.availability.itemPickAvailableText = "";
				availAndDeliveryObj.availability.itemPickAvailableDate = "";
			}
			return availAndDeliveryObj;
		};
		
		return itemService;
	}
]);
/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp. 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/

/**
 * @ngdoc service 
 * @name iscManagerDashboardService
 * @requires iscDialChartD3Pvdr
 * @requires iscI18n
 * 
 * @description 
 * This service is used to carry out some common tasks related to manager dashboard.
 */
 
angular.module('isc.shared').factory('iscManagerDashboardService', ['iscDialChartD3Pvdr', 'iscI18n', function(iscDialChartD3Pvdr, iscI18n) {
	var iscManagerDashboardService = {};
	
	var CONST_SLA_Code_SFS = "YCD_TIME_RMN_SFS";
	var CONST_SLA_Code_BOPUS = "YCD_TIME_RMN_THRSH";
	
	var _commonCodeListData = null;
	var _bopusActiveChart = null;
	var _sfsActiveChart = null;
	
	/**
	 * @ngdoc method
	 * @name iscManagerDashboardService#setCommonCodeListData
	 * @description Method converts the commonCodeData from API into data commonCodeData for bopus and sfs.
	 * 
	 * @param {object} commonCodeData json data containing common code data obtained from common code API.
	 */
	iscManagerDashboardService.setCommonCodeListData = function(commonCodeData) {
		_commonCodeListData = {
			"bopus": [],
			"sfs": []
		};
		if (commonCodeData != null && commonCodeData.CommonCodeList != null && commonCodeData.CommonCodeList.CommonCode != null) {
			for (var i = 0; i < commonCodeData.CommonCodeList.CommonCode.length; i++) {
				var aCommonCode = commonCodeData.CommonCodeList.CommonCode[i];
				if (aCommonCode["CodeType"] === CONST_SLA_Code_BOPUS) {
					_commonCodeListData["bopus"].push(aCommonCode);
				} else if (aCommonCode["CodeType"] === CONST_SLA_Code_SFS) {
					_commonCodeListData["sfs"].push(aCommonCode);
				}
			}
		}
	};
	
	/**
	 * @ngdoc method
	 * @name iscManagerDashboardService#validateCommonCodeListDataForFulfillmentMethod
	 * @description Method validates if all the SLA configurations defined for a fulfillmentMethod in manager dashboard configuration are defined for the current organization as common codes. The non localized short descriptions for common codes are matched.
	 * 
	 * @param {string} fulfillmentMethod fulfillment method: either bopus or sfs.
	 *
	 * @returns {boolean} Returns true to indicate that the configuration is correct. In case if it returns false, the SLA charts and Shipment List screens can not display data due to invliad configuration.
	 */
	iscManagerDashboardService.validateCommonCodeListDataForFulfillmentMethod = function(fulfillmentMethod) {
		var mgrDashboardConfig = iscDialChartD3Pvdr.getManagerDashboardConfig(),
			fulfillmentMethod_code = fulfillmentMethod,
			bopusOrSfsConfig_sla = null,
			fulfillmentMethodSlaArray = [],
			commonCodeListSlaArray = [],
			displayStatusArray = [],
			isValidConfig = true;
			
		if (fulfillmentMethod_code === "bopus") {
			fulfillmentMethod_code = "pickupInStore";
		} else {
			fulfillmentMethod_code = "shipFromStore";
		}
		
		bopusOrSfsConfig_sla = mgrDashboardConfig[fulfillmentMethod_code]["sla"];
		if (bopusOrSfsConfig_sla != null) {
			displayStatusArray = bopusOrSfsConfig_sla["displayStatuses"];
		}
		for (var i = 0; i < displayStatusArray.length; i++) {
			var aDisplayStatus = displayStatusArray[i];
			var combinedStatusArray = aDisplayStatus["combinedStatusArray"];
			fulfillmentMethodSlaArray = fulfillmentMethodSlaArray.concat(combinedStatusArray);
		}
		if (_commonCodeListData != null && _commonCodeListData[fulfillmentMethod] != null) {
			for (var i = 0; i < _commonCodeListData[fulfillmentMethod].length; i++) {
				commonCodeListSlaArray.push(_commonCodeListData[fulfillmentMethod][i]["NonLocalizedCodeShortDescription"]);
			}
		}
		// validate that each entry in fulfillmentMethodSlaArray is present in commonCodeListSlaArray.
		for (var i = 0; i < fulfillmentMethodSlaArray.length; i++) {
			var anEntry = fulfillmentMethodSlaArray[i];
			var exists = false;
			for (var j = 0; j < commonCodeListSlaArray.length; j++) {
				if (anEntry === commonCodeListSlaArray[j]) {
					exists = true;
					break;
				}
			}
			if (!exists) {
				isValidConfig = false;
				break;
			}
		}
		return isValidConfig;
	};
	
	iscManagerDashboardService.getCommonCodeListData = function() {
		return _commonCodeListData;
	};
	
	iscManagerDashboardService.bopus_setActiveChart = function(activeChart) {
		_bopusActiveChart = activeChart;
	};
	
	iscManagerDashboardService.bopus_getActiveChart = function() {
		return _bopusActiveChart;
	};
	
	iscManagerDashboardService.sfs_setActiveChart = function(activeChart) {
		_sfsActiveChart = activeChart;
	};
	
	iscManagerDashboardService.sfs_getActiveChart = function() {
		return _sfsActiveChart;
	};
	
	/**
	 * @ngdoc method
	 * @name iscManagerDashboardService#getInputJson
	 * @description Method returns the inputJson required to get the total number of shipments for required fulfillment method and view.
	 * 
	 * @param {object} slaConfigJson json object corresponding to SLA for the current fulfillment method defined in manager dashboard json config.
	 * @param {object} orderStatusConfigJson json object corresponding to orderstatus for the current fulfillment method defined in manager dashboard json config.
	 * @param {string} fulfillmentMethod fulfillment method: either bopus or sfs.
	 * @param {string} view the current selected view: either sla or orderstatus.
	 *
	 * @returns {object} Returns inputJson required to get the total number of shipments for required fulfillment method and view.
	 */
	iscManagerDashboardService.getInputJson = function(slaConfigJson, orderStatusConfigJson, fulfillmentMethod, view) {
		var input = {
			"Shipment": {}
		};
		if (view === "sla") {
			input["Shipment"]["SLA"] = {
				"DisplayStatusList": {
					"DisplayStatus": []
				}
			};
			for (var i = 0; i < slaConfigJson.displayStatuses.length; i++) {
				input["Shipment"]["SLA"]["DisplayStatusList"]["DisplayStatus"].push({
					"StatusName": slaConfigJson.displayStatuses[i]["statusName"],
					"Statuses": iscManagerDashboardService.getStringOfAllActualOrderStatusesExceptExcludedInSla(orderStatusConfigJson, slaConfigJson),
					"StatusCombineQryType": "OR",
					"ThresholdTime": _getThresholdFor(slaConfigJson.displayStatuses[i]["combinedStatusArray"], fulfillmentMethod)
				});
			}
		} else {
			input["Shipment"]["OrderStatus"] = {
				"DisplayStatusList": {
					"DisplayStatus": []
				}
			};
			for (var i = 0; i < orderStatusConfigJson.displayStatuses.length; i++) {
				input["Shipment"]["OrderStatus"]["DisplayStatusList"]["DisplayStatus"].push({
					"StatusName": orderStatusConfigJson.displayStatuses[i]["statusName"],
					"Statuses": orderStatusConfigJson.displayStatuses[i]["combinedStatusArray"].join(","),
					"StatusCombineQryType": "OR"
				});
			}
		}
		return input;
	};
	
	iscManagerDashboardService.getStringOfAllActualOrderStatusesExceptExcludedInSla = function(orderStatusConfigJson, slaConfigJson) {
		var statusToExclude = slaConfigJson["shipmentStatusToExclude"];
		var statusStrArr = [];
		for (var i = 0; i < orderStatusConfigJson.displayStatuses.length; i++) {
			var aStatus = orderStatusConfigJson.displayStatuses[i];
			if (aStatus["statusName"] !== statusToExclude) {
				var statusArr = orderStatusConfigJson.displayStatuses[i]["combinedStatusArray"];
				statusStrArr = statusStrArr.concat(statusArr);
			}
		}
		return statusStrArr.join(",");
	};
	
	var _getThresholdFor = function(passedStatusArray, fulfillmentMethod) {
		// Choose the bigger value.
		var commonCodeArr = _commonCodeListData[fulfillmentMethod];
		var thresholdValuesArray = [];
		for (var i = 0; i < passedStatusArray.length; i++) {
			var aPassedStatus = passedStatusArray[i];
			for (var j = 0; j < commonCodeArr.length; j++) {
				var aCommonCode = commonCodeArr[j];
				if (aPassedStatus === aCommonCode["NonLocalizedCodeShortDescription"]) {
					thresholdValuesArray.push(+(aCommonCode["CodeValue"]));
					break;
				}
			}
		}
		thresholdValuesArray = thresholdValuesArray.sort(function(a, b) {
			return a - b;
		});
		return thresholdValuesArray.pop();
	};
	
	iscManagerDashboardService.getThresholdTimeLimitForStatus = function(displayStatusArray, fulfillmentMethod, statusName) {
		var limitString = "";
		var statusAndThresholdArr = [];
		for (var i = 0; i < displayStatusArray.length; i++) {
			var aDisplayStatus = displayStatusArray[i];
			var displayStatusName = aDisplayStatus["statusName"];
			statusAndThresholdArr.push({
				"statusName": displayStatusName,
				"time": _getThresholdFor(aDisplayStatus["combinedStatusArray"], fulfillmentMethod)
			});
		}
		statusAndThresholdArr = statusAndThresholdArr.sort(function(a, b) {
			return a["time"] - b["time"];
		});
		
		for (var i = 0; i < statusAndThresholdArr.length; i++) {
			if (statusAndThresholdArr[i]["statusName"] === statusName) {
				if (i === 0) {
					limitString = statusAndThresholdArr[i]["time"] + "";
				} else {
					limitString = statusAndThresholdArr[i - 1]["time"] + "";
					limitString = limitString + "," + statusAndThresholdArr[i]["time"];
				}
				break;
			}
		}
		return limitString;
	};
	
	iscManagerDashboardService.getCommonCodeListDataAccordingToStatuses = function(displayStatusArray, fulfillmentMethod) {
		var limitString = "";
		var commonCodeListDataToSend = [];
		var commonCodeArr = _commonCodeListData[fulfillmentMethod];
		for (var i = 0; i < displayStatusArray.length; i++) {
			var aDisplayStatus = displayStatusArray[i];
			var statusUIDefault = aDisplayStatus["statusUIDefaults"];
			var timeLimit = _getThresholdFor(aDisplayStatus["combinedStatusArray"], fulfillmentMethod);
			var combinedStatusArray = aDisplayStatus["combinedStatusArray"];
			for (var j = 0; j < commonCodeArr.length; j++) {
				if (commonCodeArr[j]["NonLocalizedCodeShortDescription"] === statusUIDefault) {
					var copiedCode = {};
					angular.copy(commonCodeArr[j], copiedCode);
					copiedCode["CodeValue"] = "" + timeLimit;
					commonCodeListDataToSend.push(copiedCode);
					break;
				}
			}
		}
		return commonCodeListDataToSend;
	};
	
	/**
	 * @ngdoc method
	 * @name iscManagerDashboardService#getDataFromModel
	 * @description Method returns json data containing the count of shipments for all the configured SLA and orderstatus categories defined in manager dashboard config json.
	 * 
	 * @param {object} slaModelData json object containing the data to be displayed for all the configured SLA categories in manager dashboard for required fulfillment method.
	 * @param {object} orderStatusmodelData json object containing the data to be displayed for all the configured orderstatus categories in manager dashboard for required fulfillment method.
	 * @param {string} fulfillmentMethod fulfillment method: either bopus or sfs.
	 * @param {string} requiredView the current selected view: either sla or orderstatus. If not passed, it is assumed data for both is required.
	 *
	 * @returns {object} Returns json data containing the count of shipments for all the configured SLA and orderstatus categories defined in manager dashboard config json.
	 */
	iscManagerDashboardService.getDataFromModel = function(slaModelData, orderStatusmodelData, fulfillmentMethod, requiredView) {
		var slaModelList = null,
			orderStatusModelList = null,
			sla_DataArray = null,
			orderstatus_DataArray = null;
		var mgrDashboardConfig = iscDialChartD3Pvdr.getManagerDashboardConfig(),
			fulfillmentMethod_code = fulfillmentMethod,
			bopusOrSfsConfig = null,
			displayStatuses_config = [];
			
		if (fulfillmentMethod_code === "bopus") {
			fulfillmentMethod_code = "pickupInStore";
		} else {
			fulfillmentMethod_code = "shipFromStore";
		}
		bopusOrSfsConfig = mgrDashboardConfig[fulfillmentMethod_code];
		
		if ((requiredView === "sla" || !requiredView) && slaModelData != null && slaModelData.Shipment != null) {
			slaModelList = slaModelData.Shipment.SLA.DisplayStatusList.DisplayStatus;
			displayStatuses_config = bopusOrSfsConfig["sla"]["displayStatuses"];
			sla_DataArray = [];
			for (var j = 0; j < displayStatuses_config.length; j++) {
				var statusName_config = displayStatuses_config[j]["statusName"];
				for (var i = 0; i < slaModelList.length; i++) {
					var statusName_modelData = slaModelList[i]["StatusName"];
					if (statusName_modelData.toLowerCase() === statusName_config.toLowerCase()) {
						sla_DataArray.push(+slaModelList[i]["Count"]);
						break;
					}
				}
			}
		}
		
		if (requiredView === "orderstatus" || !requiredView) {
			orderStatusModelList = orderStatusmodelData.Shipment.OrderStatus.DisplayStatusList.DisplayStatus;
			displayStatuses_config = bopusOrSfsConfig["shipmentStatus"]["displayStatuses"];
			orderstatus_DataArray = [];
			for (var j = 0; j < displayStatuses_config.length; j++) {
				var statusName_config = displayStatuses_config[j]["statusName"];
				for (var i = 0; i < orderStatusModelList.length; i++) {
					var statusName_modelData = orderStatusModelList[i]["StatusName"];
					if (statusName_modelData.toLowerCase() === statusName_config.toLowerCase()) {
						orderstatus_DataArray.push(+orderStatusModelList[i]["Count"]);
						break;
					}
				}
			}
		}
		return {
			"sla": sla_DataArray,
			"orderstatus": orderstatus_DataArray
		};
	};
	
	iscManagerDashboardService.getFirstDisplayStatusInArray = function(fulfillmentMethod, viewName) {
		var fulfillmentMethod_code = fulfillmentMethod;
		var viewName_code = viewName;
		var mgrDashboardConfig = iscDialChartD3Pvdr.getManagerDashboardConfig();
		if (fulfillmentMethod_code === "bopus") {
			fulfillmentMethod_code = "pickupInStore";
		} else {
			fulfillmentMethod_code = "shipFromStore";
		}
		if (viewName_code === "orderstatus") {
			viewName_code = "shipmentStatus";
		}
		
		var bopusOrSfsConfig = mgrDashboardConfig[fulfillmentMethod_code];
		var displayStatuses = bopusOrSfsConfig[viewName_code]["displayStatuses"];
		
		return displayStatuses[0]["statusName"];
	};
	
	return iscManagerDashboardService;
}]);
/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp.  2015, 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/

/**
 * @ngdoc service 
 * @name iscMashup
 * @requires $http
 * @requires $q
 * @requires iscAppInfo
 * @requires iscModal
 * @requires iscI18n
 * @requires $rootScope
 * @requires iscMashupCache
 * 
 * @description 
 * Calls mashups based upon the mashup input passed. Handles the mashup output and sets model on control object
 * 
 */






angular.module('isc.shared').factory('iscMashup', ['$http','$q','iscAppInfo','iscModal','iscI18n','$rootScope','iscMashupCache', 'iscHttpRequest', function($http,$q,iscAppInfo,iscModal,iscI18n,$rootScope,iscMashupCache,iscHttpRequest) {
	
	var _mashupControllerUrl = iscAppInfo.getApplicationContext()+iscAppInfo.getMashupControllerUrl();
	var mashupService = {};
		
	_getMashupObject = function(control,mashupRefId ){
		var mashup;
		for(var i=0;i<control.mashupRefs.length;i++){
			if(control.mashupRefs[i].mashupRefId===mashupRefId){
				mashup = control.mashupRefs[i];
				break;				
			}
		}
		return mashup;
	};
	
	_getPageModel = function(control,modelName){
		if(!control.pageModel){
			control.pageModel = {};
		}
		if(!control.pageModel[modelName]){
			control.pageModel[modelName] = {};
			control.pageModel[modelName]["0"] = {};						
		}
		return control.pageModel[modelName];
	};
	/**
	 * @ngdoc method
	 * @name iscMashup#getMashupOutput
	 * @description Returns the mashup output for the speficed mashupRefId
	 * 
	 * @param {object} controllerOutput Mashup contoller output
	 * @param {string} mashupRefId Mashup ref id of the mashup
	 * @returns {object} Returns mashup output for the speficed mashupRefId if found in the controllerOutput 
	 */
	mashupService.getMashupOutput = function(controllerOutput,mashupRefId){
		var output;
		for(var i=0;i<controllerOutput.MashupRefs.MashupRef.length;i++){
			if(controllerOutput.MashupRefs.MashupRef[i].mashupRefId===mashupRefId){
				output = controllerOutput.MashupRefs.MashupRef[i].Output;
				break;
			}
			
		}
		return output;
	};
	
	mashupService.getSimpleMashupOutput = function(response,requiredMashupId){
		var output = "";
   	 var mashupRefs = response.MashupRefs.MashupRef;
		 for(var i=0;mashupRefs[i];i++){
			 if(mashupRefs[i].mashupId){
				  var mashupId = mashupRefs[i].mashupId;
					if(mashupId == requiredMashupId){
					   output =	mashupRefs[i].Output;
					   break;
				   }
			  }
		  }
			  
		return output;
	};
	/**
	 * @ngdoc method
	 * @name iscMashup#getMashupRefObj
	 * @description Returns the mashupRefObj to be passed as an argument to callMashups 
	 * 
	 * @param {object} control View controller object instance
	 * @param {string} mashupRefId Mashup ref id of the mashup to be called
	 * @param {object} mashupInput Mashup input
	 */
	mashupService.getMashupRefObj = function(control,mashupRefId,mashupInput){
		var mashup = _getMashupObject(control,mashupRefId);	
		var mashupRefObj;
		if(mashup){
			mashupRefObj = 
					{
						"mashupId":mashup.mashupId,
						"mashupRefId":mashupRefId,
						"Input":mashupInput,
						"cached":mashup.cached
					};
			if(mashup.isPaginated){
				mashupRefObj.isPaginated = "true";
				mashupRefObj.scPageSize = (mashup.pageSize)?""+mashup.pageSize:"5";
				mashupRefObj.scPageNumber = "1";
				mashupRefObj.scPaginationStrategy = "NEXTPAGE";
				mashupRefObj.scPreviousPageRecord = {};			
			}
		}
		return mashupRefObj;	
	};
	
	/**
	 * @ngdoc method
	 * @name iscMashup#callMashups
	 * @description Calls multiple mashups at a time and returns a promise object
	 * 
	 * @param {object} control View controller object instance
	 * @param {array} mashupRefObjList List of the mashup ref obj
	 * @param {object} options Additional options that can be passed for the mashup call. For example: isMultiAPICall flag
	 * 
	 * @returns Returns a promise object
	 */
	mashupService.callMashups = function(control,mashupRefObjList,options){
		var deferred = $q.defer();
		if(mashupRefObjList && mashupRefObjList.length>0){
			var mashupRefObjListLength = mashupRefObjList.length;
			var cachedMashupOutputArray = mashupService._getMashupCacheOutput(mashupRefObjList,options);
			if(cachedMashupOutputArray.length == 0) {			
				mashupService._callMashupsAction(mashupRefObjList,options).then(function(response){
					mashupService._handleMashupOutput(control,response,options,deferred);				
				});
			} 
			else if(mashupRefObjListLength == cachedMashupOutputArray.length) {
				var response = mashupService._createMashupCacheResponseObject();
				for(var i=0; i<cachedMashupOutputArray.length; i++) {
					response.data.controllerData.MashupRefs.MashupRef.push(cachedMashupOutputArray[i]);
				}
				mashupService._handleMashupOutput(control,response,options,deferred);
			} else {
				if(!options) options = {};
				options.cachedMashupOutputArray = cachedMashupOutputArray;
				mashupService._callMashupsAction(mashupRefObjList,options).then(function(response){
					mashupService._handleMashupOutput(control,response,options,deferred);				
				});
			}
		}
		else{
			console.debug("Invalid mashupRefObjList");
		}
		return deferred.promise;
	};
	
	/**
	 * @ngdoc method
	 * @name callSimpleMashup
	 * @description makes a simple ajax call to get api response.
	 * @param {scope} scope
	 * @param {mashupId} mashup id to be called
	 * @param {mashupInput} api input
	 * @param {callBackHandler} success handler
	 * @param {errorHandler} failure handler
	 */
	
	mashupService.callSimpleMashup = function(scope, mashupId, mashupInput, options) {
		var mashupRefList = [];
		var deferred = $q.defer();
		mashupRefList[0] = 
			{
				"mashupId":mashupId,
				"Input":mashupInput
			};
		if(options && options.cached) mashupRefList[0].cached = options.cached;
		
		var cachedMashupOutputArray = mashupService._getMashupCacheOutput(mashupRefList,options);
		
		if(mashupRefList.length > 0) {
			mashupService._callMashupsAction(mashupRefList,options).then(function(response){
				mashupService._handleSimpleMashupOutput(scope,response,options,deferred);
			});
		} else {
			var response = mashupService._createMashupCacheResponseObject();
			response.data.controllerData.MashupRefs.MashupRef.push(cachedMashupOutputArray[0]);
			mashupService._handleSimpleMashupOutput(scope,response,options,deferred);
		}
		
		return deferred.promise;
	}; 
	
	/**
	 * @ngdoc method
	 * @name callSimplePaginatedMashup
	 * @description makes a paginated ajax call to get api response. To be used only in directives. Views must use callPaginatedMashup().
	 * @param {scope} scope
	 * @param {mashupId} mashup id to be called
	 * @param {mashupInput} api input
	 * @param {paginationDataObj} object with pagination related attributes
	 * @param {pageAction} action to be taken. "START", "NEXT" or "PREVIOUS"
	 * @param {object} options Options to be passed while calling mashup
	 * 
	 * @returns {object} Returns a mashup promise object
	 */
	
	mashupService.callSimplePaginatedMashup = function(scope, mashupId, mashupInput, paginationDataObj, pageAction, options) {
        // TODO: This is becoming a repeat of the normal paginated mashup method below except a few things. Ideally, re-factor them into one.
        var deferred = $q.defer();
        if (paginationDataObj == null) {
            paginationDataObj = {
				"isPaginated": "true",
                "scPageSize": "5",
                "scPageNumber": "1",
                "scPaginationStrategy": "NEXTPAGE",
                "scPreviousPageRecord": {}
            };
        }
        var mashupRefList = [{
            "mashupId": mashupId,
            "Input": mashupInput,
            "scPageSize": paginationDataObj.scPageSize,
            "scPageNumber": paginationDataObj.scPageNumber,
            "scPaginationStrategy": paginationDataObj.scPaginationStrategy,
            "scPreviousPageRecord": paginationDataObj.scPreviousPageRecord
        }];

        var pageModel = _getPageModel(scope, mashupId),
            currentPageNumber = pageModel.currentPageNumber ? pageModel.currentPageNumber : 1,
            scPageNumber = 1;
        if (pageAction === "START") {                                
            scPageNumber = 1;
            pageModel = {};
            pageModel["0"] = {};
        } else if (pageAction === "NEXT") {                        
            scPageNumber = parseInt(currentPageNumber) + 1;
        } else if (pageAction === "PREVIOUS") {
            scPageNumber = parseInt(currentPageNumber) - 1;                
        }
        // commenting below code as scPageNumber and scPreviousPageRecord is already sent in paginationDataObj.
        //mashupRefList[0].scPageNumber = "" + scPageNumber;
        //mashupRefList[0].scPreviousPageRecord = pageModel["" + (scPageNumber - 1)];
        mashupService._callMashupsAction(mashupRefList,options).then(function(response) {
            //scope[callBackHandler](response.data.controllerData);
            mashupService._handleSimpleMashupOutput(scope,response,options,deferred);
        });
        return deferred.promise;
    };
	
	
	/**
	 * @ngdoc method
	 * @name iscMashup#callPaginatedMashup
	 * @description Calls a paginated mashup
	 * 
	 * @param {object} control View controller object instance
	 * @param {string} mashupRefId Mashup ref id of the mashup to be called
	 * @param {object} inputData Mashup input
	 * @param {string} pageAction Pagination action. It could be START|NEXT|PREVIOUS
	 * @param {object} options Options to be passed while calling mashup
	 */
	mashupService.callPaginatedMashup = function(control, mashupRefId, inputData,pageAction, options ){
		var mashup = _getMashupObject(control,mashupRefId);
		var deferred = $q.defer();
		if(mashup){
			var mashupRefList = [];
			mashupRefList[0] = mashupService.getMashupRefObj(control, mashupRefId, inputData);
			var pageModel = _getPageModel(control,mashup.mashupRefId);
			var currentPageNumber = pageModel.currentPageNumber?pageModel.currentPageNumber:1;
			var scPageNumber = 1;
			if(pageAction==="START"){								
				scPageNumber = 1;
				pageModel = {};
				pageModel["0"]={};
				if(control.model[mashupRefList[0].modelName]){
				  control.model[mashupRefList[0].modelName] = {};
				}
			}
			else if(pageAction==="NEXT"){						
				scPageNumber = parseInt(currentPageNumber) + 1;
			}
			else if(pageAction==="PREVIOUS"){
				scPageNumber = parseInt(currentPageNumber) - 1;				
			}
			
			mashupRefList[0].scPageNumber = ""+scPageNumber;
			mashupRefList[0].scPreviousPageRecord = pageModel[""+(scPageNumber-1)];
		
			if( pageAction==="START" || (pageAction==="NEXT" && pageModel.IsLastPage!=="Y" && pageModel.IsValidPage!=='N') || (pageAction==="PREVIOUS" && pageModel.IsFirstPage!=="Y")){
				mashupService._callMashupsAction(mashupRefList, options).then(function(response){
					mashupService._handleMashupOutput(control,response,options,deferred);				
				});
			}
		}
		return deferred.promise;
	};
	/**
	 * @ngdoc method
	 * @name iscMashup#callMashup
	 * @description Calls mashups
	 * 
	 * @param {object} control View controller object instance
	 * @param {string} mashupRefId Mashup ref id of the mashup to be called
	 * @param {object} mashupInput Mashup input
	 * @param {object} options Options to be passed while calling mashup
	 * 
	 * @returns {object} Returns a mashup promise object
	 */
	
	mashupService.callMashup = function(control, mashupRefId, mashupInput, options) {
		var mashup = _getMashupObject(control,mashupRefId);
		var deferred = $q.defer();
		if(mashup){
			var mashupRefList = [];
			mashupRefList[0] = mashupService.getMashupRefObj(control, mashupRefId, mashupInput);
			
			var cachedMashupOutputArray = mashupService._getMashupCacheOutput(mashupRefList,options);
			
			if(mashupRefList.length > 0) {
				mashupService._callMashupsAction(mashupRefList,options).then(function(response){
					mashupService._handleMashupOutput(control,response,options,deferred);
				});
			} else {
				var response = mashupService._createMashupCacheResponseObject();
				response.data.controllerData.MashupRefs.MashupRef.push(cachedMashupOutputArray[0]);
				mashupService._handleMashupOutput(control,response,options,deferred);
			}
		}
		return deferred.promise;
	};
	
	mashupService._getMashupCacheOutput = function(mashupRefList,options) {
		var isMultiAPICall = false;
		var cachedMashupOutputArray = [];
		
		if(options && options.isMultiAPICall == true) cachedMashupOutputArray;
		
		var indexesToRemove = [];
		for(var i=0; i< mashupRefList.length; i++) {
			mashupRefObj = mashupRefList[i];
			if(iscMashupCache.isMashupCached(mashupRefObj)) {
				var cachedMashupOutput= iscMashupCache.getCachedMashupOutput(mashupRefObj);
				if(cachedMashupOutput) {
					indexesToRemove.push(i);
				}
			}
		}
		
		if(indexesToRemove.length > 0) {
			for (var j=indexesToRemove.length-1; j >= 0; j--) {
				var cacheObj = {};
				cacheObj.index = indexesToRemove[j];
				cacheObj.mashupId = mashupRefList[indexesToRemove[j]].mashupId;
				cacheObj.mashupRefId = mashupRefList[indexesToRemove[j]].mashupRefId;
				cacheObj.Output = iscMashupCache.getCachedMashupOutput(mashupRefList[indexesToRemove[j]]);
				mashupRefList.splice(indexesToRemove[j],1);
				cachedMashupOutputArray.push(cacheObj);
			}
		}
		
		return cachedMashupOutputArray;
	};
	
	mashupService._createMashupCacheResponseObject = function() {
		var response = {};
		response.status = 200;
		response.data ={};
		response.data.controllerData={};
		response.data.controllerData.MashupRefs = {};
		response.data.controllerData.MashupRefs.MashupRef = [];
		return response;
	};
    
	mashupService._handleSimpleMashupOutput = function (control, response, options, deferred) {
        if (!(response.status >= 200 && response.status < 300)) {
            iscModal.showErrorMessage("mashup.MESSAGE_Mashup_error", null, null);
        }
        else if(mashupService._hasMashupError(response)){
            if(!_hasMashupHandler(deferred.promise,2)){
                mashupService.handleMashupError(response.data);
            }
            else{
                mashupService._processMashupError(response.data);
            }
            deferred.reject(response.data);
        }
        else {
            if (options && options.successMessage && !_hasMashupHandler(deferred.promise, 1)) {
                $rootScope.ui.alertMessage = options.successMessage;
                $rootScope.ui.showAlertMessage = true;
            }
            deferred.resolve(response.data.controllerData);
        }
    };

	mashupService._handleMashupOutput = function(control, response, options,deferred) {		
		if(!(response.status>=200 && response.status<300)){
		  iscModal.showErrorMessage("mashup.MESSAGE_Mashup_error",null,null);
		}
        else if(mashupService._hasMashupError(response)){
            if(!_hasMashupHandler(deferred.promise,2)){
                mashupService.handleMashupError(response.data);
            }
            else{
                mashupService._processMashupError(response.data);
            }
            deferred.reject(response.data);
        }
		else{
			/* handling callMashups cached mashup output first */
			if(options && options.cachedMashupOutputArray && options.cachedMashupOutputArray.length > 0) {
				var responseArray = response.data.controllerData.MashupRefs.MashupRef;
				for(var j=options.cachedMashupOutputArray.length-1; j >= 0; j--) {
					var cacheObj = options.cachedMashupOutputArray[j];
					var indexToAddAt = cacheObj.index;
					responseArray.splice(indexToAddAt,0,cacheObj);
				}
			}	
			for(var i=0;i<response.data.controllerData.MashupRefs.MashupRef.length;i++){
				var mashupRef = response.data.controllerData.MashupRefs.MashupRef[i];			
				var mashup = _getMashupObject(control,mashupRef.mashupRefId);			
				
				if(mashup){
					var model = mashupRef.Output;
					
					if (mashup.handler !== undefined && angular.isFunction(control[mashup.handler])) {
						model = control[mashup.handler](model);
					}
					if (mashup.modelName) {
					  if(!(mashup.isPaginated && mashup.append)){
					    control.model[mashup.modelName] = model;  
					  }
					  else{
					    if(iscCore.isVoid(control.model[mashup.modelName])){
					      control.model[mashup.modelName] = model;
					    }
					    else{
					      
					      var appendModel = iscCore.getValueFromJsonPath(model.Page.Output,mashup.appendPath);
					      var currentModel = iscCore.getValueFromJsonPath(control.model[mashup.modelName].Page.Output,mashup.appendPath);
					      //currentModel.concat(appendModel);
					      if(angular.isArray(appendModel) && angular.isArray(currentModel) && model.Page.IsValidPage !== 'N'){//it will check for void also, when user has visited last page and in continoud scrolling again tries to scroll down, appendModel will become null
							  for(var l=0;l<appendModel.length;l++){
								currentModel.push(appendModel[l]);
							  }
						  }
					      control.model[mashup.modelName].Page.IsFirstPage = model.Page.IsFirstPage;
					      control.model[mashup.modelName].Page.IsLastPage = model.Page.IsLastPage;
					      control.model[mashup.modelName].Page.PageNumber = model.Page.PageNumber;
						  control.model[mashup.modelName].Page.IsValidPage = model.Page.IsValidPage;
					    }
					  }
					}
					if(mashup.isPaginated){
						_getPageModel(control,mashup.mashupRefId)[model.Page.PageNumber] = model.Page.LastRecord;
						_getPageModel(control,mashup.mashupRefId).currentPageNumber = model.Page.PageNumber;
						_getPageModel(control,mashup.mashupRefId).IsLastPage = model.Page.IsLastPage;
						_getPageModel(control,mashup.mashupRefId).IsFirstPage = model.Page.IsFirstPage;
						_getPageModel(control,mashup.mashupRefId).IsValidPage = model.Page.IsValidPage;
					}
					//console.log(model);
				}			
			}
			
			if(options && options.successMessage && !_hasMashupHandler(deferred.promise,1)){
			  $rootScope.ui.alertMessage=options.successMessage;
			  $rootScope.ui.showAlertMessage=true;
			}
			deferred.resolve(response.data.controllerData);
		}
		//console.log(response.data.controllerData);
	};
	
    
    mashupService._hasMashupError = function(response){
        return response.data.Errors || (response.data.response && response.data.response.success == "false");
    }
    
    /**
	 * @ngdoc method
	 * @name iscMashup#handleMashupError
	 * @description Handles mashup error and 
	 * 
	 * @param {object} controllerError response error object
	 */
    
    mashupService.handleMashupError = function (controllerError) {
        
        if (controllerError.Errors) {
            var errorMsg = controllerError.Errors.Error[0].ErrorDescription;
            var errorCode = controllerError.Errors.Error[0].ErrorCode;
            console.log(errorCode);
            if (iscI18n.hasKey("apierror." + errorCode)) {
                errorMsg = iscI18n.translate("apierror." + errorCode);
                iscModal.showErrorMessage(errorMsg, null, null);
            }
            else {
                iscModal.showErrorMessage(errorMsg, null, null);
            }
        }
        else if (controllerError.response && controllerError.response.success == "false") {
            var errorCode = controllerError.response.em;
            if (iscI18n.hasKey("apierror." + errorCode)) {
                errorMsg = iscI18n.translate("apierror." + errorCode);
                iscModal.showErrorMessage(errorMsg, null, null);
            }
            else {
                iscModal.showErrorMessage(errorCode, null, null);
            }
        }
        
    };
    
    mashupService._processMashupError = function(controllerError){
        if (controllerError.Errors) {
            controllerError.Errors.Attributes = {};
            for(var i=0;i<controllerError.Errors.Error[0].Attribute.length;i++){
                var error = controllerError.Errors.Error[0].Attribute[i];
                controllerError.Errors.Attributes[error.Name]=error.Value; 
            }
        }
    }
    
	var _hasMashupHandler = function(promise,type){
	  if(promise && promise.$$state && promise.$$state.pending){
	    return angular.isFunction(promise.$$state.pending[0][type]) && promise.$$state.pending[0][type]!== angular.noop;
	  }
	  else{
	    return false;
	  }
	};
	
	mashupService._callMashupsAction = function(mashupRefList,options){
		$rootScope.ui.showAlertMessage = false; // The alert message panel should be closed when a new mashup call is made
		var isMultiAPICall = false;
		var showMask = true;
		if(options && options.showMask===false){
		  showMask = false;
		}
		if(options && options.isMultiAPICall == true) isMultiAPICall = true;
		
		var dataToPost = {
			method: "POST",
			url: _mashupControllerUrl,
			showMask:showMask,
			headers: {"Content-Type": "application/x-www-form-urlencoded","SCIAjax":"true"},
			transformResponse: function(value, headersGetter, status) {				
				var data = null;//{"scControllerData":{"mashupId": mashupId, "mashupInput": inputData, "mashupOutput": value}};
				if (status >=200 && status < 300 && headersGetter().loginpage!=="true") {
					data = JSON.parse(JSON.stringify(eval('('+value+')')));
				}
				return data;
			}
		};
		var scControllerData ={
			"MashupRefs":{
				"MashupRef":mashupRefList,
				"isMultiAPICall" : isMultiAPICall				
			}
		};
		dataToPost.data = iscHttpRequest.addAdditionalParams("scControllerData=" + encodeURIComponent(JSON.stringify(scControllerData)), "POST", _mashupControllerUrl);
		var promise = $http(dataToPost);
        promise.then(function(data, status, headers, config) {
				
				if(status >= 200 && status < 300 && data.controllerData) { //If there is an API error from custom mashup, data.controllerData won't be present
					for(var i=0;i<data.controllerData.MashupRefs.MashupRef.length;i++){
						var mashupRefObj = data.controllerData.MashupRefs.MashupRef[i];
						var mashupOutput = mashupRefObj.Output;
						if(iscMashupCache.isMashupCached(mashupRefObj) && (!mashupRefObj.isPaginated)) {
							var cachedMashupOutput= iscMashupCache.getCachedMashupOutput(mashupRefObj);
							if(!cachedMashupOutput) {
								iscMashupCache.putMashupOutputInCache(mashupRefObj,mashupOutput)
							}
						}
					}
				}
				
				//return data;
			});
		/*success(
			function(data, status, headers, config) {
				
				//Caching code starts: Add the API output to cache 
				if(status >= 200 && status < 300 && data.controllerData) { //If there is an API error from custom mashup, data.controllerData won't be present
					for(var i=0;i<data.controllerData.MashupRefs.MashupRef.length;i++){
						var mashupRefObj = data.controllerData.MashupRefs.MashupRef[i];
						var mashupOutput = mashupRefObj.Output;
						if(iscMashupCache.isMashupCached(mashupRefObj) && (!mashupRefObj.isPaginated)) {
							var cachedMashupOutput= iscMashupCache.getCachedMashupOutput(mashupRefObj);
							if(!cachedMashupOutput) {
								iscMashupCache.putMashupOutputInCache(mashupRefObj,mashupOutput)
							}
						}
					}
				}
				//Caching code ends 
				return data;
			}
		).
		error(
			function(data, status, headers, config) {
				console.log(data);
			}
		);*/
		return promise;		
	};
	
	var defaultPollingTime = 10000;
    var polls = {};
	
	mashupService.startPollingMashup = function(control,mashupRefId,mashupInput,pollingTime,options){
		var deferred = $q.defer();
		if (!polls[name]) {
			var poller = function() {
			  var mashup = _getMashupObject(control,mashupRefId);		
    		if(mashup){
    			var mashupRefList = [];
    			mashupRefList[0] = mashupService.getMashupRefObj(control, mashupRefId, mashupInput);			
    			mashupService._callMashupsAction(mashupRefList,{showMask:false}).then(function(response){
    				mashupService._handleMashupOutput(control,response,options,deferred);				
    			});
    		}
				//mashupService.callMashup(control,mashupRefId,inputData,callBackHandler);				
			};
			poller();
			polls[name] = setInterval(poller, pollingTime || defaultPollingTime);
		}
		return deferred.promise;
	};
	
	
	mashupService.stopPollingMashup = function(name) {
		clearInterval(polls[name]);
		delete polls[name];
	};
	return mashupService;	
	
}]);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
/**
 * @ngdoc service
 * @name iscMashupCache
 *
 * @description 
 * Caches the mashup output for a unique 'mashupId-mashupInput' combination. 
 * Exposes the methods which are used by the 'iscMashup' service to implement mashup output caching. 
 * 
 * Mashup call can be made either from a controller or a directive. An attribute called 'cached' has to be set as 'PAGED' for mashup output caching to work.
 * 
 * In case of a view controller, either 'callMashup' or 'callMashups' method of 'iscMashup' service is used to make a mashup call. List of mashups to be called is passed as input to these methods based on the 'mashupRefs' array the controller maintains for that view. 'cached' attribute needs to be set for a mashup in this mashup definition array. 
 * 
 * In case of a directive, the mashup call is made through 'callSimpleMashup' method of the 'iscMashup' service. For this method, the 'cached' attribute is passed through the 'options' argument.
 *
 * @example
 * mashupRefs: [{	mashupRefId: 'getCompleteItemList',mashupId: 'additems_getCompleteItemList',
   modelName : 'getCompleteItemList',cached: 'PAGE'}]
 *
 * @example
 * iscMashup.callSimpleMashup($scope,"wsccommon_getCountryList",mashupInput,{"cached":"PAGE"}).
 * then($scope.successHandler.bind($scope),$scope.failureHandler.bind($scope));
 *
 */
 angular.module('isc.shared').factory('iscMashupCache', ['$rootScope', function($rootScope) {
	
	var mashupCacheService = {};
	
	var mashupOutputPageCaching = {};
	
	/**
	 * @ngdoc property
	 * @name iscMashupCache#_lruMax
	 * @description
	 * Size limit on how many mashup output objects can be cached
	 */
	var _lruMax= 100;
	
	/**
	 * @ngdoc method
	 * @name iscMashupCache#isMashupCached
	 *
	 * @param mashupRefObj {Object} Mashup reference object that should have the 'cached' attribute set
	 *
	 * Mashup reference object contains information like: mashupId, mashupRefId, Input, cached etc
	 *
	 * @returns {Boolean} true if a mashup's cached attribute is set to 'PAGED'. false, otherwise.
	 *
	 * @description
	 * Checks if a mashup is cached or not.
	 */
	
	mashupCacheService.isMashupCached = function(mashupRefObj){
		if(!mashupRefObj.cached){
			return false;
		}else if(mashupRefObj.cached == "PAGE"){
			return true;
		}
		return false;
	};
	
	/**
	 * @ngdoc method
	 * @name iscMashupCache#getCachedMashupOutput
	 *
	 * @param mashupRefObj {Object} Mashup reference object that should have the 'cached' attribute set
	 *
	 * Mashup reference object contains information like: mashupId, mashupRefId, Input, cached etc
	 *
	 * @returns {Object} Mashup output from the cache as an object that contains input, output and lastAccess time for the cache output
	 *
	 * @description
	 * Gets the mashup output from the cache for the given 'mashupId - Input' combination.
	 */
	mashupCacheService.getCachedMashupOutput = function(mashupRefObj) {
		return this.getFromLRU(mashupRefObj);
	};
	
	mashupCacheService.getFromLRU = function(mashupRefObj) {
		if(mashupRefObj.cached == "PAGE") {
			return this._get(mashupRefObj.mashupId,mashupRefObj.Input,mashupOutputPageCaching);	
		}
	};
	
	mashupCacheService._get = function(mashupId,mashupInput,bigCache){
		var cacheForMashupId=bigCache[mashupId];					
		if(cacheForMashupId){
			for(var i=0; i<cacheForMashupId.cache.length;i++){
				var cachedObj=cacheForMashupId.cache[i];
				if(this._equals(cachedObj.input,mashupInput)){
					cachedObj.lastAccess=new Date().getTime();
					return cachedObj.output;							
				}
			}
		}
		return null;
	};
	
	/**
	 * @ngdoc method
	 * @name iscMashupCache#putMashupOutputInCache
	 *
	 * @param mashupRefObj {Object} Mashup reference object that should have the 'cached' attribute set
	 *
	 * Mashup reference object contains information like: mashupId, mashupRefId, Input, cached etc
	 *
	 * @description
	 * Checks if the cache has reached the limit and if yes, purges the oldest entry from the cache.
	 * Adds the mashup output from the server into the cache for the 'mashupId - Input' combination.
	 */
	mashupCacheService.putMashupOutputInCache = function(mashupRefObj,mashupOutput){
		var mashupInput = mashupRefObj.Input;			
		this.addtoLRU(mashupRefObj,mashupInput,mashupOutput);
	};
	
	mashupCacheService.addtoLRU = function(mashupRefObj,input,output){
		if(mashupRefObj.cached == "PAGE") {
			mashupOutputPageCaching[mashupRefObj.mashupId] = this._add(mashupRefObj.mashupId,input,output,mashupOutputPageCaching);
		}
	};
	
	mashupCacheService._add = function(mashupId,input,output,bigCache){
		var cacheForMashupId = null;
		if(this._lruMax >0 && this._countCache(bigCache) == this._lruMax){
			this._purge(bigCache);
		}
		cacheForMashupId = bigCache[mashupId];
		if(!cacheForMashupId){
			cacheForMashupId = {};
			cacheForMashupId.cache = [];
		}
		var cacheObj = {"input":input,"output":output,"lastAccess":new Date().getTime()};
		cacheForMashupId.cache.push(cacheObj);
		return cacheForMashupId;
	};
	
	mashupCacheService._countCache = function(bigCache){
		var count = 0;
		if(!bigCache){
			return count;
		}		
		//calculate the lengths of cache arrays for all mashupids and add them to get the final count of cache size.
		for(var mashupId in bigCache){
			if(bigCache.hasOwnProperty(mashupId)){
				var cacheForMashupId = bigCache[mashupId];
				count = count + cacheForMashupId.cache.length;
			}
		}			
		return count;
	};
	
	mashupCacheService._purge = function(bigCache){
		var temp = [];
		var count = 0;
		for(var mashupId in bigCache){
			if(bigCache.hasOwnProperty(mashupId)){
				var cacheForMashupId = bigCache[mashupId];
				for(var i=0; i<cacheForMashupId.cache.length;i++){
					temp[count]={"mashupId":mashupId,"cacheObj":cacheForMashupId.cache[i]};
					count++;
				}
			}
		}	
		//sort in the descending order of last accessed date as pop will return the last element of the array.	
		temp.sort(function(x,y){
			return y.cacheObj.lastAccess - x.cacheObj.lastAccess;					
		});
		
		var leastUsed = temp.pop();
		var cacheForMashupId = bigCache[leastUsed.mashupId];
		for(var i=0; i<cacheForMashupId.cache.length;i++){
			var cacheObj = cacheForMashupId.cache[i];
			//look for the least used object in the actual cache array using the lastAcces time.
			if(cacheObj.lastAccess-leastUsed.cacheObj.lastAccess == 0){
				//remove the least recently used element
				cacheForMashupId.cache.splice(i,1);
			}
		}				
	};
	
	//Deep search equals function, checks if its a number/date and compares
	// if its an array or object it calls equals function recursively.
	mashupCacheService._equals = function (obj1 , obj2){

		if((obj1 === undefined)&&(obj2 === undefined)){
			return true;
		}
		if(arguments.length < 2){
			return false;
		}
		if((obj1 === obj2)||(obj1 == obj2)||
			( typeof obj1 == "number" && typeof obj2 == "number" && isNaN(obj1) && isNaN(obj2) )){
			return true;
		}
		if( (angular.isArray(obj1) && angular.isArray(obj2))&&
			(this._arrayEquals(obj1, obj2)) ){
			return true;
		}
		if( ((typeof obj1 == "object")&&((typeof obj2 == "object")))&&
			(this._objectEquals(obj1, obj2)) ){
			return true;
		}
	};
	
	mashupCacheService._arrayEquals = function(obj1, obj2){
		if(obj1.length != obj2.length){ return false; }				
		for(var x=0; x<obj1.length; x++){
			if(!this._equals(obj1[x], obj2[x])){ return false; }
		}
		return true;
	};
	
	mashupCacheService._objectEquals = function(obj1, obj2){
		if(obj1 === null && obj2 === null){
			return true;
		}

		if(obj1 === null || obj2 === null){
			return false;
		}
		if(obj1 instanceof Date){
			return obj2 instanceof Date && obj1.getTime()==obj2.getTime();
		}
		var x;
		
		for(x in obj2){
			if(obj1[x] === undefined){
				return false;
			}
		};

		for(x in obj1){
			if(!this._equals(obj1[x], obj2[x])){
				return false;
			}
		}
		return true;
	};
	
	/**
	 * @ngdoc method
	 * @name iscMashupCache#setMashupCacheLimit
	 *
	 * @param limit {Number} New size for the mashup output cache
	 *
	 * @description
	 * Sets the mashup output cache size. 
	 */
	mashupCacheService.setMashupCacheLimit = function(limit){
		this._lruMax=limit;				
	};
	
	/**
	 * @ngdoc method
	 * @name iscMashupCache#getMashupCacheLimit
	 *
	 * @returns {Number} The current mashup output cache size
	 *
	 * @description
	 * Gets the mashup output cache size. 
	 */
	mashupCacheService.getMashupCacheLimit = function(){
		return this._lruMax;				
	};
	
	return mashupCacheService;
 
 }]);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp.  2015, 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/

/**
 * @ngdoc service
 * @name iscOrder
 * 
 * 
 * @description 
 * Handles all the common tasks related to order. 
 * 
 */
angular.module('isc.shared').factory('iscOrder', ['$http','$filter','$q','iscAppInfo','iscModal','iscI18n','iscMashup','iscState','iscObjectUtility','iscAppContext','$rootScope','iscResourcePermission',
 function($http,$filter,$q,iscAppInfo,iscModal,iscI18n,iscMashup, iscState,iscObjectUtility,iscAppContext,$rootScope,iscResourcePermission) {
  
   var orderService = {};	 
   
   /**
	 * @ngdoc method
	 * @name iscOrder#updateOrderLines
	 * @description Updates OrderLineList model with getCompleteOrderLineList api output
	 * @param apiOutput {object} Output model object containing getCompleteOrderLineList output
	 * @param orderLineList {object} model which needs to be updated with apiOutput
	 */
   
   orderService.updateOrderLines = function(apiOutput,orderLineList){
     	
	        var orderLines = []; 
	        orderLines = orderLineList.OrderLineList.OrderLine;
	        
			if(!iscCore.isVoid(apiOutput.Order.OrderLines) && !iscCore.isVoid(apiOutput.Order.OrderLines.OrderLine)){
				
				var modifiedLines = [];
				var matchingLineFound = false;
				modifiedLines = apiOutput.Order.OrderLines.OrderLine;
				
     		    for(var j=0; j<modifiedLines.length; j++){
     		    	matchingLineFound = false;
					for(var k= 0; k<orderLines.length ; k++){
						if(orderLines[k].OrderLineKey === modifiedLines[j].OrderLineKey){
							 orderLines[k] =modifiedLines[j];
							 orderLines[k].OrderLineTranQuantity.OrderedQty = $filter('number')(orderLines[k].OrderLineTranQuantity.OrderedQty);    
			 				 orderLines[k].OrderedQty = $filter('number')(orderLines[k].OrderedQty);
							 if(!iscCore.isVoid(orderLines[k].LineSeqNo)) {
								orderLines[k].LineSeqNumber = orderLines[k].LineSeqNo.split('.')[0];
								orderLines[k].DisplayStatus = this.getLineDisplayStatus(orderLines[k]);
							 }
							 matchingLineFound = true;
							 break;
						}
					}
					
					if(!matchingLineFound){
						orderLines[orderLines.length] = modifiedLines[j];
						orderLines[orderLines.length-1].OrderLineTranQuantity.OrderedQty = $filter('number')(orderLines[orderLines.length-1].OrderLineTranQuantity.OrderedQty);
		 				orderLines[orderLines.length-1].OrderedQty = $filter('number')(orderLines[orderLines.length-1].OrderedQty);
						if(!iscCore.isVoid(orderLines[orderLines.length-1].LineSeqNo)) {
							orderLines[orderLines.length-1].LineSeqNumber = orderLines[orderLines.length-1].LineSeqNo.split('.')[0];
							orderLines[orderLines.length-1].DisplayStatus = this.getLineDisplayStatus(orderLines[orderLines.length-1]);
		 				}
					}
     	 	   }
			}
			
			if(!iscCore.isVoid(apiOutput.Order.DeletedOrderLines)){
				var deletedLines = [];
				deletedLines = apiOutput.Order.DeletedOrderLines.OrderLine;
        		    for(var j=0; j<deletedLines.length; j++){
					
					for(var k= 0; k<orderLines.length ; k++){
						if(orderLines[k].OrderLineKey === deletedLines[j].OrderLineKey){
							orderLines.splice(k,1);
							 break;
						}
					}
        	 	   }
			}
           
		   orderLineList.OrderLineList.TotalNumberOfRecords=orderLines.length;
		   
     };
     
     /**
 	 * @ngdoc method
 	 * @name iscOrder#updateOrderHeaderDetails
 	 * @description Updates order model with getCompleteOrderDetails api output
 	 * @param apiOutput {object} Output model object containing getCompleteOrderDetails output
 	 * @param order {object} model which needs to be updated with apiOutput
 	 * @returns {Object} model containing updated order header details.
 	 */
    
     
     orderService.updateOrderHeaderDetails = function(apiOutput,order){
    	
    	var orderDetails = angular.copy(apiOutput);
    	//preserving OrderLines element in the order header
     	if(!iscCore.isVoid(orderDetails.Order.OrderLines) && !iscCore.isVoid(orderDetails.Order.OrderLines.OrderLine)){
     		delete orderDetails.Order.OrderLines["OrderLine"];
     	}
     	
     	return orderDetails;
     }; 
     
     /**
  	 * @ngdoc method
  	 * @name iscOrder#getGiftInstructionForOrderLine
  	 * @description Returns gift instruction of a order line.
  	 * @param {Object} orderlineModel - orderLine data as JSON object. 
  	 * @returns {Object} object containing gift instruction.
  	 */
     
     orderService.getGiftInstructionForOrderLine = function(orderlineModel){
     	
     	  var instructionList = orderlineModel.Instructions.Instruction;
		  var giftInstruction = null;
			
            if(!iscCore.isVoid(instructionList)){
			for(var k= 0; k<instructionList.length ; k++){
				if(instructionList[k].InstructionType == 'Gift'){
					giftInstruction = instructionList[k];
					break;
				}
			}
            } 	
			return giftInstruction;
     };
     
     
     /**
   	 * @ngdoc method
   	 * @name iscOrder#checkIfAnyOrderlineIsGift
   	 * @description Checks if any of the order lines is a gift.
   	 * @param {Object} orderLineList - list of order lines. 
   	 * @returns {String} Y if any of the order line is gift.
   	 */
     
     orderService.checkIfAnyOrderlineIsGift = function(orderLineList){
     	
    	  var orderLines = []; 
	      orderLines = orderLineList.OrderLineList.OrderLine;
				var isAnyLineGift = false; 
				for(var k= 0; k<orderLines.length ; k++){
					if(orderLines[k].GiftFlag === 'Y'){
						isAnyLineGift = true;
						break;
					}
				}
				return isAnyLineGift;
     };
     
     /**
    	 * @ngdoc method
    	 * @name iscOrder#addPriceOverrideDefaultNote
    	 * @description Adds Order line note to the api input of modifyFulfillmentOptions when unit price of a order line is overriden .
    	 * @param {Object} apiInput - modifyFulfillmentOptions api input. 
    	 * @param {String} priceOverrideReason - reason for overriding the price. 
    	 */
     orderService.addPriceOverrideDefaultNote = function(apiInput,priceOverrideReason){
     	var noteText = iscI18n.translate('addItems.MSG_PriceOverrideReason',{overrideReason: priceOverrideReason});
     	apiInput.Order.OrderLines.OrderLine[0].Notes = [];
     	apiInput.Order.OrderLines.OrderLine[0].Notes[0] = {};
     	apiInput.Order.OrderLines.OrderLine[0].Notes[0].Note = {
     			'NoteText': noteText,
     			'ReasonCode': 'YCD_NEW_ITEM_INFO'
     	};
     };
     
     /**
    	 * @ngdoc method
    	 * @name iscOrder#checkIfOrderHasShipLines
    	 * @description Checks if any of the order lines is a shipping line.
    	 * @param {Object} orderLineList - list of order lines. 
    	 * @returns {Boolean} true if any of the order lines is a shipping line.
    	 */
     
     orderService.checkIfOrderHasShipLines = function(orderLineList){
    	 
    	var isShippingLinePresent = false; 
    	
    	if(!iscCore.isVoid(orderLineList)){
    		for(var i= 0; i<orderLineList.length; i++){
    			if(orderLineList[i].DeliveryMethod === 'SHP'){
    					isShippingLinePresent = true;
    					break;
    				 }
    			}
    	}
        
        return isShippingLinePresent;  
		};
      
		/**
    	 * @ngdoc method
    	 * @name iscOrder#prepareModifyFulfillmentOptionsApiInput
    	 * @description Prepares modifyFulfillmentOptions api input for a OrderLine
    	 * @param {String} orderHeaderKey - Unique identifier of a Order.
    	 * @param {String} orderLineKey - Unique identifier of a Order line. 
    	 * @returns {Object} modifyFulfillmentOptionsInput -modifyFulfillmentOptions api input.
    	 */
		
     orderService.prepareModifyFulfillmentOptionsApiInput = function(orderHeaderKey,orderLineKey){
        var  modifyFulfillmentOptionsInput = {};
		modifyFulfillmentOptionsInput.Order = {};
		modifyFulfillmentOptionsInput.Order.OrderHeaderKey=orderHeaderKey;
		modifyFulfillmentOptionsInput.Order.OrderLines = {};
		modifyFulfillmentOptionsInput.Order.OrderLines.OrderLine = [];
		modifyFulfillmentOptionsInput.Order.OrderLines.OrderLine[0]={};
		modifyFulfillmentOptionsInput.Order.OrderLines.OrderLine[0].OrderLineKey = orderLineKey;
		return modifyFulfillmentOptionsInput;
     };
     
     
     /**
 	 * @ngdoc method
 	 * @name iscOrder#prepareChangeOrderInputForGift
 	 * @description Prepares changeOrder api input when Order is marked as gift
 	 * @param {Object} giftOptionsData - object containing gift information. 
 	 * @param {String} orderHeaderKey - Unique identifier of a Order.
 	 * @param {Object} orderLineList - list of order lines. 
 	 * @returns {Object} apiInput -changeOrder api input.
 	 */
     
     orderService.prepareChangeOrderInputForGift = function(giftOptionsData,orderHeaderKey,orderLineList){
    	   
	    	var apiInput = {};
	     	apiInput.Order = {};
	     	apiInput.Order.OrderHeaderKey=orderHeaderKey;
	     	apiInput.Order.OrderLines = {};
	     	apiInput.Order.OrderLines.OrderLine = [];
     	
    	   for(var k= 0; k<orderLineList.length ; k++){
    		  apiInput.Order.OrderLines.OrderLine[k] = {};
    		  apiInput.Order.OrderLines.OrderLine[k].OrderLineKey = orderLineList[k].OrderLineKey;
    		  
    		  if((!iscCore.isVoid(giftOptionsData.giftWrapChecked)) && giftOptionsData.giftWrapChecked === "Y"){
          		
          		apiInput.Order.OrderLines.OrderLine[k].GiftWrap = "Y";
          		apiInput.Order.OrderLines.OrderLine[k].GiftFlag = "Y";
          		
          	}else{
          		
          		apiInput.Order.OrderLines.OrderLine[k].GiftWrap = "N";
          		if(giftOptionsData.giftFlag === "Y"){
              		apiInput.Order.OrderLines.OrderLine[k].GiftFlag = "Y";
              	}
          	}
          	
    		 
          	if(!iscCore.isVoid(giftOptionsData.giftMessage)){
          		apiInput.Order.OrderLines.OrderLine[k].Instructions = {};
          		
          		apiInput.Order.OrderLines.OrderLine[k].Instructions.Instruction = [];
          		apiInput.Order.OrderLines.OrderLine[k].Instructions.Instruction[0] = {};
          		apiInput.Order.OrderLines.OrderLine[k].Instructions.Instruction[0].InstructionText=giftOptionsData.giftMessage;
          		apiInput.Order.OrderLines.OrderLine[k].Instructions.Instruction[0].InstructionType='Gift';
          		
          		var noOfInstructions = null;
          		if(orderLineList[k].Instructions){
          			noOfInstructions = parseInt(orderLineList[k].Instructions.NumberOfInstructions);
          		}
          		if(noOfInstructions > 0){
          			var giftInstructionObj =this.getGiftInstructionForOrderLine(orderLineList[k]);
        			var instructionDetailKey = null;
        			if(giftInstructionObj !== null){
        				instructionDetailKey = giftInstructionObj.InstructionDetailKey;
        				apiInput.Order.OrderLines.OrderLine[k].Instructions.Instruction[0].InstructionDetailKey=instructionDetailKey;
        			}
        			
          		}
          
          	}
          	
          	
          	if(!iscCore.isVoid(giftOptionsData.giftRecipient)){
          		apiInput.Order.OrderLines.OrderLine[k].PersonInfoMarkFor = {};
          		apiInput.Order.OrderLines.OrderLine[k].PersonInfoMarkFor.FirstName = giftOptionsData.giftRecipient;
          	}
			}
    	   
    	   return apiInput;
     };
     
     
     /**
  	 * @ngdoc method
  	 * @name iscOrder#prepareChangeOrderInputForGiftRemoval
  	 * @description Prepares changeOrder api input when gift options are removed for a order
  	 * @param {String} orderHeaderKey - Unique identifier of a Order.
  	 * @param {Object} orderLineList - list of order lines. 
  	 * @returns {Object} apiInput -changeOrder api input.
  	 */
     
     orderService.prepareChangeOrderInputForGiftRemoval = function(orderHeaderKey,orderLineList){
       	 
    	var apiInput = {};
     	apiInput.Order = {};
     	apiInput.Order.OrderHeaderKey=orderHeaderKey;
     	apiInput.Order.OrderLines ={};
     	apiInput.Order.OrderLines.OrderLine=[];
     	
     	 for(var k= 0; k<orderLineList.length ; k++){
			 
   		      apiInput.Order.OrderLines.OrderLine[k] = {};
   		      apiInput.Order.OrderLines.OrderLine[k].OrderLineKey = orderLineList[k].OrderLineKey;
         	  apiInput.Order.OrderLines.OrderLine[k].GiftWrap = "N";
         	  apiInput.Order.OrderLines.OrderLine[k].GiftFlag = "N";
   		
         	  var noOfInstructions = parseInt(orderLineList[k].Instructions.NumberOfInstructions);
         		
              if(noOfInstructions > 0){
         			
         		var giftInstructionObj =this.getGiftInstructionForOrderLine(orderLineList[k]);
       			var instructionDetailKey = null;
       			if(giftInstructionObj !== null){
       				instructionDetailKey = giftInstructionObj.InstructionDetailKey;
       				apiInput.Order.OrderLines.OrderLine[k].Instructions = {};
       				apiInput.Order.OrderLines.OrderLine[k].Instructions.Instruction = [];
                 	apiInput.Order.OrderLines.OrderLine[k].Instructions.Instruction[0] = {};
       				apiInput.Order.OrderLines.OrderLine[k].Instructions.Instruction[0].InstructionDetailKey=instructionDetailKey;
       				apiInput.Order.OrderLines.OrderLine[k].Instructions.Instruction[0].Action="REMOVE";
       			}
       			
         		}
        	
			}
     	
     	 return apiInput;
     };
     
     /**
 	 * @ngdoc method
 	 * @name iscOrder#orderHasAnyCarryLines
 	 * @description Checks if any of the order lines is a carry line.
 	 * @param {Object} orderModel -order model containing list of order lines. 
 	 * @returns {Boolean} true if any of the order lines is a carry line.
 	 */
     
	orderService.orderHasAnyCarryLines = function(orderModel){
	if(orderModel !== null && orderModel !== undefined && orderModel.Order && orderModel.Order.OrderLines && orderModel.Order.OrderLines.OrderLine){
		var len = orderModel.Order.OrderLines.OrderLine.length;
		for(var i = 0; i < len; i++){
			var orderLine = orderModel.Order.OrderLines.OrderLine[i];
			var deliveryMethod = orderLine.DeliveryMethod;
			if(deliveryMethod === 'CARRY'){
					return true;
				}
			}
		}
		return false;
	};
	
	/**
 	 * @ngdoc method
 	 * @name iscOrder#orderHasOnlyCarryLines
 	 * @description Checks if all of the order lines is a carry line.
 	 * @param {Object} orderModel -order model containing list of order lines. 
 	 * @returns {Boolean} true if all of the order lines is a carry line.
 	 */
     
	orderService.orderHasOnlyCarryLines = function(orderModel){
		if(orderModel !== null && orderModel !== undefined && orderModel.Order && orderModel.Order.OrderLines && orderModel.Order.OrderLines.OrderLine){
			var len = orderModel.Order.OrderLines.OrderLine.length;
			for(var i = 0; i < len; i++){
				var orderLine = orderModel.Order.OrderLines.OrderLine[i];
				var deliveryMethod = orderLine.DeliveryMethod;
				if(deliveryMethod != 'CARRY'){
					return false;
				}
			}
		}
		return true;
	};
	
	/**
 	 * @ngdoc method
 	 * @name iscOrder#orderHasAnyShippingLines
 	 * @description Checks if any of the order lines is a shipping line.
 	 * @param {Object} orderModel -order model containing list of order lines. 
 	 * @returns {Boolean} true if any of the order lines is a shipping line.
 	 */
	orderService.orderHasAnyShippingLines = function(orderModel){
	if(orderModel !== null && orderModel !== undefined && orderModel.Order && orderModel.Order.OrderLines && orderModel.Order.OrderLines.OrderLine){
		var len = orderModel.Order.OrderLines.OrderLine.length;
		for(var i = 0; i < len; i++){
			var orderLine = orderModel.Order.OrderLines.OrderLine[i];
			var deliveryMethod = orderLine.DeliveryMethod;
			if(deliveryMethod === 'SHP'){
					return true;
				}
			}
		}
		return false;
	};
	
	/**
 	 * @ngdoc method
 	 * @name iscOrder#orderHasAnyPickupLines
 	 * @description Checks if any of the order lines is a pickup line.
 	 * @param {Object} orderModel -order model containing list of order lines. 
 	 * @returns {Boolean} true if any of the order lines is a pickup line.
 	 */
	orderService.orderHasAnyPickupLines = function(orderModel){
	if(orderModel !== null && orderModel !== undefined && orderModel.Order && orderModel.Order.OrderLines && orderModel.Order.OrderLines.OrderLine){
		var len = orderModel.Order.OrderLines.OrderLine.length;
		for(var i = 0; i < len; i++){
			var orderLine = orderModel.Order.OrderLines.OrderLine[i];
			var deliveryMethod = orderLine.DeliveryMethod;
			if(deliveryMethod === 'PICK'){
					return true;
				}
			}
		}
		return false;
	};
	
	
	/**
 	 * @ngdoc method
 	 * @name iscOrder#openOverridePriceModal
 	 * @description Opens the override price pop-up.
	 * @param {Object} orderlineModel - orderLine data as JSON object. 
	 * @param {String} currency - currency for the product price. 
 	 * @param  {Object} ctrl - controller object invoking the util method.
 	 * @param {String} callbackhandler - name of the callbackhandler method that needs to be invoked when override price pop-up is closed.
 	 */
	
	orderService.openOverridePriceModal = function(orderlineModel,currency,ctrl,callbackhandler){
		

      	var ovpInput = {};
      	var callbackhandler = 'onPriceOverride';
      	ovpInput.price = {};
      	ovpInput.price.listPrice =  orderlineModel.LinePriceInfo.ListPrice;
      	ovpInput.price.unitPrice =  orderlineModel.LinePriceInfo.UnitPrice;
      	ovpInput.price.Currency = currency;
      	
      	var priceOverrideInput = {
      			modalInput: function(){
      				return ovpInput;
      			}
      	};
      	
      	iscModal.openModal('store.views.common.priceoverride.priceoverride',priceOverrideInput,{})
				.then(function(callBackData){
      			if(callBackData != null && callBackData.data != null && callBackData.data != undefined){
      				ctrl[callbackhandler].call(ctrl,callBackData.data,orderlineModel);
      			}		            			
 				},
				angular.noop);	
      
      	
	};

	/**
 	 * @ngdoc method
 	 * @name iscOrder#openStoreSearchModal
 	 * @description Opens Store search pop-up in pickup scenarios.
	 * @param {Object} orderlineModel - orderLine data as JSON object. 
 	 * @param  {Object} ctrl - controller object invoking the util method.
 	 * @param {String} callbackhandler - name of the callbackhandler method that needs to be invoked when override price pop-up is closed.
 	 * @param {String} mode - context of where the pop-up is opened. 
 	 */
	
   orderService.openStoreSearchModal = function(orderlineModel,ctrl,callbackhandler,mode){
	   
       	var currentStoreAddress = iscAppContext.getFromContext('storeAddress').ShipNodePersonInfo;
       	var storeSearchModalInput = {
       			modalInput: function(){
       				return {
       				inputData : {callingMode : mode,orderLine : orderlineModel}		
       						};
       								}
       						};
       	
       	iscModal.openModal('store.views.common.storesearch.storesearch',storeSearchModalInput,{})
       			 .then(function(callBackData){
       				ctrl[callbackhandler].call(ctrl,callBackData.data,orderlineModel);
				},angular.noop);
        
   };
   
   /**
	 *@ngdoc method
	 *@name iscOrder#openGiftOptionsForOrderLinePopup
	 *@description Opens Gift options popup for order line.
	 *@param {Object} orderlineModel - orderLine data as JSON object. 
	 *@param  {Object} ctrl - controller object invoking the util method.
 	 *@param {String} callbackhandler - name of the callbackhandler method that needs to be invoked when override price pop-up is closed.
	 */
   
   orderService.openGiftOptionsForOrderLinePopup = function(orderlineModel,ctrl,callbackhandler){
		
   		var giftOptionsInput = null;
   		if(orderlineModel.GiftFlag == "Y"){
                
   			var giftInstructionObj =this.getGiftInstructionForOrderLine(orderlineModel);
   			var giftMessage = null;
   			if(giftInstructionObj !== null){
   			  giftMessage = giftInstructionObj.InstructionText;
   			}
   			
   			var giftRecipient =null;
   			if(orderlineModel.PersonInfoMarkFor && orderlineModel.PersonInfoMarkFor.FirstName){
   				giftRecipient = orderlineModel.PersonInfoMarkFor.FirstName;
       		}
   			
   			 giftOptionsInput = {
           			gift:{
           				giftFlag:"Y",
           				giftWrap: orderlineModel.ItemDetails.PrimaryInformation.AllowGiftWrap,
           				giftRecipient : giftRecipient,
           				giftMessage : giftMessage, 
           				giftWrapChecked: orderlineModel.GiftWrap,
           				showRemoveGift:'Y'
          			}
           	};
   		}else{
   			
   			 giftOptionsInput = {
           			gift:{
           				giftWrap: orderlineModel.ItemDetails.PrimaryInformation.AllowGiftWrap,
           				giftWrapChecked: 'N'
         			}
           	};
   		}
   		
       	var giftOptionsModalInput = {
       			modalInput: function(){
       				return giftOptionsInput;
       			}
       	};
   	
       	iscModal.openModal('store.views.common.gift.giftoptions',giftOptionsModalInput,{})
				.then (function(callBackData){
					if(callBackData.data !== null && callBackData.data !== undefined){
						ctrl[callbackhandler].call(ctrl,callBackData.data,orderlineModel);
					}
					},
					angular.noop);
   
        
	};
	
	
	/**
	 *@ngdoc method
	 *@name iscOrder#prepareGetItemAvailabilityForStoreApiInput
	 *@description utility to prepare getItemAvailabilityForStore api input.
	 *@param {String} orderHeaderKey - unique identifier for order. 
	 *@param {String} orderlineModel - orderLine data as JSON object. 
	 *@returns {Object} json object. 
	 */
	
	orderService.prepareGetItemAvailabilityForStoreApiInput = function(orderHeaderKey,orderlineModel){
		
			var getItemAvailabilityForStoreInput = {'Promise':
								                  {'OrderHeaderKey':orderHeaderKey,
								                   'OrderLineKey':	orderlineModel.OrderLineKey,
								                   'PromiseLines':
								                       {
								                       'PromiseLine':
								                              [ 
								                                {'ItemID':orderlineModel.ItemDetails.ItemID,
								                                 'UnitOfMeasure' : orderlineModel.ItemDetails.UnitOfMeasure,
									                             'RequiredQty': orderlineModel.OrderLineTranQuantity.OrderedQty,
									                             'Quantity':orderlineModel.OrderLineTranQuantity.OrderedQty,
									                             'OrderLine':
									                                {
									                                   'OrderLineKey':orderlineModel.OrderLineKey,
										                               'DeliveryMethod':orderlineModel.DeliveryMethod 
									                                }
								                               }
								                              ] 
								                       }
								                   }
								                }; 

		if(orderlineModel.DeliveryMethod === "SHP"){
			getItemAvailabilityForStoreInput.Promise.ComputeShpAvl = "Y";	
		}
		
		else if(orderlineModel.DeliveryMethod === "PICK"){
			getItemAvailabilityForStoreInput.Promise.ComputePickupAvl = "Y";	
		    getItemAvailabilityForStoreInput.Promise.ShipNode =  orderlineModel.Shipnode.ShipNode;
		}
		else if(orderlineModel.DeliveryMethod === "CARRY"){
		getItemAvailabilityForStoreInput.Promise.ComputeCarryAvl = "Y";
		 getItemAvailabilityForStoreInput.Promise.ShipNode =  orderlineModel.Shipnode.ShipNode;
		}
			
		return getItemAvailabilityForStoreInput;
		
	};
	
	/**
 	 * @ngdoc method
 	 * @name iscOrder#orderHasMixedSettledLines
 	 * @description Checks if order has mixed settled lines, which is some lines settled and some lines not settled.
 	 * @param {Object} orderLineList -order line list model containing list of order lines. 
 	 * @returns {Boolean} true if order has some lines settled and some lines not settled .
 	 */
	orderService.orderHasMixedSettledLines = function(orderLineList){
		var len = orderLineList.length;
		var lineSettlementStatus = [];
		for(var i = 0; i < len; i++){
			var orderLine = orderLineList[i];
			var orderLineTranQty = orderLine.OrderLineTranQuantity;
			var settledQty = orderLineTranQty.SettledQuantity;
			var orderedQty = orderLineTranQty.OrderedQty;
			if(orderedQty == settledQty){
				lineSettlementStatus[i] = "Settled";
			}
			else {
				lineSettlementStatus[i] = "UnSettled";
			}
		}
		for(var j = 0; j < lineSettlementStatus.length; j++){
			if(j > 0 && lineSettlementStatus[j] != lineSettlementStatus[j-1]){
				//return true;
				return false;//Work-around for now, since there is an issue with settling lines using Foundation API
			}
		}
		return false;
	};
	
	/**
 	 * @ngdoc method
 	 * @name iscOrder#viewOrderFromList
 	 * @description Checks if order is a Draft Order or confirmed. Confirmed order are taken to Order summary screen. 
 	 * Draft Orders are taken to Order capture/ Cart details screen if they have permission for modifying the order. If they have permission we invoke changeOrder to modify the SellerOrgCode and Modifyts. 
 	 * @param {Object} order - order model. 
 	 * @returns {Boolean} true if back link needs to be displayed in Order Summary screen for Confirmed orders.
 	 */
	orderService.viewOrderFromList = function(order,showBackLinkInOrderSummary){
		if("Y" == order.DraftOrderFlag) {
			 if(iscResourcePermission.hasPermission("WSC000031")){
				 orderService.modifyDraftOrder({Order:order});
			 }else {
				 iscModal.showErrorMessage(iscI18n.translate('orderList.MSG_NoPermissionOrderCapture'));
			 }
		} else if("N" == order.DraftOrderFlag) {
			
			var orderModel = {};
			orderModel.Order = {};
			orderModel.Order.OrderHeaderKey = order.OrderHeaderKey;
			orderModel.Order.EnterpriseCode = order.EnterpriseCode;
			orderModel.Order.SellerOrganizationCode = order.SellerOrganizationCode;
			orderModel.Order.DocumentType = order.DocumentType;
			
			if(showBackLinkInOrderSummary) {
				iscState.goToState('ordersummary',{orderInput:orderModel,showBackLink:true},{});
			} else {
				iscState.goToState('ordersummary',{orderInput:orderModel,showBackLink:false},{});
			}
			
		}
	};
	
	/**
 	 * @ngdoc method
 	 * @name iscOrder#modifyDraftOrder
 	 * @description This method invokes changeOrder API to modify the SellerOrgCode to CurrentStore and Modifyts to Current timestamp so that coupons are re-evaluated.
 	 * @param {Object} order - order model. 
 	 */
	orderService.modifyDraftOrder = function(order) {

		var currentDate = new Date();
		currentDate = new Date(currentDate.setDate(currentDate.getDate() - 1));
		
		var currentStore = iscAppContext.getFromContext("storeName");
		
		// 510367 - (currentStore != order.Order.SellerOrganizationCode || iscObjectUtility.compareDates(order.Order.Modifyts, currentDate, "LT", true)
		if(!iscCore.isVoid(order)) {
			
			var orderModel = {};
			orderModel.Order = {};
			orderModel.Order.OrderHeaderKey = order.Order.OrderHeaderKey;
			orderModel.Order.SellerOrganizationCode = order.Order.SellerOrganizationCode;
			
			iscMashup.callSimpleMashup(this,'shared.lookup.modifyDraftOrder',orderModel,{}).then(function(response) {
				   
				var apiOutput = iscMashup.getSimpleMashupOutput(response,"shared.lookup.modifyDraftOrder");
				if(!iscCore.isVoid(apiOutput)) {
					iscState.goToState('ordercapture',{action:'QUICKCHECKOUT',orderModel:apiOutput},{});
				} else {
					console.error("ERROR: changeOrder failed !");
				}
				   
			   },angular.noop);
			   
		} else {
			iscState.goToState('ordercapture',{action:'QUICKCHECKOUT',orderModel:order},{});
		}
		
	};

	/**
 	 * @ngdoc method
 	 * @name iscOrder#addNote
 	 * @description Creates a note element and returns the same.
 	 * @param {Object} noteText - note text to be added in note.
	 * @param {Object} reasonCode - reasonCode for note. 
 	 * @returns {Object} Notes element created. 
 	 */
	orderService.addNote = function(noteText,reasonCode){
		var notes = {};
		notes.Note = {
			'NoteText':noteText,
			'ReasonCode':reasonCode,
			'ContactUser':iscAppContext.getFromContext('currentLoginID')
		}
		return notes;
	};
	
	/**
 	 * @ngdoc method
 	 * @name iscOrder#getCssClassByOrderStatus
 	 * @description Gets the css color class based on order status
 	 * @param {Object} order - order model. 
 	 * @returns {Object} String containing Css color class based on order status 
 	 */
	orderService.getCssClassByOrderStatus = function(orderStatus) {
		
		var cssClass = "additional";
		
		if(!iscCore.isVoid(orderStatus)) {
			
			if(orderStatus.match("^1100.7777") || orderStatus.match("^3700")) {
				cssClass = "completed";
			} else if(orderStatus.match("^1000") || orderStatus.match("^1100")) {
				cssClass = "initial";
			} else if(orderStatus.match("^9000")) {
				cssClass = "halt";
			} else if(orderStatus > "1140" &&  orderStatus <= "3350.10.10") {
				cssClass = "inprogress";
			} 
		}
		
		return cssClass;
		
	};
	
	/**
 	 * @ngdoc method
 	 * @name iscOrder#getDisplayStatus
 	 * @description Gets the Order Display Status
 	 * @param {Object} order - order model. 
 	 * @returns {Object} String containing order status 
 	 */
	orderService.getDisplayStatus = function(order){
	   	 if(order.MultipleStatusesExist == 'Y'){
	   		 return iscI18n.translate('globals.LABEL_PartialStatus',{status:order.MaxOrderStatusDesc});
	   	 }else{
	   		 return order.Status;
	   	 }
    };
    
    /**
 	 * @ngdoc method
 	 * @name iscOrder#getLineDisplayStatus
 	 * @description Gets the OrderLine Display Status
 	 * @param {Object} order - orderline model. 
 	 * @returns {Object} String containing orderline status 
 	 */
    orderService.getLineDisplayStatus = function(orderLine){
	   	 if(orderLine.MultipleStatusesExist == 'Y'){
	   		 return iscI18n.translate('globals.LABEL_PartialStatus',{status:orderLine.MaxLineStatusDesc});
	   	 }else{
	   		 return orderLine.Status;
	   	 }
   };
   
   /**
	 * @ngdoc method
	 * @name iscOrder#getOrderAge
	 * @description Gets the OrderLine Display Status
	 * @param {Object} String - order date. 
	 * @returns {Object} String containing orderline status 
	 */
   
   orderService.getOrderAge = function(toDate){
		var fromDate = new Date();
		toDate = new Date(toDate);
		/*getTime() gives date in milliseconds.Hence dividing by no. of ms in a day to get the number of days.*/
		var dateDiff = Math.floor(fromDate.getTime() - toDate.getTime())/(24 * 60 * 60 * 1000);
		return dateDiff;
	};
	
	
   /**
	 * @ngdoc method
	 * @name iscOrder#stampDisplayStatusOnOrderList
	 * @description Stamps Order Display Status on OrderList
	 * @param {Object} order - orderlist model. 
	 * @returns {Object} Model containing orderlist updated with order display status 
	 */
   orderService.stampDisplayStatusOnOrderList = function(orderList) {
	 
	   for(var i = 0;i < orderList.OrderList.Order.length;i++) {
		   var order = orderList.OrderList.Order[i];
		   order.DisplayStatus = orderService.getDisplayStatus(order);
	   }
	   
	   return orderList;
	   
   };
    
   return orderService;
 }]);




/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/

/**
 * @ngdoc service
 * @name iscPayment
 * @requires $http
 * @requires $q
 * @requires iscAppInfo
 * @requires iscModal
 * @requires iscI18n
 * @requires $rootScope
 * @requires iscObjectUtility
 * 
 * @description 
 * Handles all the common tasks related to Payment Capture. 
 * 
 */
 
angular.module('isc.shared').factory('iscPayment', ['$http','$q','iscAppInfo','iscModal','iscI18n','$rootScope','iscObjectUtility',
 function($http,$q,iscAppInfo,iscModal,iscI18n,$rootScope,iscObjectUtility) {
  
   var paymentService = {};	 
   
   /**
	 * @ngdoc method
	 * @name iscPayment#isPaymentMethodAuthorizedOrCharged
	 * @description Traverses through the paymentMethod model, to determine if the payment method has already been authorized or charged for some amount by looking into 
	 * 				values for TotalAuthorized and/or TotalCharged attribute in the model object.
	 * 
	 * @param {object} paymentMethod Model object 
	 * 
	 */
   paymentService.isPaymentMethodAuthorizedOrCharged = function(paymentMethod){
	 	if(paymentMethod.TotalAuthorized){
	 		if(iscObjectUtility.isGreaterThanZero(paymentMethod.TotalAuthorized)){
	 			return true;
	 		}
	 	}
	 	if(paymentMethod.TotalCharged){
	 		if(iscObjectUtility.isGreaterThanZero(paymentMethod.TotalCharged)){
	 			return true;
	 		}
	 	}
	 	return false;
	 };
	 /**
	 * @ngdoc method
	 * @name iscPayment#getPaymentTypeDetails
	 * @description Traverses through the output of getPaymentTypeList api, and fetches PaymentType model object for a particular payment type.
	 * 
	 * @param {String} paymentTypeName Name of the payment type
	 * @param {object} paymentTypeList List model of the payment types list, which is the mashup UI output model for getPaymentTypeList API
	 * 
	 */
	paymentService.getPaymentTypeDetails = function(paymentTypeName, paymentTypeList){
		for(var pt=0; pt < paymentTypeList.PaymentType.length; pt++){
			var paymentType = paymentTypeList.PaymentType[pt];
			if(paymentType && paymentTypeName && paymentTypeName === paymentType.PaymentType){
				return paymentType;
			}
		}
		return null;
	};	
	/**
	 * @ngdoc method
	 * @name iscPayment#getPaymentCardTypeDescription
	 * @description Traverses through the output of getPaymentCardTypeList api, fetches ShortDescription for a particular payment card type (or credit card type).
	 * 
	 * @param {String} paymentCardTypeName Name of the payment card type or credit card type
	 * @param {object} paymentCardTypeList List model of the payment card types (or credit card type) list, which is the mashup UI output model for getPaymentCardTypeList API
	 * 
	 */
	paymentService.getPaymentCardTypeDescription = function(paymentCardTypeName, paymentCardTypeList){
		for(var pt=0; pt < paymentCardTypeList.PaymentCardType.length; pt++){
			var paymentCardType = paymentCardTypeList.PaymentCardType[pt];
			if(paymentCardType && paymentCardTypeName && paymentCardTypeName === paymentCardType.PaymentCardType){
				return paymentCardType.ShortDescription;
			}
		}
		return null;
	};
	/**
	 * @ngdoc method
	 * @name iscPayment#getFormattedName
	 * @description Formats first name and last name values using a bundle entry 'address.LABEL_Display_name'.
	 * 
	 * @param {String} firstName First name of a customer.
	 * @param {String} lastName Last name of a customer.
	 * 
	 */
	paymentService.getFormattedName = function(firstName, lastName){
    	return(iscI18n.translate('address.LABEL_Display_name',{firstname: firstName, lastname : lastName}));
    };
    /**
	 * @ngdoc method
	 * @name iscPayment#getDisplayAccountNo
	 * @description Returns DisplayPrimaryAccountNo or last four digits of PrimaryAccountNo or last four digits of primary attribute of payment method.
	 * 
	 * @param {Object} paymentMethod.
	 * 
	 */
	paymentService.getDisplayAccountNo = function(paymentMethod){
    	if(paymentMethod.DisplayPrimaryAccountNo){
    		return paymentMethod.DisplayPrimaryAccountNo;
    	}
    	else {
    		var primaryAccountNo = paymentMethod.PrimaryAccountNo ? paymentMethod.PrimaryAccountNo : paymentService.getPrimaryAccountNo(paymentMethod);
    		if(primaryAccountNo){
	    		if(primaryAccountNo.length >=4){
	    			return primaryAccountNo.substring(primaryAccountNo.length-4,primaryAccountNo.length);
	    		}
    		}
    		else {
    			return "";
    		}
    	}
    };
     /**
	 * @ngdoc method
	 * @name iscPayment#getPrimaryAccountNo
	 * @description Returns PrimaryAccountNo of a payment method.
	 * 
	 * @param {Object} paymentMethod.
	 * 
	 */
	paymentService.getPrimaryAccountNo = function(paymentMethod){
    	if(paymentMethod.PrimaryAccountNo){
    		return paymentMethod.PrimaryAccountNo;
    	}
    	else {
    		var paymentTypeGroup = paymentMethod.PaymentTypeGroup;
    		if(paymentTypeGroup === "CREDIT_CARD"){
    			return paymentMethod.CreditCardNo;
    		}
    		else if(paymentTypeGroup === "CUSTOMER_ACCOUNT"){
    			return paymentMethod.CustomerAccountNo;
    		}
    		else if(paymentTypeGroup === "STORED_VALUE_CARD"){
    			return paymentMethod.SvcNo;
    		}
    		else if(paymentTypeGroup === "OTHER"){
    			return paymentMethod.PaymentReference1;
    		}
    		else if(paymentTypeGroup === "DEBIT_CARD"){
    			return paymentMethod.DebitCardNo;
    		}
    	}
    };
    
    /**
	 * @ngdoc method
	 * @name iscPayment#prepareSuccessMessagePopupData
	 * @description Traverses through the output Order Model after success of Payment processing, and prepares a model object for success popup by setting the Order and Payment details.
	 * 
	 * @param {object} orderModel Order Model object with all the payment method details.
	 * @param {object} paymentTypeList List model of the payment types list, which is the mashup UI output model for getPaymentTypeList API
	 * @param {object} paymentCardTypeList List model of the payment card types (or credit card types) list, which is the mashup UI output model for getPaymentCardTypeList API
	 * @param {Boolean} isReatTimeAuthEnabled Real time authorization turned on or not.
	 * 
	 */
    paymentService.prepareSuccessMessagePopupData = function(orderModel,paymentTypeList,paymentCardTypeList,isReatTimeAuthEnabled){
    	var returnObj = {};
    	returnObj.order = angular.copy(orderModel);
    	returnObj.paymentDetails = {};
    	returnObj.paymentDetails.paymentDetail = [];
    	var orderDocType = orderModel.Order.DocumentType;
    	var exchangeType = orderModel.Order.ExchangeType;
    	var isExchangeOrder = false;
    	var isReturnOrder = false;
    	var isSalesOrder = false;
    	if(orderDocType === '0003'){
    		isReturnOrder = true;
    	}
    	else if(orderDocType === '0001'){
    		if(!iscObjectUtility.isEmpty(exchangeType)){
    			isExchangeOrder = true;
    		}
    		else{
    			isSalesOrder = true;
    		}
    	}
    	returnObj.isExchangeOrder = isExchangeOrder;
    	returnObj.isSalesOrder = isSalesOrder;
    	returnObj.isReturnOrder = isReturnOrder;
    	var paymentMethods = returnObj.order.Order.PaymentMethods;
		if(paymentMethods && paymentMethods.PaymentMethod && paymentMethods.PaymentMethod.length > 0){
			returnObj.paymentMethodsAvailable = true;
			for(var p=0; p < paymentMethods.PaymentMethod.length; p++){
				var paymentMethod = paymentMethods.PaymentMethod[p];
				var paymentMethodType = paymentMethod.PaymentType;
				var totalAuthorizedAmt = paymentMethod.TotalAuthorized;
				var totalChargedAmt = paymentMethod.TotalCharged;
				var totalRefundedAmt = paymentMethod.TotalRefundedAmount;
				var plannedRefundAmt = paymentMethod.PlannedRefundAmount;
				var maxChargeLimitAmt = paymentMethod.MaxChargeLimit;
				var paymentAccNo = paymentMethod.DisplayPrimaryAccountNo;
				var paymentType = paymentService.getPaymentTypeDetails(paymentMethodType,paymentTypeList);
				var paymentTypeGroup = paymentType.PaymentTypeGroup;
				var paymentTypeDescription = paymentType.PaymentTypeDescription;
				var newPayment = {};
				if(paymentService.isPaymentMethodSuspended(paymentMethod,orderDocType) && (parseFloat(totalChargedAmt) == 0) && (parseFloat(totalAuthorizedAmt) == 0)){
					//ignore this payment method, since there was nothing authorized or charged on this and it is suspended anyways
				}
				else{
					if(paymentTypeGroup === 'CREDIT_CARD'){
						var creditCardType = paymentService.getPaymentCardTypeDescription(paymentMethod.CreditCardType, paymentCardTypeList);
						//newPayment.PaymentDescription = creditCardType + ' - ' + paymentAccNo;
						var paymentCardTypeDescription = iscI18n.translate("payment.LABEL_CreditCardDescription",{cardType:creditCardType,paymentType:paymentTypeDescription});
						newPayment.PaymentDescription = iscI18n.translate("globals.LABEL_creditcardpaymentMethod",{creditCardType:paymentCardTypeDescription,paymentAccNo:paymentAccNo});
					}
					else {
						//newPayment.PaymentDescription = paymentTypeDescription + ' - ' + paymentAccNo;
						newPayment.PaymentDescription = iscI18n.translate("globals.LABEL_otherpaymentMethod",{paymentType:paymentTypeDescription,paymentAccNo:paymentAccNo});
					}
					if(isReturnOrder){
						if(parseFloat(totalRefundedAmt) > 0){
							newPayment.PaymentAmount = totalRefundedAmt;
						}
						else {
							newPayment.PaymentAmount = plannedRefundAmt;
						}
					}
					else if(isExchangeOrder || isSalesOrder){
						if(parseFloat(totalChargedAmt) > 0){
							if (parseFloat(totalAuthorizedAmt) > 0){
								var totalPaidAmt = parseFloat(totalChargedAmt) + parseFloat(totalAuthorizedAmt);
								totalPaidAmt = totalPaidAmt.toFixed(2);
								newPayment.PaymentAmount = totalPaidAmt.toString();
							}
							else {
								newPayment.PaymentAmount = totalChargedAmt;
							}
						}
						else if (parseFloat(totalAuthorizedAmt) > 0){
							newPayment.PaymentAmount = totalAuthorizedAmt;
						}
						else {
							newPayment.PaymentAmount = maxChargeLimitAmt;
							newPayment.ChargePending = 'Y';
							//if(isReatTimeAuthEnabled){
								//newPayment.ChargePending = 'Y';
							//}
							//else{
								//newPayment.PaymentAmount = maxChargeLimitAmt;
							//}
						}
					}
					if(parseFloat(newPayment.PaymentAmount) > 0){
						returnObj.paymentDetails.paymentDetail[returnObj.paymentDetails.paymentDetail.length] = newPayment;
					}
				}
			}
		}
		else{
			returnObj.paymentMethodsAvailable = false;
		}
		return returnObj;
    };
	
	paymentService.prepareShipmentPaymentData = function(shipmentModel,paymentTypeList,paymentCardTypeList) {
		
		var returnObj = {};
		returnObj.paymentDetails = {};
    	returnObj.paymentDetails.paymentDetail = [];
		
		for(var i=0; i<shipmentModel.Shipment.ShipmentLines.ShipmentLine.length; i++) {
			var shipmentLine = shipmentModel.Shipment.ShipmentLines.ShipmentLine[i];
			var paymentMethods = shipmentLine.OrderLine.Order.PaymentMethods;
			var currencySign = shipmentLine.OrderLine.Order.PriceInfo.Currency;
			
			if(paymentMethods && paymentMethods.PaymentMethod && paymentMethods.PaymentMethod.length > 0){
				returnObj.paymentMethodsAvailable = true;
				for(var p=0; p < paymentMethods.PaymentMethod.length; p++){
					var paymentMethod = paymentMethods.PaymentMethod[p];
					var paymentMethodType = paymentMethod.PaymentType;
					var totalAuthorizedAmt = paymentMethod.TotalAuthorized;
					var totalChargedAmt = paymentMethod.TotalCharged;
					var totalRefundedAmt = paymentMethod.TotalRefundedAmount;
					var plannedRefundAmt = paymentMethod.PlannedRefundAmount;
					var maxChargeLimitAmt = paymentMethod.MaxChargeLimit;
					var paymentAccNo = paymentMethod.DisplayPrimaryAccountNo;
					var paymentType = paymentService.getPaymentTypeDetails(paymentMethodType,paymentTypeList);
					var paymentTypeGroup = paymentType.PaymentTypeGroup;
					var paymentTypeDescription = paymentType.PaymentTypeDescription;
					var newPayment = {};
					newPayment.Currency = currencySign;
					
					if(paymentTypeGroup === 'CREDIT_CARD'){
						var creditCardType = paymentService.getPaymentCardTypeDescription(paymentMethod.CreditCardType, paymentCardTypeList);
						var paymentCardTypeDescription = iscI18n.translate("payment.LABEL_CreditCardDescription",{cardType:creditCardType,paymentType:paymentTypeDescription});
						newPayment.PaymentDescription = iscI18n.translate("globals.LABEL_creditcardpaymentMethod",{creditCardType:paymentCardTypeDescription,paymentAccNo:paymentAccNo});
					} else {
						newPayment.PaymentDescription = iscI18n.translate("globals.LABEL_otherpaymentMethod",{paymentType:paymentTypeDescription,paymentAccNo:paymentAccNo});
					}
					
					if(parseFloat(totalChargedAmt) > 0){
						if (parseFloat(totalAuthorizedAmt) > 0){
							var totalPaidAmt = parseFloat(totalChargedAmt) + parseFloat(totalAuthorizedAmt);
							totalPaidAmt = totalPaidAmt.toFixed(2);
							newPayment.PaymentAmount = totalPaidAmt.toString();
						} else {
							newPayment.PaymentAmount = totalChargedAmt;
						}
					} else if (parseFloat(totalAuthorizedAmt) > 0){
						newPayment.PaymentAmount = totalAuthorizedAmt;
					} else {
						newPayment.PaymentAmount = maxChargeLimitAmt;
						
					}
					
					if(parseFloat(newPayment.PaymentAmount) > 0){
						var isPaymentAlreadyAdded = paymentService.existsInArray(returnObj,newPayment)
						if(!isPaymentAlreadyAdded) {
							returnObj.paymentDetails.paymentDetail[returnObj.paymentDetails.paymentDetail.length] = newPayment;
						}
					}
				}
			} else{
				returnObj.paymentMethodsAvailable = false;
			}
		}
		
		return returnObj;
	};
	
	paymentService.existsInArray = function(parentArray, newElement) {
		var isPaymentAlreadyAdded = false;
		for(var i=0; i< parentArray.paymentDetails.paymentDetail.length; i++) {
			var currentParentElement = parentArray.paymentDetails.paymentDetail[i];
			if(currentParentElement.PaymentDescription == newElement.PaymentDescription && currentParentElement.PaymentAmount == newElement.PaymentAmount) {
				isPaymentAlreadyAdded = true;
				break;
			}
		}
		return isPaymentAlreadyAdded;
	};
	
    /**
	 * @ngdoc method
	 * @name iscPayment#getPaymentMethodForKey
	 * @description Traverses through the Order Model object to fetch the PaymentMethod for a particular PaymentKey.
	 * 
	 * @param {object} orderModel Order Model object with all the payment method details.
	 * @param {String} paymentKey PaymentKey for the payment method
	 * 
	 */
    paymentService.getPaymentMethodForKey = function(orderModel, paymentKey){
    	if(orderModel.Order && orderModel.Order.PaymentMethods && orderModel.Order.PaymentMethods.PaymentMethod){
			for(var sp=0; sp < orderModel.Order.PaymentMethods.PaymentMethod.length; sp++){
				var paymentMethod = orderModel.Order.PaymentMethods.PaymentMethod[sp];
				var paymentMethodKey = paymentMethod.PaymentKey;
				if(paymentMethodKey && paymentKey && paymentMethodKey === paymentKey){
					return paymentMethod;
				}
			}
    	}
    	return null;
    };
    /**
	 * @ngdoc method
	 * @name iscPayment#validateExpirationDate
	 * @description Validates the user input expiration date value for formats and past date (validation) and sets the validity on the form field for the same.
	 * 
	 * @param {String} enteredExpDate User input expiration date
	 * @param {obj} formField Form field object for the expiration date field to set the validtity
	 * 
	 */
    paymentService.validateExpirationDate = function(enteredExpDate, formField){
	 	var regexPattern = new RegExp("^[0-9]{2}/[0-9]{4}$");
	 	if(enteredExpDate){
	 		if(enteredExpDate && !regexPattern.test(enteredExpDate)){
				formField.$setValidity("expdatepattern", false);
				formField.$setValidity("pastDate", true);
				formField.$setValidity("validMonth", true);
			}
			else {
				formField.$setValidity("expdatepattern", true);
				var monthYear = enteredExpDate.split('/');
		 		var month = parseInt(monthYear[0]);
		 		var year = parseInt(monthYear[1]);
		 		var currentDate = new Date();
				var currentYear = parseInt(currentDate.getFullYear().toString().substring(4));
				var currentMonth = (currentDate.getMonth() + 1);
				if(month > 12){
					formField.$setValidity("validMonth", false);
				}
				else if(year < currentYear){
					formField.$setValidity("pastDate", false);
				}
				else if(year == currentYear && month < currentMonth){
					formField.$setValidity("pastDate", false);
				}
				else {
					formField.$setValidity("pastDate", true);
					formField.$setValidity("validMonth", true);
				}
			}
	 		
	 	}
	 	else {
	 		formField.$setValidity("pastDate", true);
	 		formField.$setValidity("validMonth", true);
	 		formField.$setValidity("expdatepattern", true);
	 	}
	 };
	 /**
	 * @ngdoc method
	 * @name iscPayment#isPaymentExpired
	 * @description Validates the order/return payment method expiration if any.
	 * 
	 * @param {object} paymentMethod Payment method model object
	 * @param {Boolean} paymentEncryptEnabled whether encryption is enabled on payment attributes
 	 * 
	 */
    paymentService.isPaymentExpired = function(paymentMethod, paymentEncryptEnabled){
	 	var regexPattern = new RegExp("^[0-9]{2}/[0-9]{4}$");
	 	if(paymentMethod && paymentMethod.PaymentTypeGroup === 'CREDIT_CARD' && paymentMethod.CreditCardExpDate){
	 		var expDate = paymentMethod.CreditCardExpDate;
	 		if(expDate){
	 			if(paymentEncryptEnabled && expDate === "**/****"){
	 				if(paymentMethod.UnEncryptedCreditCardExpDate){
	 					expDate = paymentMethod.UnEncryptedCreditCardExpDate;
	 				}
	 				else {
	 					return false;
	 				}
	 			}
		 		if(expDate && !regexPattern.test(expDate)){
		 			if(paymentEncryptEnabled && paymentMethod.UnEncryptedCreditCardExpDate){
		 				paymentMethod.CreditCardExpDate = paymentMethod.UnEncryptedCreditCardExpDate;
		 			}
					return true;
				}
				else {
					var monthYear = expDate.split('/');
			 		var month = parseInt(monthYear[0]);
			 		var year = parseInt(monthYear[1]);
			 		var currentDate = new Date();
					var currentYear = parseInt(currentDate.getFullYear().toString().substring(4));
					var currentMonth = (currentDate.getMonth() + 1);
					if(month > 12){
						if(paymentEncryptEnabled && paymentMethod.UnEncryptedCreditCardExpDate){
			 				paymentMethod.CreditCardExpDate = paymentMethod.UnEncryptedCreditCardExpDate;
			 			}
						return true;
					}
					else if(year < currentYear){
						if(paymentEncryptEnabled && paymentMethod.UnEncryptedCreditCardExpDate){
			 				paymentMethod.CreditCardExpDate = paymentMethod.UnEncryptedCreditCardExpDate;
			 			}
			 			return true;
					}
					else if(year == currentYear && month < currentMonth){
						if(paymentEncryptEnabled && paymentMethod.UnEncryptedCreditCardExpDate){
			 				paymentMethod.CreditCardExpDate = paymentMethod.UnEncryptedCreditCardExpDate;
			 			}
			 			return true;
					}
					else {
						return false;
					}
				}
		 		
		 	}
		 	else {
		 		return false;
		 	}
	 	}
	 	else {
	 		return false;
	 	}
	 	
	 };
	 /**
	 * @ngdoc method
	 * @name iscPayment#isPaymentMethodSuspended
	 * @description Traverses through the Payment Method model object and determines whether the Payment method is suspended for any charges
	 * 			by checking the attribute SuspendAnyModeCharges.
	 * 
	 * @param {object} paymentMethod Payment method model object
	 * @param {String} orderDocType Document type of the order if applicable
	 * 
	 */
    paymentService.isPaymentMethodSuspended = function(paymentMethod,orderDocType){
    	if((paymentMethod && 'B' == paymentMethod.SuspendAnyMoreCharges) 
    		|| (paymentMethod && 'Y' == paymentMethod.SuspendAnyMoreCharges 
    				&& (!orderDocType || (orderDocType && orderDocType === '0001')))){
    		return true;
    	}
    	return false;
    };    
    /**
	 * @ngdoc method
	 * @name iscPayment#getAwtAuthNChrgAmtOnSuspndedPmts
	 * @description Traverses through the Payment Methods model object and determines whether the Payment method is suspended for any charges
	 * 			by checking the attribute SuspendAnyModeCharges and adds any AwaitingAuthInterfaceAmount and/or AwaitingChargeInterfaceAmount on that payment.
	 * 			It returns a cumulative sum of all AwaitingAuthInterfaceAmount and AwaitingChargeInterfaceAmount on all suspended payments.
	 * 
	 * @param {object} paymentMethods Payment methods model object with Payment method array
	 * 
	 */
    paymentService.getAwtAuthNChrgAmtOnSuspndedPmts = function(paymentMethods,orderDocType){
    	var finalAmount = 0;
    	if(paymentMethods && paymentMethods.PaymentMethod && paymentMethods.PaymentMethod.length){
	    	for(var sp=0; sp < paymentMethods.PaymentMethod.length; sp++){
				var paymentMethod = paymentMethods.PaymentMethod[sp];
				if(paymentService.isPaymentMethodSuspended(paymentMethod,orderDocType)){
					var awaitAuthAmt = paymentMethod.AwaitingAuthInterfaceAmount;
					var awaitChrgAmt = paymentMethod.AwaitingChargeInterfaceAmount;
					if(parseFloat(awaitAuthAmt) > 0){
						finalAmount = finalAmount + parseFloat(awaitAuthAmt);
					}
					if(parseFloat(awaitChrgAmt) > 0){
						finalAmount = finalAmount + parseFloat(awaitChrgAmt);
					}
				}
			}
    	}
    	return finalAmount.toFixed(2);
    };    
    /**
	 * @ngdoc method
	 * @name iscPayment#calculatePlannedRefundAmountToDisplay
	 * @description Calculates the PlannedRefundAmount to display on a return payment method which has some AwaitingAuthInterfaceAmount and/or AwaitingChargeInterfaceAmount on that payment.
	 * 
	 * @param {object} paymentMethod Payment methods model object
	 * 
	 */
    paymentService.calculatePlannedRefundAmountToDisplay = function(paymentMethod){
		var awaitAuthAmt = paymentMethod.AwaitingAuthInterfaceAmount;
		var awaitChrgAmt = paymentMethod.AwaitingChargeInterfaceAmount;
		var totalRefundedAmount = paymentMethod.TotalRefundedAmount ? paymentMethod.TotalRefundedAmount : "0";
		var plannedRefundAmount = paymentMethod.PlannedRefundAmount ? paymentMethod.PlannedRefundAmount : "0";
		plannedRefundAmount = parseFloat(plannedRefundAmount);
		if(parseFloat(awaitAuthAmt) < 0){
			plannedRefundAmount = plannedRefundAmount - parseFloat(awaitAuthAmt);
		}
		if(parseFloat(awaitChrgAmt) < 0){
			plannedRefundAmount = plannedRefundAmount - parseFloat(awaitChrgAmt);
		}
		if(parseFloat(totalRefundedAmount) > 0){
			plannedRefundAmount = plannedRefundAmount + parseFloat(totalRefundedAmount);
		}
    	return plannedRefundAmount.toFixed(2);
    };    
    /**
	 * @ngdoc method
	 * @name iscPayment#calculateRemainingAmountToAdd
	 * @description Calculate remainingAmountToAdd in UI where there are some saved paymentMethods on Order and some un-saved 
	 * 				payment methods in UI.
	 * 
	 * @param {object} orderModel Order Model object with all the payment method details.
	 * @param {object} newPaymentMethods Unsaved Payment methods model array object
	 * 
	 */
    paymentService.calculateRemainingAmountToAdd = function(orderModel,newPaymentMethodArray){
    	var remainingAmountToAuth = orderModel.Order.ChargeTransactionDetails.RemainingAmountToAuth;
    	var suspndAwtAmt = 0;
    	if(orderModel && orderModel.Order && orderModel.Order.PaymentMethods){
    		suspndAwtAmt = paymentService.getAwtAuthNChrgAmtOnSuspndedPmts(orderModel.Order.PaymentMethods,orderModel.Order.DocumentType);
    	}
    	var unsavedPmtAmtAdded = 0;
    	if(newPaymentMethodArray && newPaymentMethodArray.length){
	    	for(var sp=0; sp <newPaymentMethodArray.length; sp++){
				var paymentMethod = newPaymentMethodArray[sp];
				var reqAmt = paymentMethod.RequestedAmount;
				unsavedPmtAmtAdded = parseFloat(unsavedPmtAmtAdded) + parseFloat(reqAmt);
				unsavedPmtAmtAdded = unsavedPmtAmtAdded.toFixed(2);
			}
    	}
		var finalRemainingAmt = parseFloat(remainingAmountToAuth) + parseFloat(suspndAwtAmt) - parseFloat(unsavedPmtAmtAdded);
    	return finalRemainingAmt.toFixed(2);
    };
 
   return paymentService;
 }]);




/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/

/**
 * @ngdoc service
 * @name iscPaymentinput
 * @requires $http
 * @requires $q
 * @requires iscAppInfo
 * @requires iscModal
 * @requires iscI18n
 * @requires $rootScope
 * @requires iscObjectUtility
 * @requires iscPayment
 * @requires iscOrder
 * 
 * @description 
 * Handles all the common tasks related to preparing input model objects for making any mashup calls related to Payment Capture. 
 * 
 */

angular.module('isc.shared').factory(
		'iscPaymentinput',
		['$http', '$q', 'iscAppInfo', 'iscModal', 'iscI18n', '$rootScope', 'iscObjectUtility', 'iscPayment', 'iscOrder',
				function($http, $q, iscAppInfo, iscModal, iscI18n, $rootScope, iscObjectUtility, iscPayment, iscOrder) {

					var paymentinputService = {};
					 /**
					 * @ngdoc method
					 * @name iscPaymentinput#prepareGetFundsAvailableUEInput
					 * @description Traverses through the paymentMethod model, to prepare input to getFundsAvailable user exit call
					 * 
					 * @param {object} originalPaymentMethod Payment method model object 
					 * 
					 */
					paymentinputService.prepareGetFundsAvailableUEInput = function(
							originalPaymentMethod) {
						var paymentMethodInput = {};
						var paymentMethod = angular.copy(originalPaymentMethod);
						paymentMethodInput.PaymentType = paymentMethod.PaymentType;
						paymentMethodInput.PaymentTypeGroup = paymentMethod.PaymentTypeGroup;
						if (paymentMethod.PaymentTypeGroup === 'CREDIT_CARD') {
							paymentMethodInput.CreditCardExpDate = paymentMethod.CreditCardExpDate;
							paymentMethodInput.CreditCardNo = paymentMethod.CreditCardNo;
							if (paymentMethod.SecureAuthenticationCode) {
								paymentMethodInput.SecureAuthenticationCode = paymentMethod.SecureAuthenticationCode;
							}
							paymentMethodInput.CreditCardType = paymentMethod.CardType.PaymentCardType;
							if (paymentMethod.CreditCardName) {
								paymentMethodInput.CreditCardName = paymentMethod.CreditCardName;
							} else {
								paymentMethodInput.FirstName = paymentMethod.FirstName;
								paymentMethodInput.LastName = paymentMethod.LastName;
							}
							paymentMethodInput.PrimaryAccountNo = paymentMethod.CreditCardNo;
						} else if (paymentMethod.PaymentTypeGroup === 'CUSTOMER_ACCOUNT') {
							paymentMethodInput.CustomerAccountNo = paymentMethod.CustomerAccountNo;
							paymentMethodInput.PrimaryAccountNo = paymentMethod.CustomerAccountNo;
						} else if (paymentMethod.PaymentTypeGroup === 'STORED_VALUE_CARD') {
							paymentMethodInput.SvcNo = paymentMethod.SvcNo;
							paymentMethodInput.PaymentReference1 = paymentMethod.PaymentReference1;
							paymentMethodInput.PaymentReference2 = paymentMethod.PaymentReference2;
							paymentMethodInput.PaymentReference3 = paymentMethod.PaymentReference3;
							paymentMethodInput.PrimaryAccountNo = paymentMethod.SvcNo;
						} else if (paymentMethod.PaymentTypeGroup === 'OTHER') {
							paymentMethodInput.PrimaryAccountNo = paymentMethod.PaymentReference1;
							if (paymentMethod.PaymentType == 'CHECK'
									|| paymentMethod.PaymentType == 'REFUND_CHECK') {
								paymentMethodInput.PaymentReference1 = paymentMethod.PaymentReference1;
								paymentMethodInput.PaymentReference2 = paymentMethod.PaymentReference2;
								paymentMethodInput.CheckNo = paymentMethod.CheckNo;
							} else if (paymentMethod.PaymentType == 'PRE_PAID') {
								paymentMethodInput.PaymentReference1 = paymentMethod.PaymentReference1;
								paymentMethodInput.PaymentReference2 = paymentMethod.PaymentReference2;
								paymentMethodInput.PaymentReference3 = paymentMethod.PaymentReference3;
							} else {
								paymentMethodInput.PaymentReference1 = paymentMethod.PaymentReference1;
								paymentMethodInput.PaymentReference2 = paymentMethod.PaymentReference2;
								paymentMethodInput.PaymentReference3 = paymentMethod.PaymentReference3;
							}
						}
						return paymentMethodInput;
					};
					/**
					 * @ngdoc method
					 * @name iscPaymentinput#getCountryListInput
					 * @description Prepares input to getCountryList API call
					 * 
					 * @param {object} orderModel Order model object 
					 * 
					 */
					paymentinputService.getCountryListInput = function(
							orderModel) {
						var apiInput = {};
						apiInput.CommonCode = {};
						return apiInput;
					};
					/**
					 * @ngdoc method
					 * @name iscPaymentinput#getCurrencyListInput
					 * @description Prepares input to getCurrencyList API call
					 * 
					 * @param {object} orderModel Order model object 
					 * 
					 */
					paymentinputService.getCurrencyListInput = function(
							orderModel) {
						var apiInput = {};
						apiInput.Currency = {};
						return apiInput;
					};
					/**
					 * @ngdoc method
					 * @name iscPaymentinput#getRuleDetailsInput
					 * @description Prepares input to getRuleDetails API call
					 * 
					 * @param {object} orderModel Order model object 
					 * 
					 */
					paymentinputService.getRuleDetailsInput = function(
							orderModel) {
						var apiInput = {};
						apiInput.Rules = {};
						return apiInput;
					};
					/**
					 * @ngdoc method
					 * @name iscPaymentinput#getPaymentTypeListInput
					 * @description Prepares input to getPaymentTypeList API call
					 * 
					 * @param {object} orderModel Order model object 
					 * 
					 */
					paymentinputService.getPaymentTypeListInput = function(
							orderModel) {
						var apiInput = {};
						apiInput.PaymentType = {};
						apiInput.PaymentType.CallingEnterpriseCode = orderModel.Order.EnterpriseCode;
						apiInput.PaymentType.CallingSellerOrganizationCode = orderModel.Order.SellerOrganizationCode;
						return apiInput;
					};
					
					paymentinputService.getPaymentTypeListInputForShipment = function(
							shipmentModel) {
						var apiInput = {};
						apiInput.PaymentType = {};
						apiInput.PaymentType.CallingEnterpriseCode = shipmentModel.Shipment.EnterpriseCode;
						apiInput.PaymentType.CallingSellerOrganizationCode = shipmentModel.Shipment.SellerOrganizationCode;
						return apiInput;
					};
					/**
					 * @ngdoc method
					 * @name iscPaymentinput#getPaymentCardTypeListInput
					 * @description Prepares input to getPaymentCardTypeList API call
					 * 
					 * @param {object} orderModel Order model object 
					 * 
					 */
					paymentinputService.getPaymentCardTypeListInput = function(
							orderModel) {
						var apiInput = {};
						apiInput.PaymentType = {};
						apiInput.PaymentType.CallingOrganizationCode = orderModel.Order.EnterpriseCode;
						apiInput.PaymentType.CallingSellerOrganizationCode = orderModel.Order.SellerOrganizationCode;
						apiInput.PaymentType.CallingEnterpriseCode = orderModel.Order.EnterpriseCode;
						apiInput.PaymentType.DocumentType = orderModel.Order.DocumentType;
						return apiInput;
					};
					
					paymentinputService.getPaymentCardTypeListInputForShipment = function(
							shipmentModel) {
						var apiInput = {};
						apiInput.PaymentType = {};
						apiInput.PaymentType.CallingOrganizationCode = shipmentModel.Shipment.EnterpriseCode;
						apiInput.PaymentType.CallingSellerOrganizationCode = shipmentModel.Shipment.SellerOrganizationCode;
						apiInput.PaymentType.CallingEnterpriseCode = shipmentModel.Shipment.EnterpriseCode;
						apiInput.PaymentType.DocumentType = shipmentModel.Shipment.DocumentType;
						return apiInput;
					};
					/**
					 * @ngdoc method
					 * @name iscPaymentinput#getCompleteOrderDetailsInput
					 * @description Prepares input to getCompleteOrderDetails API call
					 * 
					 * @param {String} orderHeaderKey OrderHeaderKey for the order 
					 * 
					 */
					paymentinputService.getCompleteOrderDetailsInput = function(
							orderHeaderKey) {
						var apiInput = {};
						apiInput.Order = {};
						apiInput.Order.OrderHeaderKey = orderHeaderKey;
						return apiInput;
					};
					/**
					 * @ngdoc method
					 * @name iscPaymentinput#computeRefundsPaymentsInput
					 * @description Prepares input to computeRefundsPaymentsInput API call
					 * 
					 * @param {object} orderModel Order model object 
					 * 
					 */
					paymentinputService.computeRefundPaymentsInput = function(
							orderHeaderKey) {
						var apiInput = {};
						apiInput.Order = {};
						apiInput.Order.OrderHeaderKey = orderHeaderKey;
						return apiInput;
					};
					/**
					 * @ngdoc method
					 * @name iscPaymentinput#prepareCapturePaymentInputForPaymentMethod
					 * @description Prepares input model for a new payment method to pass in the capturePayment API call from the UI model object
					 * 
					 * @param {obj} paymentMethod PaymentMethod model object  
					 * @param {Boolean} realTimeAuthEnabled Real time authorization is turned on or not
					 * @param {Boolean} creditCardNameRuleEnabled Using single field for credit card name rule is turned on or not
					 * 
					 */
					paymentinputService.prepareCapturePaymentInputForPaymentMethod = function(paymentMethod, realTimeAuthEnabled, creditCardNameRuleEnabled, isRefund){
						var returnPaymentMethod = {};
						var newPaymentMethodObj = angular.copy(paymentMethod);
						var isNewPaymentMethod = newPaymentMethodObj.PaymentKey ? false : true;
						var isIncompletePaymentMethod = 'Y' === newPaymentMethodObj.IncompletePaymentType ? true : false;
						if(newPaymentMethodObj.PaymentTypeGroup === 'CREDIT_CARD'){		            		
		            		returnPaymentMethod.CreditCardExpDate = newPaymentMethodObj.CreditCardExpDate;
		            		if(realTimeAuthEnabled){
		            			returnPaymentMethod.SecureAuthenticationCode = newPaymentMethodObj.SecureAuthenticationCode;
		            		}		            		
		            		if(creditCardNameRuleEnabled){
		            			returnPaymentMethod.CreditCardName = newPaymentMethodObj.CreditCardName;
		            		}
		            		else{
		            			returnPaymentMethod.FirstName = newPaymentMethodObj.FirstName;
		            			returnPaymentMethod.LastName = newPaymentMethodObj.LastName;
		            			returnPaymentMethod.CreditCardName = iscPayment.getFormattedName(newPaymentMethodObj.FirstName,newPaymentMethodObj.LastName);
		            		}
	            			returnPaymentMethod.PersonInfoBillTo = newPaymentMethodObj.PersonInfoBillTo;
	            			if(!returnPaymentMethod.PersonInfoBillTo.State){
	            				returnPaymentMethod.PersonInfoBillTo.State = "";
	            			}
	            			else if(returnPaymentMethod.PersonInfoBillTo.State && returnPaymentMethod.PersonInfoBillTo.State.RegionName){
	            				returnPaymentMethod.PersonInfoBillTo.State = returnPaymentMethod.PersonInfoBillTo.State.RegionName;
	            			}
		            		if(isNewPaymentMethod || isIncompletePaymentMethod){
		            			returnPaymentMethod.CreditCardNo = newPaymentMethodObj.CreditCardNo;
		            			returnPaymentMethod.DisplayCreditCardNo = newPaymentMethodObj.DisplayCreditCardNo;
		            			returnPaymentMethod.CreditCardType = newPaymentMethodObj.CardType.PaymentCardType;
		            			returnPaymentMethod.PersonInfoBillTo.PersonInfoKey = "";
		            		}
		            	}
		            	else if(newPaymentMethodObj.PaymentTypeGroup === 'CUSTOMER_ACCOUNT' && (isNewPaymentMethod || isIncompletePaymentMethod)){
		            		returnPaymentMethod.CustomerAccountNo = newPaymentMethodObj.CustomerAccountNo;
		            	}
		            	else if(newPaymentMethodObj.PaymentTypeGroup === 'STORED_VALUE_CARD' && (isNewPaymentMethod || isIncompletePaymentMethod)){
		            		returnPaymentMethod.SvcNo = newPaymentMethodObj.SvcNo;
		            		returnPaymentMethod.PaymentReference1 = newPaymentMethodObj.PaymentReference1;
		            		returnPaymentMethod.PaymentReference2 = newPaymentMethodObj.PaymentReference2;
		            		returnPaymentMethod.PaymentReference3 = newPaymentMethodObj.PaymentReference3;
		            	}
		            	else if(newPaymentMethodObj.PaymentTypeGroup === 'OTHER' && (isNewPaymentMethod || isIncompletePaymentMethod)){
		            		if(newPaymentMethodObj.PaymentType == 'CHECK' || newPaymentMethodObj.PaymentType == 'REFUND_CHECK'){
		            			returnPaymentMethod.PaymentReference1 = newPaymentMethodObj.PaymentReference1;
		            			returnPaymentMethod.PaymentReference2 = newPaymentMethodObj.PaymentReference2;
		            			returnPaymentMethod.CheckNo = newPaymentMethodObj.CheckNo;
		            		}
		            		else if(newPaymentMethodObj.PaymentType == 'PRE_PAID'){
		            			returnPaymentMethod.PaymentReference1 = newPaymentMethodObj.PaymentReference1;
		            			returnPaymentMethod.PaymentReference2 = newPaymentMethodObj.PaymentReference2;
		            			returnPaymentMethod.PaymentReference3 = newPaymentMethodObj.PaymentReference3;
		            		}
		            		else{
		            			returnPaymentMethod.PaymentReference1 = newPaymentMethodObj.PaymentReference1;
		            			returnPaymentMethod.PaymentReference2 = newPaymentMethodObj.PaymentReference2;
		            			returnPaymentMethod.PaymentReference3 = newPaymentMethodObj.PaymentReference3;
		            		}
		            	}
						return returnPaymentMethod;
					};
					/**
					 * @ngdoc method
					 * @name iscPaymentinput#prepareCapturePaymentInputForPaymentMethod
					 * @description Prepares input model for changes to already saved payment method on the order, to pass in the capturePayment API call from the UI model object
					 * 
					 * @param {obj} paymentMethod PaymentMethod model object  
					 * @param {Boolean} realTimeAuthEnabled Real time authorization is turned on or not
					 * @param {Boolean} creditCardNameRuleEnabled Using single field for credit card name rule is turned on or not
					 * 
					 */
					paymentinputService.prepareCapturePaymentInputForSavedPaymentMethod = function(paymentMethod, realTimeAuthEnabled, creditCardNameRuleEnabled, isRefund){
						var newPaymentMethodObj = angular.copy(paymentMethod);
						if(!newPaymentMethodObj.PaymentTypeGroup && (newPaymentMethodObj.PaymentType && newPaymentMethodObj.PaymentType.PaymentTypeGroup) ){
		            		newPaymentMethodObj.PaymentTypeGroup = newPaymentMethodObj.PaymentType.PaymentTypeGroup;
		            		newPaymentMethodObj.PaymentType = newPaymentMethodObj.PaymentType.PaymentType;
		            	}
		            	var originalAmt =  newPaymentMethodObj.MaxChargeLimit;
		            	if(isRefund){
		            		originalAmt =  iscPayment.calculatePlannedRefundAmountToDisplay(newPaymentMethodObj);
		            	}
		            	var updatePaymentObject = {};
		            	if(isRefund){
	            			var awaitAuthAmt = newPaymentMethodObj.AwaitingAuthInterfaceAmount;
							var awaitChrgAmt = newPaymentMethodObj.AwaitingChargeInterfaceAmount;
							var totalRefundedAmount = newPaymentMethodObj.TotalRefundedAmount ? newPaymentMethodObj.TotalRefundedAmount : "0";
							var finalRefundRequestAmount = parseFloat(newPaymentMethodObj.RequestedAmount);
							if(parseFloat(awaitAuthAmt) < 0){
								finalRefundRequestAmount = finalRefundRequestAmount + parseFloat(awaitAuthAmt);
							}
							if(parseFloat(awaitChrgAmt) < 0){
								finalRefundRequestAmount = finalRefundRequestAmount + parseFloat(awaitChrgAmt);
							}
							if(parseFloat(totalRefundedAmount) > 0){
								finalRefundRequestAmount = finalRefundRequestAmount - parseFloat(totalRefundedAmount);
							}
							newPaymentMethodObj.RequestedAmount = finalRefundRequestAmount.toFixed(2);
	            		}
		            	if(newPaymentMethodObj.RequestedAmount && originalAmt != newPaymentMethodObj.RequestedAmount){
			            	updatePaymentObject.RequestedAmount = newPaymentMethodObj.RequestedAmount;
		            	}
		            	else if(!newPaymentMethodObj.RequestedAmount){
		            		updatePaymentObject.RequestedAmount = "0.0";
		            	}
		            	var paymentMethodInput = this.prepareCapturePaymentInputForPaymentMethod(paymentMethod, realTimeAuthEnabled, creditCardNameRuleEnabled, isRefund);
		            	updatePaymentObject = angular.extend(updatePaymentObject,paymentMethodInput);
		            	if(!iscObjectUtility.isEmpty(updatePaymentObject)){
		            		updatePaymentObject.PaymentKey = newPaymentMethodObj.PaymentKey;
		            		updatePaymentObject.IsCorrection = "Y";
		            		updatePaymentObject.RequestedAmount = newPaymentMethodObj.RequestedAmount;
		            		updatePaymentObject.PaymentTypeGroup = newPaymentMethodObj.PaymentTypeGroup;
		            		updatePaymentObject.PaymentType = newPaymentMethodObj.PaymentType;
		            	}
		            	return updatePaymentObject;
					};

					return paymentinputService;
				}]);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp. 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/



/**
 * 
 * @ngdoc service
 * @name iscBarcodeScannerService
 * 
 * @description
 * The iscBarcodeScanner is the core service which facilitates barcode scanning
 */

angular.module('isc.shared').factory('iscBarcodeScanner', ['$q', '$rootScope', 'iscModal','iscI18n', function ($q, $rootScope, iscModal,iscI18n) {

    var iscBarcodeScannerService = {};
    
    var _barcodeListeners = {};
    var _focussedElement = -1;
    
    var _getScanElement = function(){
        if(_focussedElement>-1 && _barcodeListeners[_focussedElement]!== undefined){
            return _barcodeListeners[_focussedElement];
        }
        /*else if(Object.keys(_barcodeListeners).length===1){
            if(_isElementUnderMask(_barcodeListeners[Object.keys(_barcodeListeners)[0]].element)){
               return {callFn:function(){iscModal.showErrorMessage(iscI18n.translate('barcode.MESSAGE_No_barcode_field'))}};
            }
            return _barcodeListeners[Object.keys(_barcodeListeners)[0]];
        }*/
        else if(Object.keys(_barcodeListeners).length>0){
            var primaryFound = false;
            var effectiveBarcodeListeners = {}
            for(var key in _barcodeListeners){
                if(_isElementUnderMask(_barcodeListeners[key].element)){
                    continue;
                }
                effectiveBarcodeListeners[key] = _barcodeListeners[key];
            }
            if(Object.keys(effectiveBarcodeListeners).length===1){
                return effectiveBarcodeListeners[Object.keys(effectiveBarcodeListeners)[0]];
            }
            else if(Object.keys(effectiveBarcodeListeners).length>1){
                for(var key in effectiveBarcodeListeners){
                    if(effectiveBarcodeListeners[key].type==="PRIMARY"){
                        primaryFound = true;
                        return effectiveBarcodeListeners[key];
                    }
                }
            }

            if(Object.keys(effectiveBarcodeListeners).length === 0){
                return {callFn:function(){iscModal.showErrorMessage(iscI18n.translate('barcode.MESSAGE_No_barcode_field'))}};
            }
            if(!primaryFound){
                return {callFn:function(){iscModal.showErrorMessage(iscI18n.translate('barcode.MESSAGE_Multiple_barcode_field'))}};
            }
        }
        else{
            return {callFn:function(){iscModal.showErrorMessage(iscI18n.translate('barcode.MESSAGE_No_barcode_field'))}};
        }
        
        
        
    }
    
    var _isElementUnderMask = function(element){
        var bd = null;
        bd = getEffectiveMask('[class*=-backdrop]',bd);
        //bd = getEffectiveMask('.modal-backdrop',bd);
        //bd = getEffectiveMask('.modal-lookup-backdrop',bd);
        //bd = getEffectiveMask('.minicart-popover-backdrop',bd);
        //var bd = document.querySelectorAll('.modal-lookup-backdrop')[0];
        if(bd===null){
            return false;
        }
        var maskRect = bd.getBoundingClientRect();
        var elementRect = element[0].getBoundingClientRect();
        if(window.getComputedStyle(bd)['z-index'] > window.getEffectiveZIndex(element[0])
            && elementRect.left > maskRect.left && elementRect.left < maskRect.right
            && elementRect.right > maskRect.left && elementRect.right < maskRect.right
            && elementRect.top > maskRect.top && elementRect.top < maskRect.bottom
            && elementRect.bottom > maskRect.top && elementRect.bottom < maskRect.bottom
          ){
            return true;
        }
        else{
            return false;
        }
        
        
    }
    //
    window.getEffectiveMask = function(cssClassName,bd,bdStyle){
        var bdStyle = null;
        if(bd!==null){
            bdStyle = window.getComputedStyle(bd);
        }
        var bdArray = document.querySelectorAll(cssClassName);
        for(var i=0;i<bdArray.length;i++){
            var bdTempStyle = window.getComputedStyle(bdArray[i]);
            console.log(bdTempStyle['display']);
            console.log(bdTempStyle['z-index']);
            if(bdTempStyle['display']==='none'){
                continue;
            }
            else if(bdStyle!==null && bdTempStyle['z-index']!=='auto' && parseInt(bdTempStyle['z-index']) > parseInt(bdStyle['z-index'])){
                bd = bdArray[i];
                bdStyle = bdTempStyle;
            }
            else if(bdStyle===null){
                bd = bdArray[i];
                bdStyle = bdTempStyle;
            }
        }
        return bd;
    }

    
    window.getEffectiveZIndex = function getEffectiveZIndex(elm) {
        var elementZIndex,
            style,
            zindex = 0,
            effectiveZIndex = 0;
        while(elm) {
            style = getComputedStyle(elm);

            if (style) {
                elementZIndex = parseInt(style.getPropertyValue('z-index'), 10);

                if (elementZIndex > zindex) {
                    zindex = elementZIndex;
                    effectiveZIndex+=zindex;
                }
            }
            if(style.getPropertyValue('position')==='absolute'){
                break;
            }
            if(elm.parentNode.nodeType === 1){
                elm = elm.parentNode;
            }
            else{
                break;
            }

        }

        return effectiveZIndex;
    }
    
    iscBarcodeScannerService._onScanElementFocussed = function(id){
        //console.log("Element focussed "+id);
        _focussedElement = id;
    }
    
    iscBarcodeScannerService._onScanElementBlurred = function(id){
        //console.log("Element blurred "+id);
        _focussedElement = -1;
    }
    
    iscBarcodeScannerService._addElement = function(id,handler){
        _barcodeListeners[id]=handler;
        //console.log("adding registry "+id );
        
    }

    iscBarcodeScannerService._removeElement = function(id){
        delete _barcodeListeners[id];
        if(_focussedElement === id){
            _focussedElement = -1;
        }
        //console.log("removing from registry" + id);
    }
    
    iscBarcodeScannerService._scan = function (config) {
        var q = $q.defer();

        cordova.plugins.barcodeScanner.scan(function (result) {
            if (!result.cancelled) {
                q.resolve(result.text);
            } else {
                q.reject(err);
            }
        }, function (err) {
            q.reject(err);
        }, config);

        return q.promise;
    }

    /*
     * @ngdoc method
     * @name iscBarcodeScannerService#scanToElement
     * @description The scanToElement methods triggers barcode scanning and places the barcode data in the availabe input scan fields when the barcode is recieved
     * 
     * @param {obect} config Optional config object
     */
    iscBarcodeScannerService.scanToElement = function (config) {
        iscBarcodeScannerService._scan(config)
            .then(function (barcodeText) {
                _getScanElement().callFn(barcodeText);
            }, function (err) {
                iscModal.showErrorMessage(iscI18n.translate('globals.MSG_InvalidBarCodeData'));

            });
    }

    /*
     * @ngdoc method
     * @name iscBarcodeScannerService#scanAndFireEvent
     * @description The scanAndFireEvent methods triggers barcode scanning and fires 'BarcodeScanned' when the barcode is recieved
     * 
     * @param {obect} config Optional config object
     */
    iscBarcodeScannerService.scanAndFireEvent = function (config) {
        iscBarcodeScannerService._scan(config)
            .then(function (barcodeText) {
                $rootScope.$broadcast("BarcodeScanned", barcodeText);
            }, function (err) {
                iscModal.showErrorMessage(iscI18n.translate('globals.MSG_InvalidBarCodeData'));

            });
    }
    
    /**
     * @ngdoc method
     * @name iscBarcodeScannerService#placeBarcodeToElement
     * @description The scanToElement methods places the barcode data in the availabe input scan fields when the barcode is recieved
     * 
     * @param {String} barcodeData Barcode data
     */
    iscBarcodeScannerService.placeBarcodeToElement = function(barcodeData){
    	_getScanElement().callFn(barcodeData);
    }
    /*
     * @ngdoc method
     * @name iscBarcodeScannerService#fireEventWithBarcode
     * @description The fireEventWithBarcode methods fires 'BarcodeScanned' when the barcode is recieved
     * 
     * @param {String} data BarcodeCode data
     */
    iscBarcodeScannerService.fireEventWithBarcode = function(data){
    	$rootScope.$broadcast("BarcodeScanned", data);
    }
    
    /*iscBarcodeScannerService.encode = function (type, data) {
        var q = $q.defer();
        type = type || 'TEXT_TYPE';

        cordova.plugins.barcodeScanner.encode(type, data, function (result) {
            q.resolve(result);
        }, function (err) {
            q.reject(err);
        });

        return q.promise;
    }*/
    return iscBarcodeScannerService;
  }]);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp. 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/

angular.module('isc.shared').factory('iscPortletService', ['iscPortletPvdr', 'iscPersona', function(iscPortletPvdr, iscPersona) {
	
	var iscPortletService = {};
	
	var _fn_validateAndGetCustomPortlets_newSpec = function(portletName, portletDefJson) {
		// Not doing trim() on strings to check for empty.
		var responseJson = {
			"hasError": false,
			"portletName": portletName
		};
		var oldSpecResponseJson = _fn_validateAndGetCustomPortlets_oldSpec(portletName, portletDefJson, true);
		angular.merge(responseJson, oldSpecResponseJson);
		var personaConfigJson = portletDefJson["personaConfig"];
		if (iscCore.isVoid(personaConfigJson["personaName"]) || typeof personaConfigJson["personaName"] != "string") {
			responseJson["hasError"] = true;
			responseJson["personaConfig.personaName"] = true;
		}
		if (iscCore.isVoid(personaConfigJson["personaSequenceNumber"]) || typeof personaConfigJson["personaSequenceNumber"] != "number") {
			responseJson["hasError"] = true;
			responseJson["personaConfig.personaSequenceNumber"] = true;
		}
		if (iscCore.isVoid(personaConfigJson["miniViewTemplateUrl"]) || typeof personaConfigJson["miniViewTemplateUrl"] != "string") {
			responseJson["hasError"] = true;
			responseJson["personaConfig.miniViewTemplateUrl"] = true;
		}
		if (iscCore.isVoid(personaConfigJson["miniViewController"]) || typeof personaConfigJson["miniViewController"] != "string") {
			responseJson["hasError"] = true;
			responseJson["personaConfig.miniViewController"] = true;
		}
		return responseJson;
	};
	// Can't put validation on registration, as registries would be getting populated. Thus, need to add it downstream only.
	var _fn_validateAndGetCustomPortlets_oldSpec = function(portletName, portletDefJson, skipSeqNumChk) {
		// Not doing trim() on strings to check for empty.
		var responseJson = {
			"hasError": false,
			"portletName": portletName
		};
		//templateUrl, controller, sequenceNumber, showPortlet, resourceId
		if (iscCore.isVoid(portletDefJson["templateUrl"]) || typeof portletDefJson["templateUrl"] != "string") {
			responseJson["hasError"] = true;
			responseJson["templateUrl"] = true;
		}
		if (iscCore.isVoid(portletDefJson["controller"]) || typeof portletDefJson["controller"] != "string") {
			responseJson["hasError"] = true;
			responseJson["controller"] = true;
		}
		if (!skipSeqNumChk && (iscCore.isVoid(portletDefJson["sequenceNumber"]) || typeof portletDefJson["sequenceNumber"] != "number")) {
			responseJson["hasError"] = true;
			responseJson["sequenceNumber"] = true;
		}
		if (iscCore.isVoid(portletDefJson["showPortlet"]) || typeof portletDefJson["showPortlet"] != "boolean") {
			responseJson["hasError"] = true;
			responseJson["showPortlet"] = true;
		}
		if (iscCore.isVoid(portletDefJson["resourceId"]) || typeof portletDefJson["resourceId"] != "string") {
			responseJson["hasError"] = true;
			responseJson["resourceId"] = true;
		}
		return responseJson;
	};
	
	var _fn_validateAndOverrideAvailableProperties = function(name, ootb_portletConfig, custom_portletConfig) {
		// There is no distinction between old and new spec during override. Just simplifying for ease of validation.
		var validationObj = null;
		if (iscPortletPvdr.isNewSpecPortlet(custom_portletConfig)) {
			validationObj = _fn_validateAndGetCustomPortlets_newSpec(name, custom_portletConfig);
		} else {
			validationObj = _fn_validateAndGetCustomPortlets_oldSpec(name, custom_portletConfig);
		}
		// regardless of validationObj.hasError, we need to iterate. Extremely low but not impossible probability, flag will be false which means all def is overridden.
		// most probably, the values and type of values validation is needed. That is why we check only for null - if it is not null, then type of valus is issue.
		// NOTE: If anyone is setting a property to null in custom_portletConfig, we will ignore it.
		var areAnyOverriddenPropsInError = false;
		var overriddenPropsArray = [];
		for (var prop in validationObj) {
			if (prop === "hasError" || prop === "portletName") {
				continue;
			}
			var value = iscCore.getValueFromJsonPath(custom_portletConfig, prop, false);
			if (value != null) {
				areAnyOverriddenPropsInError = true;
				console.warn("invalid portlet configuration detected while overriding an OOTB portlet: '%s' for '%s' property. We will ignore overriding this portlet.", validationObj["portletName"], prop);
			}
		}
		if (!areAnyOverriddenPropsInError) {
			angular.merge(ootb_portletConfig, custom_portletConfig);
		}
		return ootb_portletConfig;
	};
	
	/*
	 * This method is required to be used going forward and when "usePersonaBasedHomepage" is true. Caller determines that condition.
	 * Here we are relying on clones. Previously we were no cloning. So, we are safer now.
	 * 1. We only need portlets for a given persona.
	 * 2. Since we will iterate over all portlets - custom and OOTB, we will warn for portlets without "personaConfig".
	 * 3. All portlets that do not have "personaConfig" are old spec and are added to end/last.
	 * 4. OOTB and new spec portlets sorted by "personaSequenceNumber". Old spec added last in #3 sorted by "sequenceNumber".
	 * 5. getAllVisibleSortedPortlets() we have missed checking if we are missing mandatory attributes when we are registering
	 * 		a custom portlet and it is not overriding an OOTB one i.e. we are defining a new custom portlet.
	 * 6. Validations on custom portlets:
	 * 		- In case we are registering a new custom portlet and not overriding an OOTB one:
	 * 			a. All new spec portlet, will have "personaConfig" json.
	 * 				- Inside this personaName, personaSequenceNumber, miniViewTemplateUrl, miniViewController.
	 * 				- Outisde this templateUrl, controller, showPortlet, resourceId are mandatory. sequenceNumber can be skipped.
	 * 			b. In case of old spec portlet, will not have "personaConfig" json. Mandatory:
	 * 				- templateUrl, controller, sequenceNumber, showPortlet, resourceId are mandatory.
	 * 		- In case we are registering custom portlet by overriding OOTB one, we will not be able to distinguish if it is being
	 * 			done for new or old spec portlet. None are mandatory. Like before we will allow all overrides except "templateUrl"
	 * 			and "controller".
	 * Extra processing: prepare a map of persona to resourceId - only chk for complete new entries in _customPortletConfig and
	 * all entries in _portletConfig (because will include overrides). Do this for all personas.
	 * NOTE: Can receive persona as "Manager_Dashboard" in case when called from footer - because we need to populate
	 * _personaToResourceIdListStr_visiblePortletsOnly.
	 */
	iscPortletService.getAllVisibleSortedPortletsForPersonaAndExtraProcessing = function(persona) {
		var _portletConfig = iscPortletPvdr.getPortletConfig();
		var _customPortletConfig = iscPortletPvdr.getCustomPortletConfig();
		
		var visibleSortedPortletsArrayForPersona = [];
		var oldSpecPortletsArray = [];
		for (var cn in _customPortletConfig) {
			// Definition does not exist. Want to define a new one.
			if (_portletConfig[cn] == null) {
				var validationObj = null;
				if (iscPortletPvdr.isNewSpecPortlet(_customPortletConfig[cn])) {
					validationObj = _fn_validateAndGetCustomPortlets_newSpec(cn, _customPortletConfig[cn]);
				} else {
					validationObj = _fn_validateAndGetCustomPortlets_oldSpec(cn, _customPortletConfig[cn]);
				}
				if (validationObj.hasError === true) {
					for (var prop in validationObj) {
						if (prop !== "hasError" && prop !== "portletName") {
							console.warn("invalid portlet configuration detected in '%s' portlet for '%s' property. We will not consider this portlet.", validationObj["portletName"], prop);
						}
					}
					continue;
				}
				
				if (_customPortletConfig[cn]["showPortlet"] === true) {
					// Then add to list.
					if (!iscPortletPvdr.isNewSpecPortlet(_customPortletConfig[cn])) {
						oldSpecPortletsArray.push(_customPortletConfig[cn]);
						iscPersona.updatePersonaToResourceIdList("_oldSpec", _customPortletConfig[cn]["resourceId"], false);
					} else {
						if (_customPortletConfig[cn]["personaConfig"]["personaName"] === persona) {
							visibleSortedPortletsArrayForPersona.push(_customPortletConfig[cn]);
						}
						iscPersona.updatePersonaToResourceIdList(_customPortletConfig[cn]["personaConfig"]["personaName"], _customPortletConfig[cn]["resourceId"], false);
					}
				}
			} else {
				// Definition exists and want to override. Must delete unsupported props:
				delete _customPortletConfig[cn]["controller"];
				delete _customPortletConfig[cn]["templateUrl"];
				_portletConfig[cn] = _fn_validateAndOverrideAvailableProperties(cn, _portletConfig[cn], _customPortletConfig[cn]);
			}
		}
		
		for (var n in _portletConfig) {
			// OOTB portlet can not miss 'personaName' (one exception - "moretasksportlet").
			if (n === "moretasksportlet") {
				visibleSortedPortletsArrayForPersona.push(_portletConfig[n]);
			} else if (_portletConfig[n]["showPortlet"] === true) {
				if (_portletConfig[n]["personaConfig"]["personaName"] === persona) {
					visibleSortedPortletsArrayForPersona.push(_portletConfig[n]);
				}
				iscPersona.updatePersonaToResourceIdList(_portletConfig[n]["personaConfig"]["personaName"], _portletConfig[n]["resourceId"], false);
			}
		}
		
		visibleSortedPortletsArrayForPersona.sort(function(a, b) {
			return (a["personaConfig"]["personaSequenceNumber"] - b["personaConfig"]["personaSequenceNumber"]);
		});
		oldSpecPortletsArray.sort(function(a, b) {
			return (a["sequenceNumber"] - b["sequenceNumber"]);
		});
		visibleSortedPortletsArrayForPersona = visibleSortedPortletsArrayForPersona.concat(oldSpecPortletsArray);
		
		return visibleSortedPortletsArrayForPersona;
	};
	
	return iscPortletService;
	
}]);
/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/


/**
 * @ngdoc service
 * @name iscPrint
 * 
 * 
 * @description 
 * Handles all the common tasks related to printing. 
 * 
 */
angular.module('isc.shared').factory('iscPrint', ['iscAppContext', function(iscAppContext) {

	var printService = {};

	/**
	 * @ngdoc method
	 * @name iscPrint#printHtmlOutput
	 * @description Prints the html output
	 * <br> This method detects the user agent and shows the print dailog based on user agent
	 * <br> When IE mobile , appends the html output to iframe and shows the iframe
	 * <br> When Chrome / Firefox desktop, appends the html output to iframe and executes browser print command
	 * <br> When IE desktop, appends the html output to the window popup and and shows the popup
	 * <br> When mobile , appends the html output to the window popup and and shows the popup as a tab
	 *
	 * @param outputModel {object} Output model object containing html
	 * 
	 * @example
	 		var outputModel = {
				"out":"<html>content goes here</html>"
			
			
			}
	 		iscPrint.printHtmlOutput(outputModel);
	 */
	printService.printHtmlOutput = function(outputModel){
        
        if(angular.isFunction(printService.printHtmlOutputCustom) 
            && printService.printHtmlOutputCustom(outputModel)){
            console.log("Printing done through customer handled");
        }
        else{
            var ua = window.navigator.userAgent;
            var msie = ua.indexOf("MSIE ");//Detect if the browser is IE other than IE11
            var trident = ua.indexOf('Trident/'); //Detect if the browser IE11
            var isIEMobile = ua.indexOf("IEMobile/") > 0;
            var isCordova = ua.indexOf("cordova") > 0;

            if(isCordova){
                printService.printHtmlUsingCordova(outputModel);
            }
            else if(isIEMobile){
                printService.printHtmlInIframeAndShowIframe(outputModel);
            }
            else if (msie > 0 || trident > 0 || iscAppContext.isMobile()){
                printService.printHtmlInPopup(outputModel);
            }
            else{
                printService.printHtmlInIframe(outputModel);
            }
            
        }
        
	};
	
	printService.printHtmlInIframe = function(outputModel) {		
		
		var iframe = document.getElementById('print_iframe');
		if (iframe === null) {
			iframe = document.createElement('iframe');
			iframe.setAttribute('id', 'print_iframe');
			iframe.setAttribute('name', 'print_iframe');
			iframe.setAttribute('width', '0');
			iframe.setAttribute('height', '0');
			iframe.setAttribute('frameBorder', 'no');
			iframe.setAttribute('src', 'about:blank');
			iframe.setAttribute('sandbox', 'allow-same-origin allow-modals');
			document.body.appendChild(iframe);
		}

		iframe.contentWindow.onload = iframe.onload = function() {
			iframe.contentWindow.print();
		};
		
		if (outputModel.Output.hasOwnProperty('out')) {
			iframe.contentWindow.document.open();
			iframe.contentWindow.document.write(outputModel.Output.out);
			iframe.contentWindow.document.close();			
		}
		
		
	};
	
	printService.printHtmlInIframeAndShowIframe = function(outputModel){
		if (outputModel.Output.hasOwnProperty('out')) {
			var iframe = document.getElementById('print_mobileiframe');
			if (iframe === null) {
				iframe = document.createElement('iframe');
				iframe.setAttribute('id', 'print_mobileiframe');
				iframe.setAttribute('name', 'print_mobileiframe');
				iframe.setAttribute('width', '100%');
				iframe.setAttribute('height', '100%');
				iframe.setAttribute('frameBorder', 'no');
				//iframe.setAttribute('src', 'about:blank');
				//iframe.setAttribute('sandbox', 'allow-same-origin');
				document.getElementById("printHolder").appendChild(iframe);
			}
			
			iframe.contentWindow.document.open();
			iframe.contentWindow.document.write(outputModel.Output.out);
			iframe.contentWindow.document.close();
			printService.showPrintIframe();
		}		
	};
	
	printService.printHtmlInPopup = function(outputModel){
		if (outputModel.Output.hasOwnProperty('out')) {
			/* If you want the dimensions of the current window
			var height = "innerHeight" in window 
			   ? window.innerHeight
			   : document.documentElement.offsetHeight;
			var width = "innerWidth" in window 
			   ? window.innerWidth
			   : document.documentElement.offsetWidth;
			var dimensions = "width=" + width + ", height=" + height;
			*/				
			var parameters = "menubar=yes, resizable=yes, scrollbars=yes";
			var printWindow = null;				
			printWindow = window.open("about:blank", "_blank", parameters);
			printWindow.document.write(outputModel.Output.out);					
		}
	};		
	
	printService.showPrintIframe = function(){
		document.getElementById("printHolder").style.display="block";
		document.getElementById("mainContentHolder").style.display="none";
		window.history.pushState({"page":"print"}, "Print", null);
		window.addEventListener("popstate", printService.hidePrintIframe );			
	};
	
	printService.hidePrintIframe = function(){
		document.getElementById("printHolder").style.display="none";
		document.getElementById("mainContentHolder").style.display="block";
		document.getElementById("printHolder").removeChild(document.getElementById('print_mobileiframe'));
		window.removeEventListener("popstate",printService.hidePrintIframe);			
	};
	
	
    printService.printHtmlUsingCordova = function(outputModel){
        console.log("Override this method in store-cordova.config.js");
    };
    
    printService.printHtmlOutputCustom = function(outputModel){
        console.log("print custom handler not implemented");
        return false;
    }
    
	return printService;
	
		
}]);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp. 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/

/**
 * @ngdoc service
 * @name iscProduct
 * 
 * 
 * @description  Handles common tasks related to shipment flow. 
 * 
 */
angular.module('isc.shared').factory('iscProduct', ['$http','$filter','$q','iscAppInfo','iscMashup','iscModal','iscWizard','iscI18n','$rootScope',
 function($http,$filter,$q,iscAppInfo,iscMashup,iscModal,iscWizard,iscI18n,$rootScope) {
  
   var productService = {};	
   
   
   productService.getComponentItemDisplay = function(itemComponentModel){
		
		var retVal =null;
		if(itemComponentModel){ 
			var componentId=itemComponentModel.ComponentItemID;
			var componentDesc=itemComponentModel.ComponentDescription;
			
			itemComponentModel={};
			itemComponentModel.ItemDescription=componentDesc;
			itemComponentModel.ItemId=componentId;
			retVal= scScreenUtils.getFormattedString(screen,"ItemDisplayConfigurationForComponents",itemComponentModel);
		}
		
	return retVal;
	
	};
   
   productService.getImageURLByAsset = function(asset) {
	   
	   var imageURL = "";
	   
	   if(!iscCore.isVoid(asset)) {
		   
		   var imageLocation = asset.ContentLocation;
		   var imageId = asset.ContentID;
		   if(!iscCore.isVoid(imageLocation) && !iscCore.isVoid(imageId)) {
			   imageURL = imageLocation+ "/" +imageId;
		   }
	   }
	   
	   return imageURL;
	   
   };
   
   productService.getFirstItemChildElementFromItemList = function(itemList) {
	   
	   var itemDetails = {};
	   itemDetails.Item = itemList.ItemList.Item[0];
	   if(!iscCore.isVoid(itemList.ItemList.Item[0].ItemAttributeGroupTypeList) && !iscCore.isVoid(itemList.ItemList.Item[0].ItemAttributeGroupTypeList.ItemAttributeGroupType[0])) {
		   itemDetails.Item.ItemAttributeGroupTypeList.ItemAttributeGroupType = itemList.ItemList.Item[0].ItemAttributeGroupTypeList.ItemAttributeGroupType[0];
	   }
	   itemDetails.Item.Currency = itemList.ItemList.Currency;
	   
	   return itemDetails;
	   
   };
   
   productService.isBundleParent = function(itemDetails) {
	   
	   if(!itemDetails|| !itemDetails.Item ){
			return false;
		}
		
		var primaryInformation=itemDetails.Item.PrimaryInformation;
		if(!primaryInformation){
			return false;
		}
		
		if(primaryInformation.KitCode && primaryInformation.KitCode === "BUNDLE"){
			return true;
		}
		return false;
	   
   };
   
   productService.isPhysicalKit = function(itemDetails) {
	   
	   if(!itemDetails || !itemDetails.Item){
			return false;
		}
		
		var primaryInformation=itemDetails.Item.PrimaryInformation;
		if(!primaryInformation){
			return false;
		}
		
		if(primaryInformation.KitCode && primaryInformation.KitCode === "PK"){
			return true;
		}
		return false;
	   
   };

   productService.generateComponentImageURL = function(componentsModel) {
		for (var i=0; i< componentsModel.Component.length; i++) {
			var currentComponent = componentsModel.Component[i];
			if(currentComponent.Item && currentComponent.Item.PrimaryInformation) {
				if(currentComponent.Item.PrimaryInformation.ImageLocation && currentComponent.Item.PrimaryInformation.ImageID) {
					currentComponent.Item.PrimaryInformation.ImageURL = currentComponent.Item.PrimaryInformation.ImageLocation+"/"+currentComponent.Item.PrimaryInformation.ImageID;
				}
			}
		}
	};
   

   return productService;
 }]);




/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/

/**
 * @ngdoc service 
 * @name iscHttpRequest
 * @requires $http
 * @requires $q
 * @requires iscAppInfo
 * 
 * @description 
 * Handles specific utilities to deal with a request object or request URLs or request params.
 * 
 */


angular.module('isc.shared').factory('iscHttpRequest', ['$http','$q','iscAppInfo', function($http,$q,iscAppInfo) {
	
	var httpRequestService = {};
	
	httpRequestService.csrfTokenParamName = 'scCSRFToken';
	httpRequestService.existingClientParamName = "scFlag";
	httpRequestService.existingClientParamValue = "Y";
	httpRequestService.isGuestUserParamName = "scGuestUser";
		
	/**
	 * @ngdoc method
	 * @name iscHttpRequest#addParam
	 * @description Adds new parameter name and value into the params object and returns the params object.
	 * 
	 * @param {string} paramName New paramaeter name to be added
	 * @param {string} paramValue Value for the new parameter
	 * @param {object} o existing param object which needs to be updated
	 * 
	 * @returns {object} Returns a params object with new parameter name and value added to it.
	 */
	httpRequestService.addParam = function(paramName, paramValue, o) {
		if(typeof o == "string")
		{
			if( o == "") {
				return paramName + "=" + encodeURIComponent(paramValue);
			}
			if(o.indexOf(paramName + "=") == -1)
				return o + "&" + paramName + "=" + encodeURIComponent(paramValue);
			
			var obj = decodeURIComponent(o);
			obj[paramName] = paramValue;
			return encodeURIComponent(obj);
		} 
		if(o == null) {
			o = {};
			o[paramName] = paramValue;
			return o;
		}
		if(o instanceof Object) {
			o[paramName] = paramValue;
			return o;
		}
		return o;
	};
	
	/**
	 * @ngdoc method
	 * @name iscHttpRequest#addCSRFTokenParam
	 * @description Adds CSRF token into params object if required based on CSRF validation mode of the application and returns the params object.
	 * 
	 * @param {object} o existing param object which needs to be updated
	 * @param {string} method Request method ("GET", "POST", "NONE" etc.)
	 * 
	 * @returns {object} Returns a params object with csrf token parameter name and  value added to it (only if CSRF validation mode is turned on the request method).
	 * 
	 */
	httpRequestService.addCSRFTokenParam = function(o, method) {
		var csrfValMode = iscAppInfo.getCSRFValidationMode();
		if("NONE" == csrfValMode)
			return o;
			
		method = (method == null ) ? "POST" : method.toUpperCase();
		method = (method == "GET") ? "GET" : "POST";
		if(method == "GET" && "POST" == csrfValMode)
			return o;
		
		var csrfToken =  iscAppInfo.getCSRFToken();
		
		if(csrfToken == null)
			return o;
			
		return httpRequestService.addParam(httpRequestService.csrfTokenParamName, csrfToken, o);	
		
	};
	
	/**
	 * @ngdoc method
	 * @name iscHttpRequest#addParamAndReturnUpdatedURL
	 * @description Adds new parameter name and value into the URL and returns the URL.
	 * 
	 * @param {string} url URL string
	 * @param {string} paramName New paramaeter name to be added
	 * @param {string} paramValue Value for the new parameter
	 * @param {string} method Request method ("GET", "POST", "NONE" etc.)
	 * 
	 * @returns {String} Returns URL with new parameter name and value added to it.
	 */
	httpRequestService.addParamAndReturnUpdatedURL = function(url, paramName, paramValue, method) {
		// summary: 
		//		This method adds the passed parameters and their values to the url and returns the
		//		updated url. It can handle csrf token as well.
		// 
		// url: String
		//		The url to be updated. It may or may not contain a "?".
		//
		// paramName: String
		//		The parameter to append to the url.
		//
		// paramValue: String
		//		The value of the parameter. It can be null if paramName is this.csrfTokenParamName
		//		i.e. the csrf token.
		//
		// method: String [optional]
		//		Pass as null or leave for all cases except the csrf token. For csrf token, it can be
		//		"GET" or "POST". 
		if(url == null) {
			return url;
		}
		var toks = url.split("?");
		var newUrl = toks[0];
		var params = toks[1] || "";
		
		if(paramName == httpRequestService.csrfTokenParamName) {
			params = httpRequestService.addCSRFTokenParam(params, method);
		} else {
			params = httpRequestService.addParam(paramName, paramValue, params);
		}
		
		if(params != "") {
			return newUrl + "?" + params;
		}
		return url;
	};
	
	/**
	 * @ngdoc method
	 * @name iscHttpRequest#appendCSRFTokenInURL
	 * @description Adds CSRF token name and value into the URL and returns the URL, only if CSRF validation mode is turned on the request method.
	 * 
	 * @param {string} url URL string
	 * @param {string} method Request method ("GET", "POST", "NONE" etc.)
	 * 
	 * @returns {String} Returns URL with CSRF token name and value added to it, only if CSRF validation mode is turned on the request method.
	 */
	httpRequestService.appendCSRFTokenInURL = function(url, method) {
		return httpRequestService.addParamAndReturnUpdatedURL(url, httpRequestService.csrfTokenParamName, null, method);
	};
	
	/**
	 * @ngdoc method
	 * @name iscHttpRequest#addAdditionalParams
	 * @description Adds additional parameter names and values into the params object and returns the params object, including CSRF token if CSRF validation mode is turned on for the request method.
	 * 
	 * @param {object} o existing param object which needs to be updated
	 * @param {string} method Request method ("GET", "POST", "NONE" etc.)
	 * @param {string} url URL string
	 * 
	 * @returns {object} Returns params object with all additional names and values added to it, including CSRF token if CSRF validation mode is turned on the request method.
	 */
	httpRequestService.addAdditionalParams = function(o, method, url) {

		if ( url.indexOf(".js") == -1 ) {
			if ( url.indexOf(".html") == -1 ) {
				o = httpRequestService.addCSRFTokenParam(o, method);	
			}				
		}			

		o = httpRequestService.addParam(httpRequestService.existingClientParamName, httpRequestService.existingClientParamValue, o);

		//if(userPrefs.isGuestUser())
		 //o = this.addParam(this.isGuestUserParamName, "Y", o);
		
		return o;
	};
	/**
	 * @ngdoc method
	 * @name iscHttpRequest#addAdditionalParamsInURL
	 * @description Adds additional parameter names and values into the URL string and returns the URL string, including CSRF token if CSRF validation mode is turned on for the request method.
	 * 
	 * @param {string} url URL string
	 * @param {string} method Request method ("GET", "POST", "NONE" etc.)
	 * 
	 * @returns {string} Returns URL string with all additional names and values added to it, including CSRF token if CSRF validation mode is turned on the request method.
	 */
	httpRequestService.addAdditionalParamsInURL = function(url, method) {
		if(url == null)
			return url;
		var toks = url.split("?");
		
		var newUrl = toks[0];
		var params = toks[1] || "";
		params = httpRequestService.addAdditionalParams(params, method, url);
		
		if(params != "")
			return newUrl + "?" + params;
		return url;
	};
		
	/**
	 * @ngdoc method
	 * @name iscHttpRequest#submitForm
	 * @description Makes an HTML Form submit with correct URL, params and target with either a GET or POST method. In case of doing a POST, it creates a dummy form with correct target, action URL, and params
	 * to submit the form, if input object does not contain 'form' attribute. If input object contains 'target' attribute (can be a window or iframe), the form post will be done on the same target element.
	 * 
	 * @param {Object} o containing url,params,method,form,scope,target attributes for appropriate actions
	 * 
	 */
	httpRequestService.submitForm = function(o) {
		var defaultMethod = "POST";
		var p = o.params;
        if(typeof p == "function"){
            p = p.call(o.scope||window, o);
        }
        
        var url = o.url;
        if(typeof url == 'function'){
            url = url.call(o.scope||window, o);
        }
        var method = o.method||(p ? "POST" : "GET");
        p = httpRequestService.addAdditionalParams(p, method, url);
        
        if(method == "GET") {
        	if(typeof p == "object"){
            	p = httpRequestService.serializeJSObjIntoQueryString(p);
        	}
        	try {
				if(p != "" && p != null)
					url = url + (url.indexOf('?') != -1 ? '&' : '?') + p;
        		window.location.href = url;
        	} catch (ex) { }
        
        } else {   
        	var form = o.form || window.document.createElement("form");
        	form.action = url;
        	if(o.target != null)
        		form.target = o.target;
        	form.name = "iscDummyForm"+new Date().getTime();
        	form.method = "POST";
        	if(!o.form){
        		document.body.appendChild(form);
        	}
        	p = p || {};
        	if(typeof p == "object"){
        		for(var key in p) {
        			var el = window.document.createElement("input");
        			el.type = "hidden";
        			var val = p[key];
        			if(val instanceof Array) {
        				for(var i = 0; i < val.length; i++) {
        					httpRequestService.createHidden(key, val[i], form);
        				}
        			} else {
        				httpRequestService.createHidden(key, val, form);
        			}
        		}
        	} else {
        		var toks = p.split("&");
        		for(var i = 0; i < toks.length; i++) {
        			var par = toks[i];
        			if(par == "")
        				continue;
        			var ts = par.split("=");
        			httpRequestService.createHidden(ts[0], ts[1], form)
        		}
        	
        	}
        	form.submit(o.otherFormParams);
        }
	};
	
	/**
	 * @ngdoc method
	 * @name iscHttpRequest#createHidden
	 * @description Makes a dynamic HTML element with input type as hidden for a hidden form element.
	 * 
	 * @param {string} name Name of the input parameter for the hidden form element.
	 * @param {string} val Value of the input parameter for the hidden form element.
	 * @param {Object} form HTML form element.
	 * 
	 */
	
	httpRequestService.createHidden = function(name, val, form) {
		if(form.el && form.el.dom){
			form = form.el.dom;
		}
		var el = window.document.createElement("input");
		el.type = "hidden";
		el.name = name;
		el.value = val || "";
		form.appendChild(el);
	};
	
	/**
	 * @ngdoc method
	 * @name iscHttpRequest#serializeJSObjIntoQueryString
	 * @description Serializes a Javascript object key-value pair into a URL query string with encoded paramaeter name values.
	 * 
	 * @param {Object} obj Javascript object which needs to be serialized into query string.
	 * @param {string} prefix Prefix for json array objects to be converted into query string parameter name. This is optional input to the method and will be evaluated internally for array objects, if required
	 * and present in the javascript object.
	 * 
	 * @returns {string} Returns encoded URL query string.
	 * 
	 */
	
	httpRequestService.serializeJSObjIntoQueryString = function(obj, prefix) {
	    var str = [];
	    for (var p in obj) {
	      if (obj.hasOwnProperty(p)) {
	        var k = prefix ? prefix + "[" + p + "]" : p,
	              v = obj[p];
	          str.push(typeof v == "object" ? httpRequestService.serializeJSObjIntoQueryString(v, k) : encodeURIComponent(k) + "=" + encodeURIComponent(v));
	      }
	    }
	    return str.join("&");
	};
	
	return httpRequestService;	
	
}]);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp. 2016, 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/

/**
 * @ngdoc service
 * @name iscReturn
 * 
 * 
 * @description  Handles common tasks related to return wizard. 
 * 
 */
angular.module('isc.shared').factory('iscReturn', ['$http','$filter','$q','iscAppInfo','iscMashup','iscModal','iscWizard','iscI18n','$rootScope',
 function($http,$filter,$q,iscAppInfo,iscMashup,iscModal,iscWizard,iscI18n,$rootScope) {
  
   var returnService = {};	
   
   /**
	 * @ngdoc method
	 * @name iscReturn#handleWizardExit
	 * @description Handles closing of return flow. Shows a confirmation popup if there is a return order.
	 * @param numOfReturnLines {Number} Number of return order lines
	 */
   returnService.handleWizardExit = function(numOfReturnLines){
	   if(!returnService.isReturnCartEmpty(numOfReturnLines)) {
		   var confirmationMsg = iscI18n.translate('returns.MSG_ExitReturnOrderFlow');
			iscModal.showConfirmationMessage(confirmationMsg).then(
				function(callBackAction){
						if(callBackAction === 'YES'){
							returnService.cleanUpOrders("exit");
						}
				},
				function(callBackAction){/*Do nothing*/});
	   } else {
		   returnService.cleanUpOrders("exit");
	   }
		return true;
   };
   
   /**
	 * @ngdoc method
	 * @name iscReturn#handleWizardCancel
	 * @description Handles cancel of return flow. Shows a confirmation popup if there is a return order.
	 * @param numOfReturnLines {Number} Number of return order lines
	 */
   returnService.handleWizardCancel = function(numOfReturnLines) {
	   if(!returnService.isReturnCartEmpty(numOfReturnLines)) {
		   var errorMsgBundleKey = 'returns.MSG_ExitReturnOrderFlow';
		   iscModal.showConfirmationMessage(iscI18n.translate(errorMsgBundleKey)).then(
				function(callBackAction){
					if(callBackAction === 'YES'){
						returnService.cleanUpOrders("close");
					} 
					},
					function(callBackAction){
					});  
		   
	   } else {
		   returnService.cleanUpOrders("close");
	   }
	   
   };
   
   /**
	 * @ngdoc method
	 * @name iscReturn#cleanUpOrders
	 * @description Deletes the return and exchange order on wizard close or cancel.
	 * @param wizardAction {String} Action performed on the return order wizard - exit or cancel
	 */
   returnService.cleanUpOrders = function(wizardAction) {
	   
	   var returnOrderHeaderKey = returnService.getReturnHeaderKeyFromWizard();
	   if(!iscCore.isVoid(returnOrderHeaderKey)) {
			var exchangeOrderKey = returnService.getExchangeOrderHeaderKeyFromWizard();
			if(!iscCore.isVoid(exchangeOrderKey)) {
				returnService.deleteExchangeOrder(exchangeOrderKey, returnOrderHeaderKey,wizardAction);
			} else {
				returnService.deleteReturnOrder(returnOrderHeaderKey,wizardAction);
			} 
	   } else {
		   wizardAction == "exit"?iscWizard.exitWizard() : iscWizard.closeWizard();
	   }
   };
   
   /**
	 * @ngdoc method
	 * @name iscReturn#isReturnCartEmpty
	 * @description Checks if return order lines is greater than 0 or not
	 * @param numOfReturnLines {Number} Number of return order lines
	 */
   returnService.isReturnCartEmpty = function(numOfReturnLines) {
		   return !iscCore.isVoid(numOfReturnLines)	&& $filter('number')(numOfReturnLines) > 0 ? false : true;
   };
   
   
   /**
	 * @ngdoc method
	 * @name iscReturn#getExchangeOrderHeaderKeyFromWizard
	 * @description Gets the exchange OrderHeaderKey from wizard model
	 */
   returnService.getExchangeOrderHeaderKeyFromWizard = function() {
	   
       	var exchangeOrderHeaderKey = "", exchangeOrderModel = iscWizard.getWizardModel("exchangeOrderModel");
  		if(!iscCore.isVoid(exchangeOrderModel) && !iscCore.isVoid(exchangeOrderModel.Order) && !iscCore.isVoid(exchangeOrderModel.Order.OrderHeaderKey)) {
  			exchangeOrderHeaderKey = exchangeOrderModel.Order.OrderHeaderKey;
  		}
  		
  		return exchangeOrderHeaderKey;
       
   };
   
   /**
	 * @ngdoc method
	 * @name iscReturn#getReturnHeaderKeyFromWizard
	 * @description Gets the return OrderHeaderKey from wizard model
	 */
   returnService.getReturnHeaderKeyFromWizard = function() {
	   
      	var returnOrderHeaderKey = "", returnOrderModel = iscWizard.getWizardModel("returnOrder");
 		if(!iscCore.isVoid(returnOrderModel) && !iscCore.isVoid(returnOrderModel.Order) && !iscCore.isVoid(returnOrderModel.Order.OrderHeaderKey)) {
 			returnOrderHeaderKey = returnOrderModel.Order.OrderHeaderKey;
 		}
 		
 		return returnOrderHeaderKey;
      
  };
   
  /**
	 * @ngdoc method
	 * @name iscReturn#deleteReturnOrder
	 * @description Deletes the return order on wizard close or cancel.
	 * @param returnOrderHeaderKey {String} return OrderHeaderKey
	 * @param wizardAction {String} Wizard action - exit or close
	 */
   returnService.deleteReturnOrder = function(returnOrderHeaderKey, wizardAction) {
	   
	   var deleteOrderInput = {};
	   deleteOrderInput.Order = {};
	   deleteOrderInput.Order.OrderHeaderKey = returnOrderHeaderKey;
	   
	   iscMashup.callSimpleMashup(this,"returnLookup_deleteReturnOrder",deleteOrderInput,{}).then(function(response) {
		   
		   wizardAction == "exit"?iscWizard.exitWizard() : iscWizard.closeWizard();
		   
	   },angular.noop);
	   
   };
 
   /**
	 * @ngdoc method
	 * @name iscReturn#deleteExchangeOrder
	 * @description Deletes the exchange order on wizard close or cancel.
	 * @param exchangeOrderHeaderKey {String} exchange OrderHeaderKey
	 * @param returnOrderHeaderKey {String} return OrderHeaderKey
	 * @param wizardAction {String} Wizard action - exit or close
	 */
 returnService.deleteExchangeOrder = function(exchangeOrderHeaderKey, returnOrderHeaderKey, wizardAction) {
	   
	   var deleteOrderInput = {};
	   deleteOrderInput.Order = {};
	   deleteOrderInput.Order.OrderHeaderKey = exchangeOrderHeaderKey;
	   deleteOrderInput.Order.ReturnOrderHeaderKey = returnOrderHeaderKey;
	   
	   iscMashup.callSimpleMashup(this,"returnsList_deleteExchangeOrder",deleteOrderInput,{}).then(function(response) {
		   returnService.deleteReturnOrder(returnOrderHeaderKey,wizardAction);
	   },angular.noop);
	   
   };
    
   /**
	 * @ngdoc method
	 * @name iscReturn#handleWizardBack
	 * @description Handles functionality (going to previous page or wizard exit) on clicking wizard back
	 * @param isScreenDirty {Boolean} True if screen is dirty
	 * @param numOrderLines {Number} number of return order lines
	 */
   returnService.handleWizardBack = function(isScreenDirty,numOrderLines){
	   var isFirstPage = iscWizard.isFirstPage();
	   //screen will not be dirty in returns flow
		/*if(isScreenDirty){
			if(isFirstPage){
				returnService.handleWizardExit(numOrderLines);
			}
			else{
				iscModal.showConfirmationMessage(iscI18n.translate('returns.MSG_Screen_dirty')).then(function(action){
	   			if(iscCore.isBooleanTrue(action)){
	   				iscWizard.gotoPreviousPage(true);
	   			}
   		});
			}
			return true;
		}
		else */
	   if(isFirstPage){
			return returnService.handleWizardExit(numOrderLines);
		}
		else{
			iscWizard.gotoPreviousPage(true);
			return true;
		}
   };
   
   /**
	 * @ngdoc method
	 * @name iscReturn#setMiniCartParam
	 * @description Sets all the attributes to show return mini cart
	 * @param screen {Object} return screen
	 */
   returnService.setMiniCartParam = function(screen){
	   screen.ui.minicartparam = {};
	   screen.ui.minicartparam.carticon = 'app-glyphicons app-icon-return_30';
	   screen.ui.minicartparam.cartbtnlabel = 'returnHeader.ACTION_ReviewReturns';
	   screen.ui.minicartparam.wizardmodelname = 'returnOrder';
	   screen.ui.minicartparam.checkoutpage = 'returnsList';
	   screen.model.returnOrder = iscWizard.getWizardModel("returnOrder");
     	if(!iscCore.isVoid(screen.model.returnOrder)){
     		screen.ui.orderTotalQty = screen.model.returnOrder.Order.OrderLines.TotalLinesInCart;
     	}
   };
   
   return returnService;
 }]);




/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/

/**
 * @ngdoc service
 * @name iscScrollUtility
 * 
 * 
 * @description 
 * Handles all the common tasks related to any scrolling. 
 * 
 */
 
(function(sharedModule){
	'use strict';
	
	sharedModule.factory('iscScrollUtility', iscScrollUtilityFn);
	
	function iscScrollUtilityFn(){
		
		var scrollUtilityService = {};
		
		/**
		 * @ngdoc method
		 * @name iscScrollUtility#scrollToElementWIthOffsetAndFixedHeader
		 * @description
		 * This method scroll a child element into the view inside a scrolling element with a 
		 * fixed header element, some top offset and some bottom offset.
		 * @param scrollElem {object} Scrolling Element
		 * @param node {object} Child element which should be displayed in the view
		 * @param fixedHeaderHeight {number} Fixed header height
		 * @param topOffset {number} Any offset at top of scrolling element
		 * @param bottomOffset {number} Any offset at bottom of scrolling element
		 * @example			
				iscScrollUtility.scrollToElementWIthOffsetAndFixedHeader(scrollElem, childElem, 100, 20, 10);
		 */
		scrollUtilityService.scrollToElementWIthOffsetAndFixedHeader = function(scrollElem, node, fixedHeaderHeight, topOffset, bottomOffset){

			fixedHeaderHeight = fixedHeaderHeight?fixedHeaderHeight:0;
			topOffset = topOffset?topOffset:0;
			topOffset = topOffset + fixedHeaderHeight;
			scrollUtilityService.scrollToElementWIthOffset(scrollElem, node, topOffset, bottomOffset);

		};

		/**
		 * @ngdoc method
		 * @name iscScrollUtility#scrollToElementWIthOffset
		 * @description
		 * This method scroll a child element into the view inside a scrolling element with  
		 * some top offset and some bottom offset.
		 * @param scrollElem {object} Scrolling Element
		 * @param node {object} Child element which should be displayed in the view
		 * @param topOffset {number} Any offset at top of scrolling element
		 * @param bottomOffset {number} Any offset at bottom of scrolling element
		 * @example			
				iscScrollUtility.scrollToElementWIthOffset(scrollElem, childElem, 20, 10);
		 */
		scrollUtilityService.scrollToElementWIthOffset = function(scrollElem, node, topOffset, bottomOffset){

			topOffset = topOffset?topOffset:0;
			bottomOffset = bottomOffset?bottomOffset:0;
			
			if(scrollElem && node){
				var nodeBottom = node.getBoundingClientRect().bottom,
					nodeTop = node.getBoundingClientRect().top,
					scrollElemBottom = scrollElem.getBoundingClientRect().bottom,
					scrollElemTop = scrollElem.getBoundingClientRect().top;
				if(nodeBottom + bottomOffset > scrollElemBottom){
					scrollElem.scrollTop = scrollElem.scrollTop + (nodeBottom + bottomOffset - scrollElemBottom);
				}else if(nodeTop < scrollElemTop + topOffset){
					scrollElem.scrollTop = scrollElem.scrollTop - (scrollElemTop + topOffset - nodeTop);
				}else{
					//no need to do anything as the node is already within the scrolling container
				}
			}

		}

		return scrollUtilityService;
	}
})(angular.module('isc.shared'));

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp. 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/


/**
 * @ngdoc service
 * @name iscCustomerPickup
 * 
 * 
 * @description  Handles common tasks related to shipment flow. 
 * 
 */
angular.module('isc.shared').factory('iscCustomerPickup', ['$http','$filter','$q','iscAppInfo','iscMashup','iscModal','iscWizard','iscI18n','$rootScope','iscState',
    function($http,$filter,$q,iscAppInfo,iscMashup,iscModal,iscWizard,iscI18n,$rootScope,iscState) {
  
        var iscCustomerPickup = {};	
     
        iscCustomerPickup.getShipmentLineDetailsInput = function(shipmentKey, shipmentLineKey){
            var getShipmentLineDetailsInput = {ShipmentLine:{}};
            getShipmentLineDetailsInput.ShipmentLine.ShipmentKey = shipmentKey;

            getShipmentLineDetailsInput.ShipmentLine.ShipmentLineKey = shipmentLineKey;
            return getShipmentLineDetailsInput;
        }
        
        iscCustomerPickup.getQuantityUpdateInput = function(shipmentKey,shipmentLineKey,customerPickedQuantity) {
            var changeShipmentInput = {
                    Shipment:{
                        ShipmentKey:shipmentKey,
                        ShipmentLines:{
                            ShipmentLine:[
                                {
                                    ShipmentLineKey : shipmentLineKey,
                                    CustomerPickedQuantity : customerPickedQuantity
                                }
                            ]
                        }
                    }
                };
            return changeShipmentInput;

        };
        
        iscCustomerPickup.getShortageLineInput = function(shipmentKey,shipmentLineKey,shortageReason,cancelReason){
            
            var changeShipmentInput = {
                    Shipment:{
                        ShipmentKey:shipmentKey,
                        ShipmentLines:{
                            ShipmentLine:[
                                {
                                    ShipmentLineKey : shipmentLineKey,
                                    ShortageResolutionReason : shortageReason,
                                    CancelReason : cancelReason
                                }
                            ]
                        }
                    }
                };
            return changeShipmentInput;
        }
        
        iscCustomerPickup.getPickAllInput = function(shipmentKey,shipmentLineList){
            var shipmentInput = {
                Shipment:{
                    ShipmentKey:shipmentKey,
                    ShipmentLines:{
                        ShipmentLine:[]
                    }
                }
            }
            for(var i=0;i<shipmentLineList.ShipmentLines.ShipmentLine.length;i++){
                var shipmentLine = shipmentLineList.ShipmentLines.ShipmentLine[i];
                if(!iscCore.isBooleanTrue(shipmentLine.IsCustomerPickComplete) && iscCore.isVoid(shipmentLine.ShortageResolutionReason)){
                    var shipmentLineInput = {
                        ShipmentLineKey:shipmentLine.ShipmentLineKey,
                        CustomerPickedQuantity:shipmentLine.Quantity
                    }
                    shipmentInput.Shipment.ShipmentLines.ShipmentLine.push(shipmentLineInput);
                }

            }
            return shipmentInput;
        };
        
        iscCustomerPickup.getShortAllRemainingInput = function(shipmentKey,shipmentLineList,shortageReason,cancelReason){
            var shipmentInput = {
                Shipment:{
                    ShipmentKey:shipmentKey,
                    ShipmentLines:{
                        ShipmentLine:[]
                    }
                }
            }
            for(var i=0;i<shipmentLineList.ShipmentLines.ShipmentLine.length;i++){
                var shipmentLine = shipmentLineList.ShipmentLines.ShipmentLine[i];
                if(!iscCore.isBooleanTrue(shipmentLine.IsCustomerPickComplete) && iscCore.isVoid(shipmentLine.ShortageResolutionReason)){
                    var shipmentLineInput = {
                        ShipmentLineKey:shipmentLine.ShipmentLineKey,
                        ShortageResolutionReason:shortageReason,
                        CancelReason:cancelReason
                    }
                    shipmentInput.Shipment.ShipmentLines.ShipmentLine.push(shipmentLineInput);
                }

            }
            return shipmentInput;
        };
        
        
        iscCustomerPickup.isAllLinesComplete = function(shipmentLineList){
            var isAllLinesComplete = true;
            var len = shipmentLineList.ShipmentLines.ShipmentLine.length;
            while(len--){
                var shipmentLine = shipmentLineList.ShipmentLines.ShipmentLine[len];
                if(!iscCore.isBooleanTrue(shipmentLine.IsCustomerPickComplete) && iscCore.isVoid(shipmentLine.ShortageResolutionReason)){
                    isAllLinesComplete = false;
                    break;
                }
            }
            return isAllLinesComplete;
        };
        
     
        return iscCustomerPickup;
}]);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp. 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/


/**
 * @ngdoc service
 * @name iscPortletShipment
 * 
 * 
 * @description  Handles common tasks related to portlet shipments. 
 * 
 */
angular.module('isc.shared').factory('iscPortletShipment', ['$http','$filter','$q','iscAppInfo','iscMashup','iscModal','iscWizard','iscI18n','$rootScope','iscState', 'iscShipment',
 function($http,$filter,$q,iscAppInfo,iscMashup,iscModal,iscWizard,iscI18n,$rootScope,iscState, iscShipment) {
  
    var portletShipment = {};   

	portletShipment.handleShipmentOrderBarcodeTranslation = function(translationOutput, actionPage, listPage){
		if(iscCore.isVoid(translationOutput) || iscCore.isVoid(translationOutput.numberOfOutboundShipments) || 0 == translationOutput.numberOfOutboundShipments){
			var errorMsgKey = iscI18n.hasKey(actionPage+".MSG_ShipmentNotFound")?actionPage+'.MSG_ShipmentNotFound':'outboundShipments.MSG_ShipmentNotFound';
			iscModal.showErrorMessage(iscI18n.translate(errorMsgKey));
		} else if (1 == translationOutput.numberOfOutboundShipments) {
			portletShipment.openflowWizard(translationOutput.Shipments.Shipment[0], actionPage);
		} else {
			portletShipment.openShipmentListForTranslation(translationOutput.barCodeTranslatedEntity, translationOutput.barCodeTranslatedValue, listPage);
		}
	};

	portletShipment.handlePortletAdvancedSearch = function(shipmentListOutput, actionPage, inputCriteria, stausList){
		if(iscCore.isVoid(shipmentListOutput.Shipments) || iscCore.isVoid(shipmentListOutput.Shipments.TotalNumberOfRecords) || 0 == shipmentListOutput.Shipments.TotalNumberOfRecords){
			iscModal.showErrorMessage(iscI18n.translate('outboundShipments.MSG_ShipmentNotFound'));
		} else if (1 == shipmentListOutput.Shipments.TotalNumberOfRecords) {
			portletShipment.openflowWizard(shipmentListOutput.Shipments.Shipment[0], actionPage);
		} else {
			portletShipment.openAdvancedShipmentListWithInput(inputCriteria, actionPage, stausList);
		}
	};

	portletShipment.openflowWizard = function(shipment, actionPage){
		iscState.goToState(actionPage,{input:{"Shipment":shipment}},{});
	};

	portletShipment.openShipmentListForTranslation = function(barCodeTranslatedEntity, barCodeTranslatedValue, listPage){
		var shipmentListInput = null;
		if(barCodeTranslatedEntity == "SHIPMENT" && !iscCore.isVoid(barCodeTranslatedValue)){
			shipmentListInput = {"Shipment":{"ShipmentNo":barCodeTranslatedValue}};
		}else if(barCodeTranslatedEntity == "ORDER" && !iscCore.isVoid(barCodeTranslatedValue)){
			shipmentListInput = {"Shipment":{"ShipmentLines":{"ShipmentLine":{"OrderNo":barCodeTranslatedValue}}}};
		}
		portletShipment.openShipmentListWithInput(shipmentListInput, listPage);
	};

	portletShipment.openShipmentListWithInput = function(shipmentListInput, listPage){
		var oListPage = !iscCore.isVoid(listPage)?listPage:'globalshipmentsearch';
		if(!iscCore.isVoid(shipmentListInput)){
			iscState.goToState(oListPage,{input:shipmentListInput},{});
		}
	};

	portletShipment.openAdvancedShipmentListWithInput = function(shipmentListInput, actionPage, stausList){
		if(!iscCore.isVoid(shipmentListInput)){
			iscState.goToState('globalshipmentsearch',{input:shipmentListInput,status:stausList},{});
		}
	};

	     
   return portletShipment;

}]);




/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp. 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/


/**
 * @ngdoc service
 * @name iscShipment
 * 
 * 
 * @description  Handles common tasks related to shipment flow. 
 * 
 */
angular.module('isc.shared').factory('iscShipment', ['$http','$filter','$q','iscAppInfo','iscMashup','iscModal','iscWizard','iscI18n','$rootScope','iscState','iscShipmentStatus',
 function($http,$filter,$q,iscAppInfo,iscMashup,iscModal,iscWizard,iscI18n,$rootScope,iscState,iscShipmentStatus) {
  
   var shipmentService = {};	
   
   /**
	 * @ngdoc method
	 * @name iscReturn#handleWizardExit
	 * @description Handles closing of return flow. Shows a confirmation popup if there is a return order.
	 * @param numOfReturnLines {Number} Number of return order lines
	 */
//   shipmentService.getDueInImageUrl = function(imageURL){
//	   /*var url = imageURL.CodeLongDescription;
//		var lastSlash = url.lastIndexOf("/");
//		var imgLoc = url.slice(0,lastSlash);*/
//		var fullImgLoc = shipmentService.getFullURLForImage(imageURL);
//		return fullImgLoc;
//   };
   
   shipmentService.getFullURLForImage = function(relativePath){
	   return window.location.protocol+"//"+window.location.host+iscAppInfo.getApplicationContext()+"//"+relativePath;
   };
   
   /**
	 * @ngdoc method
	 * @name iscShipment#getShipmentStatusDescription
	 * @description returns the status description of shipment based on status code
	 * @param shipmentModel {object} Shipment model containing status of shipment
	 */
	shipmentService.getShipmentStatusDescription = function(shipmentModel){
		var status = shipmentModel.Status.Status?shipmentModel.Status.Status:shipmentModel.Status;
		var deliveryMethod = shipmentModel.DeliveryMethod;
		status = status.replace(/\./g, "_");
		
		if(status && deliveryMethod && iscI18n.hasKey("shipmentsummary.LABEL_"+status+"_"+deliveryMethod)){
			return iscI18n.translate("shipmentsummary.LABEL_"+status+"_"+deliveryMethod);
		}
		else if(status && iscI18n.hasKey("shipmentsummary.LABEL_"+status)){
			return iscI18n.translate("shipmentsummary.LABEL_"+status);
		}
		else {
			return shipmentModel.Status.Description?shipmentModel.Status.Description:"";
		}
	};

	/**
	 * @ngdoc method
	 * @name iscShipment#displayHoldLocation
	 * @description returns if staging locations needs to be displayed or not based on status of shipment
	 * @param shipmentModel {object} Shipment model containing status and holdlocation of shipment
	 */
	shipmentService.displayHoldLocation = function(shipmentModel){
		var status = shipmentModel.Status.Status?shipmentModel.Status.Status:shipmentModel.Status;
		var holdLocation = shipmentModel.HoldLocation;
		if(!iscCore.isVoid(holdLocation) && (iscObjectUtility.stringStartsWith(status,"1100.70.06.10") || iscObjectUtility.stringStartsWith(status,"1100.70.06.20") 
   			|| iscObjectUtility.stringStartsWith(status,"1100.70.06.30") || iscObjectUtility.stringStartsWith(status,"1100.70.06.50") || iscObjectUtility.stringStartsWith(status,"1100.70.06.70")) ){
			return true;
		}
		return false;
	};

	/**
	 * @ngdoc method
	 * @name iscShipment#getDisplayOrderNumber
	 * @description returns order no, there can be multiple orders for a shipment, for the shipment 
	 * @param orderNo {string} DisplayOrderNo attribtue of shipment
	 * @param oldSep {string} old separator sequence
	 * @param newSep {string} new separator sequence
	 * @param displayMultiple {boolean} - optional param to say whethere string MULTIPLE needs to be returned or not
	 */
	shipmentService.getDisplayOrderNumber = function(orderNo, oldSep, newSep, displayMultiple){
		if(!iscCore.isVoid(orderNo)){
			var orderNoArray = orderNo.split(oldSep);
			if ( orderNoArray.length == 1 ) {
				return orderNo;
			}
			else if( orderNoArray.length > 1 && displayMultiple ) {
				return iscI18n.translate('globals.LABEL_MultipleOrders');
			}
			else {
				var escapedOldSep = oldSep.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'); //escape special characters for regular exp
				return orderNo.replace( new RegExp(escapedOldSep, 'g'), newSep);
			}
		}
		return "";
	};
   
	shipmentService.getHoldLocationArr = function(concatString){
		var holdLocationList = {};
		//holdLocationList.={};
		holdLocationList.HoldLocation=[];
		if(!iscCore.isVoid(concatString)){				
			var splitStr = concatString.split(", ");
			for(i=0;i<splitStr.length;i++){
				holdLocationList.HoldLocation[i]={};
				holdLocationList.HoldLocation[i].Location=splitStr[i];
				holdLocationList.HoldLocation[i].toDelete="N";			
			}
		}		
		return holdLocationList;
	};
	
	shipmentService.getHoldLocationString = function(holdLocationTargetModel){
		/*var holdLocationUpdateModel = {};
		holdLocationUpdateModel.Shipment={};*/
		//holdLocationUpdateModel.Shipment.ShipmentKey=shipmentLinePickedModel.Shipment.ShipmentKey;
		var holdLocationStr = "";
		for(i=0;i<holdLocationTargetModel.HoldLocation.length;i++){
			if(i==0){
				holdLocationStr+= holdLocationTargetModel.HoldLocation[i].Location;
			}
			else{
				holdLocationStr+= ", "+holdLocationTargetModel.HoldLocation[i].Location;
			}
		}
		//holdLocationUpdateModel.Shipment.HoldLocation=holdLocationStr;
		return holdLocationStr;
	};
	
	/*shipmentService.validateHoldLocation = function(holdLocationUpdateModel){
		
		if(holdLocationUpdateModel.Shipment.HoldLocation.length<=40){
			return true;
		}
		else{
			return false;
		}
	
	};*/
	
	shipmentService.isHoldLocationDuplicate = function(location,holdLocationTargetModel){
		var isDuplicate = false;
		if(!iscCore.isVoid(holdLocationTargetModel.HoldLocation)){
			for(i=0;i<holdLocationTargetModel.HoldLocation.length;i++){
				if(location==holdLocationTargetModel.HoldLocation[i].Location){
					isDuplicate = true;
					break;
				}				
			}	
			
		}
				
		return isDuplicate;
	};
	
	shipmentService.appendHoldLocation = function(location,holdLocationTargetModel){
		var holdLocation = {};
		holdLocation.Location = location;
		holdLocation.toDelete = "N";
		var inputmodel = angular.copy(holdLocationTargetModel);
		if(iscCore.isVoid(inputmodel)){
			inputmodel = {};
			inputmodel.HoldLocation=[];
		}			
		inputmodel.HoldLocation[inputmodel.HoldLocation.length]=holdLocation;
		
		return inputmodel;
	};

	shipmentService.openProductDetail = function(shipmentLine) {
		
		var itemID = "";
		var itemUOM = "";
		if(shipmentLine.ItemDetails) {
			itemID = shipmentLine.ItemDetails.ItemID;
			itemUOM = shipmentLine.ItemDetails.UnitOfMeasure;
			
		}else if(shipmentLine.OrderLine && shipmentLine.OrderLine.ItemDetails){
			itemID = shipmentLine.OrderLine.ItemDetails.ItemID;
			itemUOM = shipmentLine.OrderLine.ItemDetails.UnitOfMeasure;
		} 
		else {
			itemID = shipmentLine.ItemID;
			itemUOM = shipmentLine.UnitOfMeasure;
		}
		
		var popupInput = {};
		popupInput.ItemDetails = {};
		popupInput.ItemDetails.ItemID = itemID;
		popupInput.ItemDetails.UnitOfMeasure = itemUOM;
        
        var resolveData = {
            modalInput : function(){
				return popupInput;
            }
        };
        
        var modalOptions = {};
        iscModal.openModal('store.views.shipment.common.product-details.product-details',resolveData,modalOptions).then(function(data){},angular.noop);
		
	};
	
	shipmentService.decodeShippingLabelURL = function(modelOutput){
        var htmlStr = modelOutput.Output.out;
        var htmlEle = _parseXml(htmlStr);
        if(!iscCore.isVoid(htmlEle.getElementsByTagName("image"))){
            var imageSource = htmlEle.getElementsByTagName("image")[0].getAttribute("src"); 
            var decodeduri = decodeURIComponent(imageSource);
            htmlStr=htmlStr.replace(imageSource,decodeduri);
            htmlStr=htmlStr.replace("<image","<img");
        }
        
    };
    
    shipmentService.isStatusPresentInList_showSLA = function(status) {
		if (status != null && (status.indexOf("1100.70.06.10") != -1 || status.indexOf("1100.70.06.20") != -1
			|| status.indexOf("1100.70.06.30") != -1 || status.indexOf("1100.70.06.50") != -1
	    	|| status.indexOf("1100.70.06.70") != -1 || status.indexOf("1300") != -1)) {
			return true;
		}
		return false;
	};
	
	shipmentService.isStatusPresentInList_includedInBatch = function(status) {
		if (status != null && (status.indexOf("1100.70.06.10") != -1 || status.indexOf("1100.70.06.20") != -1
			|| status.indexOf("1100.70.06.30") != -1 || status.indexOf("1100.70.06.50") != -1)) {
			return true;
		}
		return false;
	};
	
	shipmentService.isStatusPresentInList_holdLocation = function(status) {
		if (status != null && (status.indexOf("1100.70.06.10") != -1 || status.indexOf("1100.70.06.20") != -1
			|| status.indexOf("1100.70.06.30") != -1 || status.indexOf("1100.70.06.50") != -1
			|| status.indexOf("1100.70.06.70") != -1)) {
			return true;
		}
		return false;
	};
	
	shipmentService.isNumber = function(number) {
		if(number!==null && number!=="" && !isNaN(number)){
			return true;
		} else {
			return false;
		}
	};
	
	
    _parseXml = function(htmlElem) {
        if (window.ActiveXObject) {
            var oXML = new ActiveXObject("Microsoft.XMLDOM"); oXML.loadXML(htmlElem);
            return oXML;
        }
        // code for Chrome, Safari, Firefox, Opera, etc.
        else {
            return (new DOMParser()).parseFromString(htmlElem, "text/xml");
        }
    };
	
	shipmentService.generateProductImageURL = function(shipmentLinesModel) {
		for (var i=0; i< shipmentLinesModel.ShipmentLines.ShipmentLine.length; i++) {
			var currentShipmentLine = shipmentLinesModel.ShipmentLines.ShipmentLine[i];
			if(currentShipmentLine.OrderLine && currentShipmentLine.OrderLine.ItemDetails && currentShipmentLine.OrderLine.ItemDetails.PrimaryInformation) {
				if(currentShipmentLine.OrderLine.ItemDetails.PrimaryInformation.ImageLocation && currentShipmentLine.OrderLine.ItemDetails.PrimaryInformation.ImageID) {
					currentShipmentLine.OrderLine.ItemDetails.PrimaryInformation.ImageURL = currentShipmentLine.OrderLine.ItemDetails.PrimaryInformation.ImageLocation+"/"+currentShipmentLine.OrderLine.ItemDetails.PrimaryInformation.ImageID;
				}
			}
		}
	};
	
	
	shipmentService.prepareGetShipmentListApiInput = function(orderByDesc,deliveryMethod,statusArray){
		
		  
		  var apiInput = {};
		  apiInput.Shipment = {};
		  apiInput.Shipment.DeliveryMethod = deliveryMethod;
		  apiInput.Shipment.ComplexQuery={};
		  apiInput.Shipment.ComplexQuery.And={};
		  apiInput.Shipment.ComplexQuery.And.Or=[];
		  apiInput.Shipment.ComplexQuery.And.Or[0] = {};
		  apiInput.Shipment.ComplexQuery.And.Or[0].Exp=[];
		  
		  
		   for(var k= 0; k<statusArray.length ; k++){
			    apiInput.Shipment.ComplexQuery.And.Or[0].Exp[k]={};
			    apiInput.Shipment.ComplexQuery.And.Or[0].Exp[k].Name='Status';
			    apiInput.Shipment.ComplexQuery.And.Or[0].Exp[k].QryType='FLIKE';
			    apiInput.Shipment.ComplexQuery.And.Or[0].Exp[k].Value= statusArray[k];
				
			}
		    apiInput.Shipment.ComplexQuery.And.Or[1] = {};
		    apiInput.Shipment.ComplexQuery.And.Or[1].Exp=[];
		    apiInput.Shipment.ComplexQuery.And.Or[1].Exp[0]={};
		    apiInput.Shipment.ComplexQuery.And.Or[1].Exp[0].Name= 'DocumentType';
		    apiInput.Shipment.ComplexQuery.And.Or[1].Exp[0].Value= '0001';
		    apiInput.Shipment.ComplexQuery.And.Or[1].Exp[1]={};
		    apiInput.Shipment.ComplexQuery.And.Or[1].Exp[1].Name= 'DocumentType';
		    apiInput.Shipment.ComplexQuery.And.Or[1].Exp[1].Value= '0006';
		  
		 
		  if(!iscCore.isVoid(orderByDesc)){
			    apiInput.Shipment.OrderBy = {};
				apiInput.Shipment.OrderBy.Attribute = {};  
				apiInput.Shipment.OrderBy.Attribute.Desc= orderByDesc;  
		  }
		    
		
		  return apiInput;
		
	};

	shipmentService.prepareShipmentListApiInput = function(originalApiInput,statusArray,documentTypeArray,deliveryMethod,orderByDesc){
		
		var apiInput = angular.copy(originalApiInput);
		var shipment = iscCore.getValueFromJsonPath(apiInput,"Shipment",true);
		var andObj = iscCore.getValueFromJsonPath(shipment,"ComplexQuery.And",true);
		andObj.Or=[];

		//prepare status complex query
		if(!statusArray)statusArray=iscShipmentStatus.getShipmentStatusCodeList("All");
		andObj.Or[0] = {};
		andObj.Or[0].Exp=[];
		for(var k= 0; k<statusArray.length ; k++){
			andObj.Or[0].Exp[k]={"Name":"Status","QryType":"FLIKE","Value":statusArray[k]};
		}

		//prepare document type complex query
		if(!documentTypeArray)documentTypeArray=['0001','0006'];
		andObj.Or[1] = {};
		andObj.Or[1].Exp=[];
		for(var i= 0; i<documentTypeArray.length ; i++){
			andObj.Or[1].Exp[i]={"Name":"DocumentType","QryType":"FLIKE","Value":documentTypeArray[i]};
		}
		
		//prepare other inputs
		if(!iscCore.isVoid(deliveryMethod))shipment.DeliveryMethod = deliveryMethod;
		if(!iscCore.isVoid(orderByDesc)){
			shipment.OrderBy = {};
			shipment.OrderBy.Attribute = {};  
			shipment.OrderBy.Attribute.Desc= orderByDesc;  
		}

		return apiInput;
		
	};
     
   return shipmentService;
 }]);




/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp.  2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/

/**
 * @ngdoc service
 * @name iscObjectUtility
 * 
 * 
 * @description 
 * Handles all the common tasks related to any javascript object. 
 * 
 */
 
angular.module('isc.shared').factory('iscDomUtility', ["$timeout",
 function($timeout) {

   var domUtilityService = {};

   domUtilityService.setFocus = function(focusElement, timeOutInterval){
	   
	   if(iscCore.isVoid(timeOutInterval)){
		   var timeOutInterval = 500;
	   }
   
	   if(focusElement) {
		   
		   $timeout(function (){
				
				if(!focusElement.hasAttribute('readonly')) {
					focusElement.setAttribute('readonly','readonly');
				}
				focusElement.autofocus = true;
				
				$timeout(function (){
					focusElement.focus();
					focusElement.removeAttribute('readonly');
			    }, 50);
				
				
		    }, timeOutInterval);
	   }
  	
    };
  
   return domUtilityService;
}]);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/

/**
 * @ngdoc service
 * @name iscObjectUtility
 * 
 * 
 * @description 
 * Handles all the common tasks related to any javascript object. 
 * 
 */
 
angular.module('isc.shared').factory('iscObjectUtility', [
 function() {

   var objectUtilityService = {};
    /**
	 * @ngdoc method
	 * @name iscObjectUtility#sanitizeObject
	 * @description
	 * The sanitizeObject removes blank or undefined properties from an object.
	 * @param obj {object} Object
	 * @example			
			iscObjectUtility.sanitizeObject(object);
	 */
   objectUtilityService.sanitizeObject = function(obj){
   
                   for (var prop in obj) {
						if (obj.hasOwnProperty(prop)) {
						     if(obj[prop] == 'undefined' || obj[prop] === undefined || obj[prop] == 'null' || obj[prop] === null){
							    delete obj[prop];
							}
						}
					}
	
	   return obj;
  	
    };
    /**
	 * @ngdoc method
	 * @name iscObjectUtility#isEmpty
	 * @description
	 * The isEmpty returns true if an object is empty.
	 * @param obj {object} Object
	 * @example			
			iscObjectUtility.isEmpty(object);
	 */
    objectUtilityService.isEmpty = function(obj){
    	if(obj != null){
    		for(var property in obj){
    			return false;
    		}
    	}
    	return true;
    };
    /**
	 * @ngdoc method
	 * @name iscObjectUtility#isNumLessThan
	 * @description
	 * The isNumLessThan returns true if a number (first argument) is less than the other (second argument).
	 * @param obj1 {object} Object1
	 * @param obj2 {object} Object2
	 * @example			
			iscObjectUtility.isNumLessThan(object1, object2);
	 */
    objectUtilityService.isNumLessThan = function(obj1,obj2){
    	return parseFloat(obj1, 10)<parseFloat(obj2, 10);
    };
    /**
	 * @ngdoc method
	 * @name iscObjectUtility#isGreaterThanZero
	 * @description
	 * The isGreaterThanZero returns true if a number is greater than zero.
	 * @param obj {object} Object1
	 * @example			
			iscObjectUtility.isGreaterThanZero(object);
	 */
    objectUtilityService.isGreaterThanZero = function(obj){
    	return parseFloat(obj, 10) > 0;
    };
    /**
	 * @ngdoc method
	 * @name iscObjectUtility#isLessThanZero
	 * @description
	 * The isLessThanZero returns true if a number is less than zero.
	 * @param obj {object} Object1
	 * @example			
			iscObjectUtility.isLessThanZero(object);
	 */
    objectUtilityService.isLessThanZero = function(obj){
    	return parseFloat(obj, 10) < 0;
    };
     /**
	 * @ngdoc method
	 * @name iscObjectUtility#trimString
	 * @description
	 * The trimString trims the value of a string.
	 * @param objString {string} String
	 * @example			
			iscObjectUtility.trimString(string);
	 */
    objectUtilityService.trimString = function(objString){
    	if(objString != null){
    		return objString.trim();
    	}
    	else {
    		return null;
    	}
    };
    /**
	 * @ngdoc method
	 * @name iscObjectUtility#isStringVoid
	 * @description
	 * The isStringVoid returns true if an object is a void/empty string.
	 * @param str {string} String
	 * @example			
			iscObjectUtility.isStringVoid(string);
	 */
    objectUtilityService.isStringVoid = function(str){
		if(str){
			if(str.trim() === ''){
				return true;
			}
			else {
				return false;
			}
		}
		else {
			return true;
		}
	};
	
	/**
	 * @ngdoc method
	 * @name iscObjectUtility#stringStartsWith
	 * @description
	 * The stringStartsWith returns true if an String (first arguemnt) starts with a given String (second argument).
	 * @param str {string} String
	 * @param prefix {string} String
	 * @example			
			iscObjectUtility.stringStartsWith(string1, string2);
	 */
    objectUtilityService.stringStartsWith = function(str, prefix){
		if(str && prefix && str.length >= prefix.length){
			return str.slice(0, prefix.length) == prefix;
		}
		return false;
	};
	
	
	objectUtilityService.compareDates = function(firstDate, secondDate, operation, considerTime) {
		
		var result = false;
		
		if(!firstDate)
			firstDate = new Date();
		
		if(!secondDate)
			secondDate = new Date();
		
		firstDate = new Date(firstDate);
		firstDate = new Date(firstDate.valueOf() + firstDate.getTimezoneOffset() * 60000); // Convert to GMT 0 by considering TimezoneOffset
		secondDate = new Date(secondDate);
		secondDate = new Date(secondDate.valueOf() + secondDate.getTimezoneOffset() * 60000); // Convert to GMT 0 by considering TimezoneOffset
		
		if(!considerTime) {
			firstDate = new Date(firstDate.toDateString());
			secondDate = new Date(secondDate.toDateString());
		}
		
		switch(operation) {
		
		case "EQ" :
			
			result = firstDate.valueOf() == secondDate.valueOf() ? true : false;
			break;
			
		
		case "GTE" :	
			
			result = firstDat.valueOf() >= secondDate.valueOf() ? true : false;
			break;
			
		case "LTE" :	
			
			result = firstDate.valueOf() <= secondDate.valueOf() ? true : false;
			break;
			
		case "GT" :	
			
			result = firstDate.valueOf() > secondDate.valueOf() ? true : false;
			break;
			
		case "LT" :	

			result = firstDate.valueOf() < secondDate.valueOf() ? true : false;
			break;
		
		}
			
		
		return result;
		
		
	};
	
	objectUtilityService.isNumber = function(value) {
		if(value !== null && value !== "" && !isNaN(value)){
			return true;
		} else {
			return false;
		}
	};
	
	objectUtilityService.removeDupilcatesFromArray = function(objectArray) {
		
		if(objectArray !== null && objectArray !== "" && objectArray.length > 0){
			
			for(var i=0; i<objectArray.length; ++i) {
		        for(var j=i+1; j<objectArray.length; ++j) {
		            if(objectArray[i] === objectArray[j])
		            	objectArray.splice(j--, 1);
		        }
		    }

		    return objectArray;
		} 
		
		return objectArray;
	};
  
   return objectUtilityService;
}]);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/

/**
 * @ngdoc service
 * @name iscWizardService
 * @requires iscScreen
 * 
 * 
 * @description 
 * Handles all the common tasks related to wizard. 
 * <br/><br/>Dependency injection - iscWizard
 */

angular.module('isc.shared').factory('iscWizard', ['iscScreen','iscModal','iscI18n', function(iscScreen,iscModal,iscI18n) {
	var _currentWizardData  = {};
	
	var iscWizard = {};
	
	var _wizardController;
	
	var _wizardPageController;
	
	var _wizardAction;
	
	var _wizardPageInput;
	
	var _wizardPageOptions;
	
	var _wizardContext = {};
	
	iscWizard.clearWizard = function(){
	  _currentWizardData = {};
	  _wizardController = null;
	  _wizardPageController = null;
	  _wizardAction = null;
	  _wizardPageInput = null;
	  _wizardPageOptions = null;
	  _wizardContext = {};
	};
	
	
	/**
	 * @ngdoc method
	 * @name iscWizardService#setWizardModel
	 * @description Sets the model at wizard level.
	 * 
	 * @param namespace {string} Namespace of the model
	 * @param model {object} Model object to be set 
	 * 
	 */
	
	iscWizard.setWizardModel = function(namespace,model){
		_currentWizardData[namespace] = model;		
	};
	
	/**
	 * @ngdoc method
	 * @name iscWizardService#getWizardModel
	 * @description Returns the wizard for the specified namespace
	 * 
	 * @param namespace {string} Namespace of the model
	 * 
	 * @returns Wizard model
	 */
	iscWizard.getWizardModel = function(namespace){		
		return _currentWizardData[namespace];
	};
	/*
	iscWizard.applyWizardModelToPage = function(model){		
		for(key in _currentWizardData){
			model[key] = _currentWizardData[key];			
		}
	};
	*/
	iscWizard._setWizardController = function(ctrl){
	  _wizardController = ctrl;
	};
	
	iscWizard._setWizardPageController = function(ctrl){
	  _wizardPageController = ctrl;
	};
	
	iscWizard.getWizardPageController = function(){
	  return _wizardPageController;
	};
	
	iscWizard._setWizardAction = function(action){
	  _wizardAction = action;
	};
	
	/**
	 * @ngdoc method
	 * @name iscWizardService#getWizardAction
	 * @description Returns the wizard action for the current page. Wizard action can be NEXT|PREVIOUS
	 * 
	 * 
	 * @returns Returns the wizard action for the current page. Wizard action can be NEXT|PREVIOUS
	 */
	iscWizard.getWizardAction = function(){
	  return _wizardAction;
	};
	
	iscWizard._setWizardPageOptions = function(pageOptions){
		_wizardPageOptions = pageOptions;
	};
	
	
	iscWizard.getWizardPageOptions = function(){
		  return _wizardPageOptions;
		};
	/**
	 * @ngdoc method
	 * @name iscWizardService#getWizardPageInput
	 * @description Returns the wizard page input for the current page.
	 * 
	 * @returns Wizard page input for the current page
	 */
	
	iscWizard.getWizardPageInput = function(){
	  return _wizardPageInput;
	};
	
	
	
	iscWizard._setWizardPageInput = function(pageInput){
		  _wizardPageInput = pageInput;
		};
		
	/**
	 * @ngdoc method
	 * @name iscWizardService#isFirstPage
	 * @description Returns boolean true if the current wizard page is the first page else boolean false
	 * 
	 * @returns boolean true if the current wizard page is the first page else boolean false
	 */
	iscWizard.isFirstPage = function(){
		return _wizardController.isFirstPage();	
	}
	
	/**
	 * @ngdoc method
	 * @name iscWizardService#gotoNextPage
	 * @description Navigates the wizard to the next page in case of custom transition is set to false
	 * 
	 */
	
	iscWizard.gotoNextPage = function(){
	  _wizardController.gotoNextPage();
	};
	
	/**
	 * @ngdoc method
	 * @name iscWizardService#gotoPreviousPage
	 * @description Navigates the wizard to the previous page
	 * 
	 * @param force {boolean} When true navigates the previous page without giving control to current page
	 */
	
	iscWizard.gotoPreviousPage = function(force){
	  _wizardController.gotoPreviousPage(force);
	};
	
	/**
	 * @ngdoc method
	 * @name iscWizardService#startWizard
	 * @description Starts the wizard and navigates to the first page of the wizard in case of custom transition is set to false
	 * 
	 */
	
	iscWizard.startWizard = function(){
	  _wizardController.startWizard();
	};
	
	/**
	 * @ngdoc method
	 * @name iscWizardService#startCustomWizard
	 * @description Starts the wizard and navigates to the custom page of the wizard in case of custom transition is set to true
	 * 
	 * @param pageId {string} ID of the wizard page to show
	 * @param pageInput {object} Input object to the wizard page
	 * @param pageOptions {object} additional options to the wizard page
	 */
	iscWizard.startCustomWizard = function(pageId,pageInput,pageOptions){
	  _wizardController.startCustomWizard(pageId,pageInput,pageOptions);
	};
	
	/**
	 * @ngdoc method
	 * @name iscWizardService#finishWizard
	 * @description Finishes the wizard and navigates to the wizard finish view
	 */
	
	iscWizard.finishWizard = function(){
	  _wizardController.finishWizard();
	};
	
	/**
	 * @ngdoc method
	 * @name iscWizardService#closeWizard
	 * @description Closes the wizard and navigates to the wizard finish view
	 */
	
	iscWizard.closeWizard = function(){
	  _wizardController.closeWizard();
	};
	
	/**
	 * @ngdoc method
	 * @name iscWizardService#exitWizard
	 * @description Exits the wizard
	 */
	iscWizard.exitWizard = function(){
		_wizardController._exitWizard();	
	}
	/**
	 * @ngdoc method
	 * @name iscWizardService#gotoCustomPage
	 * @description Navigates to the custom page of the wizard in case of custom transition is set to true
	 * 
	 * @param pageId {string} ID of the wizard page to show
	 * @param pageInput {object} Input object to the wizard page
	 * @param pageOptions {object} additional options to the wizard page
	 */
	iscWizard.gotoCustomPage = function(pageId,pageInput,pageOptions){
	  _wizardController.gotoCustomPage(pageId,pageInput,pageOptions);
	};
	
	iscWizard._clearWizardModel = function(){
		_currentWizardData = {};
	};
	
	/**
	 * @ngdoc method
	 * @name iscWizardService#initializeWizardPage
	 * @description Initializes the page $scope with control object and calls initialize method of the wizard page
	 * 
	 * @param $scope {object} Scope object of the wizard page controller
	 * @param control {object} Implementation object of the wizard page	 
	 * @example
	 		iscWizard.initializeWizardPage($scope,{
				//define the models used in the view
				model:{
					"viewModal1":{}
				},
				//define the mashups used in the view
				mashupRefs:[
					{
						mashupRefId:"mashuprefid1",
						mashupId:"mashupid1",
						modelName:"model1"
					}				
				],
				ui:{
					//ui properties goes here
				},				
				initialize:function(){
					//view initialization code goes here
				},
				//define the ui methods that can be called from html with ui as prefix
				uiApply:function(){
				
				},
				//define helper methods
				helpMethod1:function(){
				
				},
				//define the private methods with _
				_privateMethod1:function(){
				
				}			
			});
	 */
	iscWizard.initializeWizardPage = function($scope,control){		
		//iscWizard.applyWizardModelToPage(control.model);
		iscWizard._setWizardPageController(control);
		iscScreen.initializeScreen($scope,control);
	};
	
	/**
	 * @ngdoc method
	 * @name iscWizardService#setWizardContext
	 * @description Stores a key-value pair combination in the current wizard context. This value can be used by any page in the wizard flow
	 * 
	 * @param key {string} Key referring to identify the value stored in a wizard context 
	 * @param value {string} Value stored in the wizard context
	 */
	iscWizard.setWizardContext = function(key,value) {
		_wizardContext[key] = value;
	}
	
	/**
	 * @ngdoc method
	 * @name iscWizardService#getWizardContext
	 * @description Gets the value stored in a wizard context for the key passed in as input
	 * 
	 * @param key {string} Key that identifies the value stored in the wizard context
	 */
	iscWizard.getWizardContext = function(key) {
		return _wizardContext[key];
	};
	
	
    /**
	 * @ngdoc method
	 * @name iscWizardService#handleWizardBack
	 * @description Generic handling for wizard back
	 * 
	 * @param isDirty {boolean} Flag to indicate the screen is dirty
     * @param confirmationMessage {String} Bundle key for confirmation message
	 */
    iscWizard.handleWizardBack = function(isDirty,confirmationMessage) {

        var isFirstPage = iscWizard.isFirstPage();

        if(isDirty && isFirstPage){
            iscModal.showConfirmationMessage(iscI18n.translate('globals.MSG_Screen_dirty'))
                .then(function(callBackAction){
                    if(callBackAction === 'YES'){
                        iscWizard.closeWizard();
                    }
                },angular.noop);
            return true;
        } else if(isFirstPage) {
            iscModal.showConfirmationMessage(iscI18n.translate(confirmationMessage))
                .then(function(callBackAction){
                    if(callBackAction === 'YES'){
                        iscWizard.closeWizard();
                    }
                },angular.noop);
            return true;
        } else {
            return false;
        }
    };
    
    /**
	 * @ngdoc method
	 * @name iscWizardService#handleWizardExitAndClose
	 * @description Generic handling for wizard exit and close
	 * 
     * @param wizardAction {String} Wizard action
	 * @param isDirty {boolean} Flag to indicate the screen is dirty
     * @param confirmationMessage {String} Bundle key for confirmation message
	 */
    iscWizard.handleWizardExitAndClose = function(wizardAction,isDirty,confirmationMessage) {
        if(isDirty) {
            iscModal.showConfirmationMessage(iscI18n.translate('globals.MSG_Screen_dirty'))
                .then(function(popupAction){
                    if(popupAction === 'YES'){
                        wizardAction == 'close' ? iscWizard.closeWizard(): iscWizard.exitWizard();
                    }
                },angular.noop);
        } else {
            iscModal.showConfirmationMessage(iscI18n.translate(confirmationMessage)).then(function(popupAction){
                if(popupAction === 'YES'){
                    wizardAction == 'close' ? iscWizard.closeWizard(): iscWizard.exitWizard();
                }
            },angular.noop);
        }
        return true;
    };
    
	return iscWizard;
	
	
}]);
	
	
	
	
	

/******************************************************************************* 
* IBM Confidential 
* OCO Source Materials 
* IBM Sterling Order Management Store (5725-D10) 
* (C) Copyright IBM Corp. 2016 All Rights Reserved. 
* The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office. 
******************************************************************************/




/**
 * @ngdoc directive
 * @name iscApplyCouponEditOrder
 * @restrict E
 *
 * @description
 * Displays the coupon information associated with an order. If there are no coupons associated with the order, message indicating the same is displayed
 *
 * @scope
 * @param {Object=} ordermodel - Model containing order details with total number of lines and the Promotion element
 * @param {String=} orderdetailsmashupid - Mashup id to be called after changeOrder is called to add or remove the coupon. Default value is store.views.order.modification.getCompleteOrderDetails.
 * @param {String=} coupon-applied-callback - call backhandler method in the screen which will be invoked after changeOrder is called to add or remove the coupon.
 * @example
 *  The HTML will have the directive specified like below:
 *   <div>
 *      <isc-apply-coupon ordermodel="model.getCompleteOrderDetails" orderdetailsmashupid="'store.views.order.modification.getCompleteOrderDetails'"
					 coupon-applied-callback="uiCouponApplied"></isc-apply-coupon>		
 *   </div>
 */

(function(iscCore){
angular.module('isc.shared').directive('iscAlerts', function() {
	return {
		restrict: 'E',
		
		    link: function (scope, element, $attr, ctrl, $transclude){
	            // link parent controller's function and invoke them accordingly.
	            scope.postCallbackData = function(orderDetails){
	               var callbackHandler = scope.couponAppliedCallback;
	               callbackHandler(orderDetails);
	            };
	         },
		    controller:['$scope','$document','$timeout','iscMashup','iscWizard','iscModal','iscAppContext','iscI18n','iscResourcePermission',function($scope,$document,$timeout,iscMashup,iscWizard,iscModal,iscAppContext,iscI18n,iscResourcePermission){
				$scope.popOverTemplate = 'store/views/alerts/alerts-preview.tpl.html';
				$scope.ui = {
				
				};
				$scope.ui.showPopover=false;
				$scope.initialize = function(){
				
					var apiInput={};
		  			apiInput.getAlertStatisticsForUser={};
		  			iscMashup.callSimpleMashup($scope,"getAlertStatisticsForUser",apiInput,{}).then($scope.handleGetExceptionListForUser.bind($scope));
		  				
	            };
				
				$scope.handleSuccess = function(response){
				
					if($scope.ui.showPopover){
						$scope.ui.showPopover=false;
					
					} else {
					
					
						var output = iscMashup.getSimpleMashupOutput(response,"getAlertStatisticsForUser");
						if(!output.getAlertStatisticsForUser){
							return;
						}
						$scope.model = output;
						$scope.ui.showPopover=true;
						
					}

				};

				
				$scope.uiOpenAlerts = function(){
						var apiInput={};
		  				apiInput.Inbox={};
		  				iscMashup.callSimpleMashup($scope,"getAlertStatisticsForUser",apiInput,{}).then($scope.handleSuccess.bind($scope));
				};
				
				$scope.handleGetExceptionListForUser = function(response){
					var output = iscMashup.getSimpleMashupOutput(response,"getAlertStatisticsForUser");
					$scope.model = output;
				};
				
				$scope.uiAlertSearchClose = function(){
					$scope.$emit('uiAlertSearchClose',{});
				};
				
				$scope.initialize();
			}],
		templateUrl: './store/views/alerts/alerts-preview.tpl.html'
	};
});
})(window.iscCore);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
angular.module("isc.shared").directive("iscCommonValidations", iscCommonValidationsFn);

/**
 * @ngdoc directive
 * @name iscCommonValidations
 * @restrict A
 * @requires iscI18n
 *
 * @description
 * 	'iscCommonValidations' is a directive that will carry out the default html validations like: required and pattern (and their ng- equivalents)
 *	and update the $error object on form field with appropriate message. It is included by default in isc-input directive. It can be used with
 *	other fields as well.
 *	This directive requires that the field have a name and be present in a form with name.
 *  
 * @example
 *  Sample html with directive:
 *		<div ng-form="sampleForm">
 *			<input type="text" name="qty" ng-model="orderLine.OrderLineTranQuantity.OrderedQty"
 *				isc-common-validations class="form-control quantity-box" required />
 *		</div>
 */

iscCommonValidationsFn.$inject = ["iscI18n"];
function iscCommonValidationsFn(iscI18n) {
	return {
		restrict: "A",
		priority: 10,
		require: "?^form",
		link: function(scope, element, attributes, formController) {
			var formName = "",
				name = attributes["name"] || attributes["ngName"],
				currCtrl = null;
			if (formController == null) {
				console.warn("isc-common-validations is used in element outside form. Skipping. Element id given: %s , Element name given: %s", element.attr("id"), element.attr("name"));
				return;
			}
			formName = formController.$name;
			if (formName == null || formName == "") {
				console.warn("isc-common-validations is used in form element without name. Skipping. Element id given: %s , Element name given: %s", element.attr("id"), element.attr("name"));
				return;
			}
			if (name == null || name == "") {
				console.warn("isc-common-validations is used in element without a name. Skipping. Form name given: %s , Element id given: %s", formController.$name, element.attr("id"));
				return;
			}
			if (scope[formName] != null) {
				currCtrl = scope[formName][name];
			} else if (formController[name] != null) {
				currCtrl = formController[name];
			} else {
				console.warn("isc-common-validations unexpected scenario. Could not obtain control instance in form to add validators. Form name given: %s , Element id given: %s", formController.$name, element.attr("id"));
			}
			
			if (currCtrl && currCtrl.$validators != null) {
// TODO: Manage the error message. Currently, we are relying on Angular's ctrl.$error to do the job. This may be risky.
				currCtrl.$validators.iscCommonDefaultValidations = function(modelValue, viewValue) {
					// ignore $errorObj.required etc and set this one. This must get called before datatype directive's validators.
					var angularErrorObj = currCtrl.$error,
						returnResponse = true,
						errorMsg = "";
					angularErrorObj._iscValidation_msg_obj = {};
					delete angularErrorObj.iscCommonDefaultValidations;
					delete angularErrorObj.iscDatatypeValidator;
					delete angularErrorObj.iscCustomValidator;
					// Others possibly are: min, max, step, maxlength.
					if (angularErrorObj.required) {
						errorMsg = iscI18n.translate("validation.ERROR_mandatory");
						returnResponse = false;
					} else if (angularErrorObj.pattern) {
						errorMsg = iscI18n.translate("datatypevalidation.error_input_does_not_conform_pattern");
						returnResponse = false;
					}
					
					if (returnResponse) {
						delete angularErrorObj.iscValidation_msg;
						delete angularErrorObj._iscValidation_msg_obj;
						// For BC only, delete later:
						delete angularErrorObj.iscDatatypeValidator_msg;
					} else {
						angularErrorObj.iscValidation_msg = errorMsg;
						angularErrorObj._iscValidation_msg_obj["iscCommonDefaultValidations"] = errorMsg;
						// For BC only, delete later:
						angularErrorObj.iscDatatypeValidator_msg = errorMsg;
					}
					return returnResponse;
				}
			}
		}
	};
}
/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
angular.module("isc.shared").directive("iscDatatype", iscDatatypeFn);

/**
 * @ngdoc directive
 * @name iscDatatype
 * @restrict A
 * @requires iscDatatypeManager
 *
 * @description
 * 	'iscDatatype' is a directive that provides validation based on datatype derived from binding. Datatype corresponds to the
 * 	sterling datatype.
 * 	
 * 	Usage options:
 * 	1. Just provide isc-datatype. Set it as-is or as a blank string.
 * 		- Directive will try to derive the datatype based on binding.
 * 		- If nothing can be identified, then default regex based validations will occur when application is in production mode.
 *  2. isc-datatype = "some user entered string value".
 *  	- Directive will try to use the user entered datatype value as datatype.
 *  	- If it is null, then it will try to derive datatype based on binding.
 *  	- If nothing can be identified, then default regex based validations will occur when application is in production mode.
 *  3. isc-datatype = "{'datatype': 'OPTIONAL', 'customValidator': 'MANDATORY', 'useOnlyCustomValidator': 'BOOLEAN VALUE, OPTIONAL'}"
 *  	Provide a json with above three attributes.
 *  		- **datatype** - '{string}' - OPTIONAL. Enter a string value for datatype. It works in the same way as option#2.
 *  		- **customValidator** - '{function(validationResponseObj, angularErrorObject, modelValue, viewValue)}' - MANDATORY. Provide
 *  			the custom validator method to be invoked. As per convention, it must begin with 'ui'. Arguments are:
 *  				- **validationResponseObj** - '{object}' - Json object returned by any previous validator(s). It contains the
 *  					attributes: 'booleanResponse'(boolean) and 'errorMesssage'(string).
 					- **angularErrorObject** - '{object}' - Json object containing the $error object provided by angular.
 *  				- **modelValue** - '{string}' - Value in the model.
 *  				- **viewValue** - '{string}' - Value displayed in ui.
 *  			This method is expected to return a json object in the format of validationResponseObj.
 *  		- **useOnlyCustomValidator** - '{boolean}' - OPTIONAL. Defaults to false and the default validator will be invoked
 *  			followed by the customValidator. Set it as true if you want to use only the customValidator.
 *  
 * Changes required to consume/display the errors as a result of validation: 
 *  1. Fields to be validated must be input fields and use ng-model for binding.
 *  2. Declare the field datatype using the isc-datatype attribute directive with any one of the three usage options.
 *  3. CSS to be defined to show the invalid state on field: ng-invalid ng-invalid-isc-datatype-validator. This is set by angular
 *  	once validation fails.
 *  4. Use a form element or ng-form attribute in the parent. This is required to test the $valid and access the $error object.
 *  	The field also should ideally be given the name attribute.
 *  5. The error state: true or false can be accessed using the iscDatatypeValidator attribute i.e. $error.iscDatatypeValidator.
 *  	This will be required in cases where you are triggering some functions onblur or value change of a field being validated.
 *  6. Error message: The error message with globalized error picked from bundle can be accessed using the iscValidation_msg
 *  	attribute i.e. $error.iscValidation_msg.
 *  
 * @example
 *  Sample html with directive:
 *		<div class="col-sm-2 col-xs-3 form-group" ng-form="sampleForm">
 *			<input type="text" name="qty" ng-model="orderLine.OrderLineTranQuantity.OrderedQty"
 *				isc-datatype ng-blur="sampleForm.qty.$valid ? uiEditQuantity(orderLine) : null"
 *				class="form-control quantity-box" />
 *			<span ng-show="sampleForm.qty.$error.iscDatatypeValidator">
 *				{{sampleForm.qty.$error.iscValidation_msg}}
 *			</span>
 *		</div>
 */

iscDatatypeFn.$inject = ["iscDatatypeManager"];
function iscDatatypeFn(iscDatatypeManagerProvider) {
	return {
		restrict: "A",
		scope: true,
		require: "?ngModel",
		priority: 100,
		link: function(scope, element, attributes, ctrl) {
			var iscDatatype = attributes.iscDatatype,
				ngModel = attributes.ngModel,
				ngBind = attributes.ngBind,
				iscDatatypeConfigObj = null,
				datatypeObj = null,
				validationResponseObj = {};
				
			var fn_updateErrorMsgAndReturnResponse = function(angularErrorObj, errorKey) {
				if (angularErrorObj._iscValidation_msg_obj == null) {
					angularErrorObj._iscValidation_msg_obj = {};
				}

				if (validationResponseObj.errorMesssage === "") {
					delete angularErrorObj.iscValidation_msg;
					delete angularErrorObj._iscValidation_msg_obj;
					// For BC only, delete later:
					delete angularErrorObj.iscDatatypeValidator_msg;
				} else {
					angularErrorObj.iscValidation_msg = validationResponseObj.errorMesssage;
					angularErrorObj._iscValidation_msg_obj[errorKey] = validationResponseObj.errorMesssage;
					// For BC only, delete later:
					angularErrorObj.iscDatatypeValidator_msg = validationResponseObj.errorMesssage;
				}
				return validationResponseObj.booleanResponse;
			};
				
			// check if isc-datatype is a string or a config string.
			if (iscDatatype != null && iscDatatype.indexOf != null && iscDatatype.indexOf("{") != -1) {
				// TODO: Following attributes are allowed: "datatype", "customValidator" (mandatory), "useOnlyCustomValidator".
				iscDatatypeConfigObj = scope.$eval(iscDatatype);
				iscDatatype = iscDatatypeConfigObj.datatype;
				if (iscDatatypeConfigObj.customValidator == null) {
					throw new Error("'isc-datatype' configuration object is missing mandatory parameter 'customValidator'. If it is not required, then pass 'isc-datatype' as a string or blank.")
				}
			}
			if (iscDatatypeConfigObj == null || (iscDatatypeConfigObj != null && iscDatatypeConfigObj.useOnlyCustomValidator !== true)) {
				// remove filters from ngModel and ngBind
				if (ngModel && ngModel.indexOf("|") != -1) {
					ngModel = ngModel.substring(0, ngModel.indexOf("|")).trim();
				}
				if (ngBind && ngBind.indexOf("|") != -1) {
					ngBind = ngBind.substring(0, ngBind.indexOf("|")).trim();
				}
				datatypeObj = iscDatatypeManagerProvider.getDatatypeFor(iscDatatype, ngModel, ngBind, element, scope);
			}
			
			if (ctrl && ctrl.$validators != null) { 
				ctrl.$validators.iscDatatypeValidator = function(modelValue, viewValue) {
					// TODO: Manage the error message. Currently, we are relying on Angular's ctrl.$error to do the job. This may be risky.
					var angularErrorObj_datatype = (ctrl && ctrl.$error) ? ctrl.$error : {};
					validationResponseObj = {"errorMesssage": "", booleanResponse: true};
					// clear out obj and msgs.
					if (!angularErrorObj_datatype.iscCommonDefaultValidations) {
						// Either common-validations was not done OR result is valid, clear all msgs that come later in chain.
						delete angularErrorObj_datatype.iscValidation_msg;
						delete angularErrorObj_datatype._iscValidation_msg_obj;
						// For BC only, delete later:
						delete angularErrorObj_datatype.iscDatatypeValidator_msg;
					} else {
						delete angularErrorObj_datatype._iscValidation_msg_obj["iscDatatypeValidator"];
						delete angularErrorObj_datatype._iscValidation_msg_obj["iscCustomValidator"];
					}
					delete angularErrorObj_datatype.iscDatatypeValidator;
					delete angularErrorObj_datatype.iscCustomValidator;
					
					if (iscDatatypeConfigObj != null && iscDatatypeConfigObj.useOnlyCustomValidator === true) {
						// do nothing...
					} else {
// TODO: Do we need to validate modelValue as well?
						validationResponseObj = datatypeObj == null ? {"errorMesssage": "", booleanResponse: true} : datatypeObj.getValidationResponseObj(viewValue);
					}
					if (angularErrorObj_datatype.iscCommonDefaultValidations) {
						// If common-validations says invalid, ignore datatype validation result but must go ahead with custom validations.
						// Disadvantage of this approach is that $error.iscDatatypeValidator and $error._iscValidation_msg_obj["iscDatatypeValidator"] gets same state and msg as iscCommonDefaultValidations.
						validationResponseObj = {
							"errorMesssage": angularErrorObj_datatype.iscValidation_msg,
							"booleanResponse": false
						};
					}
					return fn_updateErrorMsgAndReturnResponse(angularErrorObj_datatype, "iscDatatypeValidator");
				};
				
				if (iscDatatypeConfigObj != null) {
					ctrl.$validators.iscCustomValidator = function(modelValue, viewValue) {
						// TODO: Manage the error message. Currently, we are relying on Angular's ctrl.$error to do the job. This may be risky.
						var angularErrorObj_custom = (ctrl && ctrl.$error) ? ctrl.$error : {};
						// clear out obj and msgs.
						if (!angularErrorObj_custom.iscCommonDefaultValidations && !angularErrorObj_custom.iscDatatypeValidator) {
							// common-validations and datatype validations were not done OR result is valid for both, clear all msgs that come later in chain.
							delete angularErrorObj_custom.iscValidation_msg;
							delete angularErrorObj_custom._iscValidation_msg_obj;
							// For BC only, delete later:
							delete angularErrorObj_custom.iscDatatypeValidator_msg;
						} else {
							// common-validations or datatype validations were not done OR result is valid for either, clear all msgs that come later in chain.
							delete angularErrorObj_custom._iscValidation_msg_obj["iscCustomValidator"];
						}
						delete angularErrorObj_custom.iscCustomValidator;
					
						// custom validations always take priority, conflict to be handled by implementer.
						validationResponseObj = iscDatatypeConfigObj.customValidator(validationResponseObj, angularErrorObj_custom, modelValue, viewValue);
						return fn_updateErrorMsgAndReturnResponse(angularErrorObj_custom, "iscCustomValidator");
					}
				}
			}
		}
	};
}
/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/

/**
 * @ngdoc directive
 * @name iscDynamicController
 * @restrict A
 * 
 * @description Assigns a controller dynamically
 * 
 * @param {string} iscDynamicController Controller name or a scope variable containing controller name
 * 
 * @example
    <!-- to assign a controller with a dynamic controller name
    <div  isc-dynamic-controller="portlet.controller">
 */


angular.module('isc.shared').directive('iscDynamicController', ['$controller', function($controller) {
    return {
            restrict: 'A',
            scope: true,
            link: function (scope, element, attrs) {
                    
                var locals = {
                    $scope: scope,
                    $element: element,
                    $attrs: attrs
                };
                
                element.data('$Controller', $controller(scope.$eval(attrs.iscDynamicController), locals));                       
            }
        };
    }
])
/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp. 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/

/**
 * @ngdoc directive
 * @name iscElastic
 *
 * @description
 * Used to stretch the element to fit the complete content. 

 *
 * @example
 * <textarea isc-elastic > Complete content should be visible</textarea>
 *
 */


angular.module('isc.shared').directive('iscElastic', ['$timeout', function($timeout) {
  return {
            restrict: 'A',
            link: function($scope, element) {
                $scope.initialHeight = $scope.initialHeight || element[0].style.height;
                var resize = function() {
                    element[0].style.height = $scope.initialHeight;
                    element[0].style.height = "" + element[0].scrollHeight + "px";
                };
                element.on("input change", resize);
                $timeout(resize, 0);
            }
        };
}]);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
angular.module("isc.shared").directive("iscEncodeAttr", iscEncodeAttrFn);

/**
 * @ngdoc directive
 * @name iscEncodeAttr
 * @restrict A
 * @element ANY
 * @scope
 * @priority -10
 * @requires iscAppInfo
 *
 * @description
 * 	'iscEncodeAttr' is a directive that is used to encode any attribute in dom that contains a uri. Specify the attribute to
 * 	be encoded as its value. The attribute to be encoded must exist on the DOM and have a valid value.
 * 
 * 	Image files/paths may contain special characters like '#' that are not encoded by Angular or by encodeURI() as '#' has a
 * 	special significance in a uri. Special characters like '#' remove any characters after it when a browser makes a request.
 * 	Thus, when these uri requests are made, application encounters csrf validation failure because the required extension,
 * 	e.g.: .jpg, .png was also removed from request.
 *  It is chiefly intended to be used for src or ng-src attribute. A '#' has special significance in href. So, using this
 *  directive will encode '#' in href too.
 * 
 * 	We use encodeURIComponent() to encode paths between every forward slash (/).
 * 	
 *	NOTE: Other special characters except '#' are handled by Angular. So in retrospect, we are just ensuring with this directive
 *	that '#' is handled in image file path as in past it was a customer scenario.
 */

iscEncodeAttrFn.$inject = ["iscAppInfo"];
function iscEncodeAttrFn(iscAppInfoProvider) {
	return {
		restrict: "A",
		priority: -10,
		scope: true,
		link: function(scope, element, attributes) {
			// Angular way because <a> exposes methods for uri.
			var urlParsingNode = iscAppInfoProvider.getUrlParsingNode(),
				msie = document.documentMode,
				attrToEncode = attributes.iscEncodeAttr;
				
			attributes.$observe(attrToEncode, function(value) {
				// For some reason, we are getting decoded value here.
				var hrefVal = value;
				if (!hrefVal) {
					if (attrToEncode === "href") {
						element.prop(attrToEncode, null);
					}
					return;
				}
				// do not call attributes.$set() as it will cause our observer to be invoked again and again till angular saftey check kicks in.
				if (msie) {
					urlParsingNode.setAttribute("href", hrefVal);
					hrefVal = urlParsingNode.href;
				}
				urlParsingNode.setAttribute("href", hrefVal);
				var host = urlParsingNode.host,
					path = hrefVal.substring(hrefVal.indexOf(host) + host.length),
					path_new = path,
					pathPartsArray = path_new.split("/");
				
				for (var i = 0; i < pathPartsArray.length; i++) {
					// decode 1st to avoid re-encoding.
					pathPartsArray[i] = encodeURIComponent(decodeURIComponent(pathPartsArray[i]));
				}
				path_new = pathPartsArray.join("/");
				hrefVal = hrefVal.replace(path, path_new);
				element.prop(attrToEncode, hrefVal);
			});
		}
	};
}

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/

/**
 * @ngdoc directive
 * @name iscEnter
 * @restrict A
 * 
 * @description Listens to enter key keydown event and calls the specified method
 * 
 * @param {string} iscEnter Method to call on enter key press
 * 
 * @example
    <!-- to call uiApply method on enter key press
    <input type="text" isc-enter="uiApply()">
 */
angular.module('isc.shared').directive('iscEnter', function () {
  return function (scope, element, attrs) {
    element.bind('keydown', function (event) {
      if(event.which === 13) {
        scope.$apply(function (){
            scope.$eval(attrs.iscEnter, {$event:event});
          });
        event.preventDefault();
      }
    });
  };
});

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/

/* 
Directive for iframe onload 
Directive Usage : 

*/

/**
 * @ngdoc directive
 * @name iframeOnload
 * @restrict A
 * 
 * @description Listens to iframe on-load event and calls the specified method
 * 
 * @example
 		<iframe iframe-onload="iframeLoadedCallBack(element)" src="..."></iframe>     
 */

angular.module('isc.shared').directive('iframeOnload', [function() {
  return {
    scope: {
        callBack: '&iframeOnload'
    },
    link: function(scope, element, attrs){
        element.on('load', function(){
            return scope.callBack(element);
        })
    }
}}])

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
angular.module("isc.shared").directive("iscInput", iscInputFn);

/**
 * @ngdoc directive
 * @name iscInput
 * @restrict E
 * @requires $compile
 *
 * @description
 * 	iscInput is a directive that automatically handles creation of an input field with a label and an error span. The label
 *	will always be displayed within the input field just like a placeholder. The directive handles the animation to increase
 *	or decrease the size of the label when there is some value or user focus is received. Also, the error span is shown
 *	automatically based on errors with message coming from validation. It can also be a bundle value. The directive also meets
 *	some accessibility guidelines by populating some aria fields required for accessibility automatically.
 *	Some important details about the directive:
 *	1. Label - All attributes for label must start with label-config-. E.g.: label-config-isc-i18n.
 *	2. Input - Likewise, all attributes for input field must start with input-config-. These two are required and can not be
 *		defaulted.
 *	3. Error - The error span contents are defaulted based on datatype or validations performed on the input field. However,
 *		if in some cases, user requires control of the value to be displayed (ng-bind, isc-i18n etc) and/or condition to
 *		display the span (ng-if), then it must start with errorspan-config-.
 *	4. Default validation and error messages work if the directive is used inside a form with name. Also, the input-config-
 *		should include name and id attributes.
 *	5. Input type is defaulted to text if not provided.
 *	6. Directives included by default:
 *		- isc-number-formatter: if type is number.
 *		- isc-common-validations: always included.
 *	
 *	NOTE:
 *	There are scenarios when the label many not be required to be shown and the input/select should take up the entire space. This
 *	can be achieved through css for label. You can use any custom css, but we have a css class exposed OOTB:
 *	label-config-class="iwLabelHidden"
 *	The input/select will appropriately get styled to come vertically in the middle.
 *	
 * @example
 * 	The HTML will have the directive specified like below:
 * 		<div ng-form="sampleform">
 *			<isc-input 
 *				label-config-isc-i18n = "addItems.LABEL_Details"
 *				label-config-required
 *
 *				input-config-id = "detailsField"
 *				input-config-name = "detailsField"
 *				input-config-ng-model = "ui.item.itemDetails"
 *				input-config-isc-datatype = '{
 *					"customValidator": uiValidator
 *				}'>
 *			</isc-input>
 *		</div>
 */

/*
Internal reference and understanding about directive:

THINGS TO REMOVE (applies to all):
1. iscDatatypeValidator_msg needs to be replaced with iscValidation_msg. This needs to be done in Order Capture too.

NOTE:
1. While giving json attr, make sure that value is in single quotes ' and json contents in double quotes ". Refer input-config-isc-datatype.
2. input type defaults to text if not given. In case of select, nothing is set automatically, but if user passes some value for type, it will be set.
3. isc-number-formatter directive automatically added for type number even if user does not give it.
4. isc-common-validations directive automatically always added.
5. Setting required/ng-required on input-config or label-config is good enough to mark the other one as required. Passing both will have conflicting/unexpected results so only pass one. Also, as per HTML behavior, no value is needed when "required"/"disabled" is set in html as opposed to "ng-required"/"ng-disabled" that needs a boolean.
6. Do not give:
	- "aria-describedby" in input-config, we will internally default it to errorspan id anyways and ignore user value.
	- errorspan and label id. We will ignore user value.
7. Give errorspan or not, it will always be created with automatic conditions and bindings.
	- Dynamic name and form name will work with automatic errorspan config. Useful in ng-repeat.
	- As soon as you give any errorspan config (except class and ng-class), automatic handling will not be done and you will need to give conditions and binding.
	- If you do not have this directive inside an ng-form/form with name, then validations will not happen and automatic conditions can not be added. Blank errorspan with icon will be shown. You can use the widget but must provide errorspan-config with condition to show/hide span.
8. "ng:", "x-ng-" way of providing attributes is not supported even for angular attributes. Give "ng-" or "ng-attr-" only. NOTE that ng-name, ng-id and quite a few other attr do not work, so use wisely.
	- If you need to give data-, then add it before input/label/errorspan config. We will not automatically add it to corresponding html for the relevant attribute as it will not always work. Do not add before attribute. We log this as error.
9. innerHTML can be given for any 3 configs. This is not ng- supported and not recommended but can be used as last ditch resort. There will be console warning. label-config will use it if it can't find any other option. errorspan-config may also behave the same. input-config may always use it.
10.type given as ng-attr-type to make it dynamic will have some limitations - we can't automatically add "isc-number-formatter" directive and will warn. User will need to add it by themselves. If we add it in this case, we will have to trigger compile again from link(). Measure performance loss and decide (it is likely to cause loss because of number of directives on <input>).
11.Any and all jsons/expressions that contain strings, must be put in "". Do not use '' as the directive uses this. E.g.: label-config-ng-required = 'ui.uiMode == "add"', input-config-ng-model-options = '{ "updateOn": "blur" }' will work. String attributes or pure expressions without string like: input-config-id = "sample2", label-config-ng-required = "$index % 2 === 1 ? true : false" will continue to work.
TODO: Test if isc-common-validations and isc-datatype given as iscCommonValidations OR ng-model as NgModel, ngModel, ng-Model, Ng-Model? and update point#8.


OPEN ITEMS: 
1. Why datatype validation if input == null || "".
2. Handling for pristine not automatic: Conditions will be present where form must not be marked in error even for a mandatory field even if user
	tabs out. Field will remain pristine in such cases. But as soon as submit button is clicked, we want to show field in error.
	Handle such cases by:
	- Updating the css to show error outline only if not pristine.
	- On click on button, set a variable in controller to true.
	- Set the value of ng-class to a new value based on this variable - your css is different now, so pristine will not be true.
	- Provide custom errorspan-config with ng-if and ng-bind. Your condition should have the varialbe thats set to true on click of button.
3. What happens to user error span binding if i18n is given too? Which should take precedence? Similar condition for label?
4. Should we error out(code does not break though)/warn gracefully if input-config- or label-config- is not given?
*/

iscInputFn.$inject = ["$compile"];

function iscInputFn($compile) {
	// Not supporting data- before HTML attributes. you can only give data-label-config etc.
	var allowedPrefixesArr1 = ["ng-", "ng-attr-"],
		allowedPrefixesArr2 = ["Ng", "NgAttr"],
		CONST_cls_rootMostDiv = "iwHolder",
		CONST_cls_rootMostDivInputIdentifier = "iwInput",
		CONST_cls_rootMostDivSelectIdentifier = "iwSelect",
		CONST_cls_lblInputHolder = "iwLblInputHolder",
		CONST_cls_lblInputHolder_reqd = "iwLblInputHolder iwLblInputHolderRequired",
		CONST_cls_label = "iwLabel",
		CONST_cls_label_spanIcon_hidden = "iwLabelMandatoryHidden",
		CONST_cls_label_spanIcon = "iwLabelMandatory",
		CONST_cls_label_spanText = "iwLabelText",
		CONST_cls_input = "form-control",
		CONST_cls_input_focus = "iwInputFocus",
		CONST_cls_input_active = "active",
		CONST_cls_errorspan = "iwError field-error error-text block-component",
		CONST_cls_errorspan_spanHolder = "iwErrorIconAndMsgHolder",
		CONST_cls_errorspan_spanIcon = "app-glyphicons app-icon-delete_30",
		CONST_cls_errorspan_spanMsg = "iwErrorMsg",
		CONST_query_errorspan = ".iwError.field-error.error-text.block-component",
		CONST_query_errorspan_spanHolder = ".iwErrorIconAndMsgHolder",
		CONST_query_errorspan_spanMsg = ".iwErrorMsg";
		
	var __fn_consoleErrorOrWarnMsg = function(errorMsgCode) {
		switch(errorMsgCode) {
			case "error1":
				console.error("isc-input has bad configuration. Invalid format to provide attribute '%s'. Do not add '-data-' to attributes after label/input/errorspan-config. Use '%s' as attribute name instead.", arguments[1], arguments[2]);
				break;
			case "warn1":
				console.warn("isc-input has old configuration attribute. The parent form is automatically determined so, 'input-config-parentform' is not required any more and will be ignored.");
				break;
			case "warn2":
				console.warn("isc-input has bad configuration. '%s' is missing. Some features/capabilities will be unavailable. '%s': '%s'", arguments[1], arguments[2], arguments[3]);
				break;
			case "warn3":
				console.warn("isc-input has potentially unstable condition. 'input-config-type' is given as a dynamic attribute: 'input-config-%s'. Kindly ensure 'isc-number-formatter' directive has been provided as a part of 'input-config' as it will not be dynamically added. 'input-config-id': '%s'", arguments[1], arguments[2]);
				break;
			case "warn4":
				console.warn("isc-input has bad configuration. '%s' is not recommended to be used. 'input-config-id': '%s'", arguments[1], arguments[2]);
				break;
			case "warn5":
				console.warn("isc-input has potentially bad configuration. Directive has been used outside a form controller. It is likely that the error span will always be visible if no condition is given in 'errorspan-config' to show or hide it. 'input-config-name': '%s'", arguments[1]);
				break;
			default:
				// nothing.
		}
	};
	
	var _fn_getParamJsons = function(attributes) {
		var inputConfig = {},
			labelConfig = {},
			errorspanConfig = {};
		
		for (var p in attributes.$attr) {
			var htmlAttr = attributes.$attr[p];
			
			if (htmlAttr.indexOf("data-") === 0) {
				htmlAttr = htmlAttr.replace("data-", "");
			}
			if (htmlAttr.indexOf("-data-") !== -1) {
				__fn_consoleErrorOrWarnMsg("error1", htmlAttr, htmlAttr.replace("-data", ""));
				htmlAttr = htmlAttr.replace("-data", "");
			}
			// TODO: Ideally, write code to error out/ignore everything and create nothing when "ng:", "x-ng-" is present?
			if (p.indexOf("inputConfig") === 0) {
				htmlAttr = htmlAttr.substring(13);
				if (htmlAttr !== "") {
					if (htmlAttr === "parentform") {
						__fn_consoleErrorOrWarnMsg("warn1");
						continue;
					}
					inputConfig[htmlAttr] = attributes[p];
				}
			} else if (p.indexOf("labelConfig") === 0) {
				htmlAttr = htmlAttr.substring(13);
				if (htmlAttr !== "") {
					labelConfig[htmlAttr] = attributes[p];
				}
			} else if (p.indexOf("errorspanConfig") === 0) {
				htmlAttr = htmlAttr.substring(17);
				if (htmlAttr !== "") {
					errorspanConfig[htmlAttr] = attributes[p];
				}
			}
		}
		return _fn_addDefaultAtts(labelConfig, inputConfig, errorspanConfig);
	};
	
	var _fn_addDefaultAtts = function(labelConfig, inputConfig, errorspanConfig) {
		/*
			Do the following:
			1. Warn about id or name missing.
			2. Add id attr to labelConfig and errorspanConfig. Ignore any value given by user.
			3. Add for attr to labelConfig. Ignore any value given by user.
			4. Add "aria-describedby" to input-config. Ignore any value given by user.
			5. Add type to inputConfig. Default to text if not given and inputConfig["ng-options"] is null.
			6. Add isc-number-formatter directive if user does not give it when input type is number - can only be done when type is not dynamic else, warn the user.
			7. Add isc-common-validations directive.
			8. Copy over required/ng-required between label and input.
			9. Copy over disabled/ng-disabled between label and input.
			10.Warn about innerhtml being given and default to "". NOTE: browser converts innerHTML to innerhtml.
		*/
		var inputId_attrNVal = _fn_getAttrNValue(null, "id", null, inputConfig, allowedPrefixesArr1),
			inputName_attrNVal = _fn_getAttrNValue(null, "name", null, inputConfig, allowedPrefixesArr1),
			inputTypeAttr_attrNVal = _fn_getAttrNValue(null, "type", null, inputConfig, allowedPrefixesArr1),
			inputNgOptionsAttr_attrNVal = _fn_getAttrNValue(null, "ng-options", null, inputConfig, allowedPrefixesArr1),
			inputRequired_attrNVal = _fn_getAttrNValue(null, "required", null, inputConfig, allowedPrefixesArr1),
			labelRequired_attrNVal = _fn_getAttrNValue(null, "required", null, labelConfig, allowedPrefixesArr1),
			inputDisabled_attrNVal = _fn_getAttrNValue(null, "disabled", null, inputConfig, allowedPrefixesArr1),
			labelDisabled_attrNVal = _fn_getAttrNValue(null, "disabled", null, labelConfig, allowedPrefixesArr1);
		// 1
		if (inputId_attrNVal["value"] == null) {
			__fn_consoleErrorOrWarnMsg("warn2", "input-config-id", "input-config-name", inputName_attrNVal["value"]);
		}
		if (inputName_attrNVal["value"] == null) {
			__fn_consoleErrorOrWarnMsg("warn2", "input-config-name", "input-config-id", inputId_attrNVal["value"]);
		}
		// 2
		if (inputId_attrNVal["attr"] == null) {
			labelConfig["id"] = inputId_attrNVal["value"] + "_label";
			errorspanConfig["id"] = inputId_attrNVal["value"] + "_errorspan";
		} else {
			labelConfig[inputId_attrNVal["attr"]] = inputId_attrNVal["value"] + "_label";
			errorspanConfig[inputId_attrNVal["attr"]] = inputId_attrNVal["value"] + "_errorspan";
		}
		// 3
		labelConfig["for"] = inputId_attrNVal["value"];
		// 4
		inputConfig["aria-describedby"] = (errorspanConfig["id"] != null) ? errorspanConfig["id"] : errorspanConfig[inputId_attrNVal["attr"]];
		// 5
		if (inputTypeAttr_attrNVal["value"] == null && inputNgOptionsAttr_attrNVal["value"] == null) {
			inputConfig["type"] = "text";
		}
		// 6
		if (inputTypeAttr_attrNVal["value"] === "number") {
			inputConfig["isc-number-formatter"] = "";
		}
		if (inputTypeAttr_attrNVal["attr"] != null && inputTypeAttr_attrNVal["attr"] !== "type") {
			__fn_consoleErrorOrWarnMsg("warn3", inputTypeAttr_attrNVal["attr"], inputId_attrNVal["value"]);
		}
		// 7
		inputConfig["isc-common-validations"] = "";
		// 8
		if (labelRequired_attrNVal["attr"] === "required" || inputRequired_attrNVal["attr"] === "required") {
			labelConfig["required"] = true;
			inputConfig["required"] = true;
		} else if (labelRequired_attrNVal["value"] != null) {
			inputConfig[labelRequired_attrNVal["attr"]] = labelRequired_attrNVal["value"];
			inputRequired_attrNVal = labelRequired_attrNVal;
		} else if (inputRequired_attrNVal["value"] != null) {
			labelConfig[inputRequired_attrNVal["attr"]] = inputRequired_attrNVal["value"];
			labelRequired_attrNVal = inputRequired_attrNVal;
		}
		// 9
		if (labelDisabled_attrNVal["attr"] === "required" || inputDisabled_attrNVal["attr"] === "required") {
			labelConfig["required"] = true;
			inputConfig["required"] = true;
		} else if (labelDisabled_attrNVal["value"] != null) {
			inputConfig[labelDisabled_attrNVal["attr"]] = labelDisabled_attrNVal["value"];
			inputDisabled_attrNVal = labelDisabled_attrNVal;
		} else if (inputDisabled_attrNVal["value"] != null) {
			labelConfig[inputDisabled_attrNVal["attr"]] = inputDisabled_attrNVal["value"];
			labelDisabled_attrNVal = inputDisabled_attrNVal;
		}
		// 10
		if (labelConfig["innerhtml"] != null) {
			__fn_consoleErrorOrWarnMsg("warn4", "label-config-innerHTML", inputId_attrNVal["value"]);
		}
		if (inputConfig["innerhtml"] != null) {
			__fn_consoleErrorOrWarnMsg("warn4", "input-config-innerHTML", inputId_attrNVal["value"]);
		}
		if (errorspanConfig["innerhtml"] != null) {
			__fn_consoleErrorOrWarnMsg("warn4", "errorspan-config-innerHTML", inputId_attrNVal["value"]);
		}
		
		return {
			"label": labelConfig,
			"input": inputConfig,
			"errorspan": errorspanConfig,
			"extras": {
				"inputNgOptionsAttr_attrNVal": inputNgOptionsAttr_attrNVal,
				"labelRequired_attrNVal": labelRequired_attrNVal
			}
		};
	};
	
	var _fn_getAttrNValue = function(specificAttr, genericAttr, optionalAttrPrefix, srcJson, allowedPrefixes) {
		// returns both "attr" and "value" as null if the attribute gives null/undefined on srcJson i.e. it does not exist.
		optionalAttrPrefix = (optionalAttrPrefix == null) ? "" : optionalAttrPrefix;
		var retValue = null,
			retAttr = null;
		if (specificAttr == null) {
			var attrArray = [(optionalAttrPrefix + genericAttr)];
			for (var i = 0; i < allowedPrefixes.length; i++) {
				var anAllowedPrefix = allowedPrefixes[i];
				// Avoid creating ng-ng-options, ng-ng-options, ng-attr-ng-options.
				if (genericAttr.indexOf("ng-") !== 0 && genericAttr.indexOf("Ng") !== 0) {
					attrArray.push((optionalAttrPrefix + anAllowedPrefix + genericAttr));
				} else if (genericAttr.indexOf("ng-") === 0 || genericAttr.indexOf("Ng") === 0) {
					var genericAttr_substring = (genericAttr.indexOf("Ng") === 0) ? genericAttr.substring(2) : genericAttr.substring(3);
					attrArray.push((optionalAttrPrefix + anAllowedPrefix + genericAttr_substring));
				}
			}
			for (var j = 0; j < attrArray.length; j++) {
				retValue = srcJson[attrArray[j]];
				if (retValue != null) {
					retAttr = attrArray[j];
					break;
				}
			}
		} else {
			retAttr = specificAttr;
			retValue = srcJson[retAttr];
		}
		
		return {
			"attr": retAttr,
			"value": retValue
		};
	};
	
	var _fn_getAttrNValueFor_l10nORi18n = function(srcJson) {
		var attrName = null,
			attrValue = null;
		for (var p in srcJson) {
			if (p.indexOf("i18n") !== -1) {
				attrName = p;
				attrValue = srcJson[p];
				break;
			} else if (p.indexOf("l10n") !== -1) {
				attrName = p;
				attrValue = srcJson[p];
				break;
			}
		}
		return {
			"attr": attrName,
			"value": attrValue
		};
	};
	
	var _fn_getAllTemplateStrings = function(labelConfig, inputConfig, errorspanConfig, extrasJson) {
		var isCombobox = extrasJson.inputNgOptionsAttr_attrNVal["attr"],
			inputTemplate = "",
			inputTemplate_begin = (isCombobox != null) ? "<select" : "<input",
			inputTemplate_end = (isCombobox != null) ? "</select>" : "</input>"
			ip_innerHTML = (inputConfig.innerhtml == null) ? "" : inputConfig.innerhtml,
			labelTemplate = _fn_getLabelTemplateString(labelConfig, extrasJson),
			inputTemplate = _fn_getSingleTemplateString(inputTemplate_begin, inputConfig, CONST_cls_input, {"innerhtml": true}) + ">" + ip_innerHTML + inputTemplate_end,
			errorspanTemplate = _fn_getErrorspanTemplateString(errorspanConfig);
		
		return {
			"labelTemplate": labelTemplate,
			"inputTemplate": inputTemplate,
			"errorspanTemplate": errorspanTemplate
		};
	};
	
	var _fn_getLabelTemplateString = function(labelConfig, extrasJson) {
		var extras_labelRequired_attrNVal = extrasJson.labelRequired_attrNVal,
			labelNgBind_attrNVal = _fn_getAttrNValue(null, "ng-bind", null, labelConfig, allowedPrefixesArr1),
			cls_child_mandatorySpan = (labelConfig.required === true) ? CONST_cls_label_spanIcon : CONST_cls_label_spanIcon_hidden,
			lbl_innerHTML = (labelConfig.innerhtml == null) ? "" : labelConfig.innerhtml,
			lbl_l10nORi18n = _fn_getAttrNValueFor_l10nORi18n(labelConfig),
			attrToSkipObj = {
				"innerhtml": true
			},
			labelTemplate_child_mandatorySpan = "<span class='" + cls_child_mandatorySpan + "'>* </span>",
			labelTemplate_child_labelSpan = "<span class='" + CONST_cls_label_spanText + "'";
		
		// conditional logic to handle ng-required scenario.
		if (extras_labelRequired_attrNVal["attr"] != null && extras_labelRequired_attrNVal["attr"] !== "required") {
			var ngClassCondString = '((' + extras_labelRequired_attrNVal["value"] + ') === true) ? "' + CONST_cls_label_spanIcon + '" : "' + CONST_cls_label_spanIcon_hidden + '"';
			labelTemplate_child_mandatorySpan = "<span ng-class='" + ngClassCondString + "'>* </span>";
		}
		// ng-bind for inner text span.
		if (labelNgBind_attrNVal["attr"] != null) {
			labelTemplate_child_labelSpan = labelTemplate_child_labelSpan + " " + labelNgBind_attrNVal["attr"] + "='" + labelNgBind_attrNVal["value"] + "'";
			attrToSkipObj[labelNgBind_attrNVal["attr"]] = true;
		}
		// innerhtml/i18n or l10n for inner text span.
		if (lbl_l10nORi18n["value"] != null) {
			labelTemplate_child_labelSpan = labelTemplate_child_labelSpan + " " + lbl_l10nORi18n["attr"] + "='" + lbl_l10nORi18n["value"] + "'></span>";
			attrToSkipObj[lbl_l10nORi18n["attr"]] = true;
		} else {
			labelTemplate_child_labelSpan = labelTemplate_child_labelSpan + ">" + lbl_innerHTML + "</span>";
		}
		
		// labelTemplate receives all properties except ng-bind + innerhtml/i18n or l10n (on "labelTemplate_child_labelSpan").
		return (_fn_getSingleTemplateString("<label", labelConfig, CONST_cls_label, attrToSkipObj) + ">" + labelTemplate_child_mandatorySpan + labelTemplate_child_labelSpan + "</label>");
	};
	
	var _fn_getSingleTemplateString = function(templateStr, configJson, defaultCssClass, attrToSkipObj) {
		// We can't handle ng-class as it is an expression.
		if (configJson["class"] != null) {
			configJson["class"] = defaultCssClass + " " + configJson["class"];
		} else {
			configJson["class"] = defaultCssClass;
		}
		for (var attr in configJson) {
			if (attrToSkipObj && attrToSkipObj[attr]) {
				continue;
			}
			templateStr = templateStr + " " + attr + "='" + configJson[attr] + "'";
		}
		return templateStr;
	};
	
	var _fn_getErrorspanTemplateString = function(errorspanConfig) {
		var errorspanId_attrNVal = _fn_getAttrNValue(null, "id", null, errorspanConfig, allowedPrefixesArr1),
			errorspanNgBind_attrNVal = _fn_getAttrNValue(null, "ng-bind", null, errorspanConfig, allowedPrefixesArr1),
			errorspanClass_attrNVal = _fn_getAttrNValue(null, "class", null, errorspanConfig, allowedPrefixesArr1),
			es_innerHTML = (errorspanConfig.innerhtml == null) ? "" : errorspanConfig.innerhtml,
			errorspan_l10nORi18n = _fn_getAttrNValueFor_l10nORi18n(errorspanConfig),
			attrToSkipObj = {
				"innerhtml": true
			},
			idClassErrorspanPropJson = {},
			errorspanTemplate = "<span",
			errorspanTemplate_child_iconSpan = "<span class='" + CONST_cls_errorspan_spanIcon + "'></span>",
			errorspanTemplate_child_msgSpan = "<span class='" + CONST_cls_errorspan_spanMsg + "'";
			
		// ng-bind for inner errortext span.
		if (errorspanNgBind_attrNVal["attr"] != null) {
			errorspanTemplate_child_msgSpan = errorspanTemplate_child_msgSpan + " " + errorspanNgBind_attrNVal["attr"] + "='" + errorspanNgBind_attrNVal["value"] + "'";
			attrToSkipObj[errorspanNgBind_attrNVal["attr"]] = true;
		}
		// innerhtml/i18n or l10n for inner errortext span.
		if (errorspan_l10nORi18n["value"] != null) {
			errorspanTemplate_child_msgSpan = errorspanTemplate_child_msgSpan + " " + errorspan_l10nORi18n["attr"] + "='" + errorspan_l10nORi18n["value"] + "'></span>";
			attrToSkipObj[errorspan_l10nORi18n["attr"]] = true;
		} else {
			errorspanTemplate_child_msgSpan = errorspanTemplate_child_msgSpan + ">" + es_innerHTML + "</span>";
		}
		
		// errorspanTemplate - topmost parent span always visible and gets id, class attributes.
		if (errorspanClass_attrNVal["attr"] != null) {
			idClassErrorspanPropJson[errorspanClass_attrNVal["attr"]] = errorspanClass_attrNVal["value"];
			attrToSkipObj[errorspanClass_attrNVal["attr"]] = true;
		}
		idClassErrorspanPropJson[errorspanId_attrNVal["attr"]] = errorspanId_attrNVal["value"];
		attrToSkipObj[errorspanId_attrNVal["attr"]] = true;
		errorspanTemplate = _fn_getSingleTemplateString(errorspanTemplate, idClassErrorspanPropJson, CONST_cls_errorspan, {}) + ">" + "<span";
		
		// holder child span gets all conditions and properties except id + class (both on parent errorspan) & ng-bind + innerhtml/i18n or l10n (on "errorspanTemplate_child_msgSpan").
		errorspanTemplate = _fn_getSingleTemplateString(errorspanTemplate, errorspanConfig, CONST_cls_errorspan_spanHolder, attrToSkipObj) + ">" + errorspanTemplate_child_iconSpan + errorspanTemplate_child_msgSpan + "</span></span>";
		
		return errorspanTemplate;
	};
	
	return {
		restrict: "E",
		scope: false,
		require: "?^form",
		compile: function fn_iscInputCompile(element, attributes) {
			var retJson = _fn_getParamJsons(attributes),
				inputConfig = retJson.input,
				labelConfig = retJson.label,
				errorspanConfig = retJson.errorspan,
				extrasJson = retJson.extras,
				extras_labelRequired_attrNVal = extrasJson.labelRequired_attrNVal,
				isCombobox = extrasJson.inputNgOptionsAttr_attrNVal["attr"],
				templateString = "<div class='" + CONST_cls_rootMostDiv + " ",
				templateStringsJson = _fn_getAllTemplateStrings(labelConfig, inputConfig, errorspanConfig, extrasJson),
				cls_lblInputHolderDiv = (labelConfig.required === true) ? CONST_cls_lblInputHolder_reqd : CONST_cls_lblInputHolder,
				tpl_lblInputHolderDiv = "<div class='" + cls_lblInputHolderDiv + "'>";
				
			templateString = (isCombobox != null) ? (templateString + CONST_cls_rootMostDivSelectIdentifier + "' iscinput>") : (templateString + CONST_cls_rootMostDivInputIdentifier + "' iscinput>");
			
			if (extras_labelRequired_attrNVal["attr"] != null && extras_labelRequired_attrNVal["attr"] !== "required") {
				var ngClassCondString = '((' +  extras_labelRequired_attrNVal["value"] + ') === true) ? "' + CONST_cls_lblInputHolder_reqd + '" : "' + CONST_cls_lblInputHolder + '"';
				tpl_lblInputHolderDiv = "<div ng-class='" + ngClassCondString + "'>";
			}
			
			tpl_lblInputHolderDiv = tpl_lblInputHolderDiv + templateStringsJson.labelTemplate + templateStringsJson.inputTemplate + "</div>";
			templateString = templateString + tpl_lblInputHolderDiv + templateStringsJson.errorspanTemplate + "</div>";
			element.replaceWith(templateString);
			
			return function fn_iscInputLink(scope, lnkElement, lnkAttributes, formController) {
				var inputEl_name_attrNVal = _fn_getAttrNValue(null, "Name", "inputConfig", lnkAttributes, allowedPrefixesArr2),
					inputEl_ngModel_attrNVal = _fn_getAttrNValue(null, "NgModel", "inputConfig", lnkAttributes, allowedPrefixesArr2),
					inputEl_name = inputEl_name_attrNVal["value"],
					inputEl_ngModel = inputEl_ngModel_attrNVal["value"],
					inputElem_angular = lnkElement.find("input"),
					labelElem_angular = lnkElement.find("label"),
					// When user gives errorspan-config to handle conditions, this may not be visible and thus = [].
					errorspanElem_angular = lnkElement.querySelectorAll(CONST_query_errorspan);
					
				if (inputElem_angular.length === 0) {
					inputElem_angular = lnkElement.find("select");
				}
				
				// Adding focus and blur listeners on inputElem_angular.
				inputElem_angular.bind("focus", function() {
					inputElem_angular.addClass(CONST_cls_input_focus);
					labelElem_angular.addClass(CONST_cls_input_active);
				});
				inputElem_angular.bind("blur", function() {
					inputElem_angular.removeClass(CONST_cls_input_focus);
					if (this.value === "" || this.value == null) {
						labelElem_angular.removeClass(CONST_cls_input_active);
					} else {
						labelElem_angular.addClass(CONST_cls_input_active);
					}
				});
				
				// Add listener on inputEl_ngModel so that when value is null or "", label expands.
				if (inputEl_ngModel != null && inputEl_ngModel != "") {
					scope.$watch(inputEl_ngModel, function(newValue, oldValue) {
						var selectedTextInSelect = "";
						if (inputElem_angular != null && inputElem_angular[0] != null && inputElem_angular[0].options != null && inputElem_angular[0].selectedIndex != null) {
							selectedTextInSelect = inputElem_angular[0].options[inputElem_angular[0].selectedIndex].text;
						}
						if (selectedTextInSelect != null && selectedTextInSelect != "") {
							newValue = selectedTextInSelect;
						}
						// CONST_cls_input_focus class implies field has focus and we do not want label to expand in this case.
						if ((newValue === "" || newValue == null) && !inputElem_angular.hasClass(CONST_cls_input_focus)) {
							labelElem_angular.removeClass(CONST_cls_input_active);
						} else {
							labelElem_angular.addClass(CONST_cls_input_active);
						}
					});
				}
				
				// Automatically add ng-if and ng-bind for error span if no user configuration is give + form and input have name given and they are not "" (angular trims only white spaces to "").
				if (formController != null && errorspanElem_angular.length === 1 && (formController.$name != null && formController.$name != "" && inputEl_name != null && inputEl_name != "")) {
					var errorspanConfig_present = false;
					for (var prp in lnkAttributes) {
						if (prp.indexOf("errorspanConfig") === 0 && prp !== "errorspanConfigClass" && prp !== "errorspanConfigNgClass") {
							errorspanConfig_present = true;
							break;
						}
					}
					if (!errorspanConfig_present) {
						var errorObjString = formController.$name + "." + inputEl_name + ".$error",
							iscDatatype_attrNVal = _fn_getAttrNValue(null, "IscDatatype", "inputConfig", lnkAttributes, allowedPrefixesArr2),
							inputConfigIscCommonValidations_attrNVal = _fn_getAttrNValue(null, "IscCommonValidations", "inputConfig", lnkAttributes, allowedPrefixesArr2),
							iscDatatypeValue = iscDatatype_attrNVal["value"],
							inputConfigIscCommonValidationsValue = inputConfigIscCommonValidations_attrNVal["value"],
							ifCondArray = [],
							ifCond = "";
							
						if (inputConfigIscCommonValidationsValue != null || inputElem_angular.attr("isc-common-validations") != null) {
							ifCondArray.push((errorObjString + ".iscCommonDefaultValidations"));
						}
						if (iscDatatypeValue != null) {
							ifCondArray.push((errorObjString + ".iscDatatypeValidator"));
							if (iscDatatypeValue.indexOf("customValidator") != -1) {
								ifCondArray.push((errorObjString + ".iscCustomValidator"));
							}
						}
						if (ifCondArray.length > 0) {
							var errorspanIfCondSpan = errorspanElem_angular.querySelectorAll(CONST_query_errorspan_spanHolder),
								errorspanMsgElem = errorspanElem_angular.querySelectorAll(CONST_query_errorspan_spanMsg);
							ifCond = ifCondArray.join(" || ");
							errorspanIfCondSpan.attr("ng-if", ifCond);
							errorspanMsgElem.attr("ng-bind", errorObjString + ".iscValidation_msg");
						}
						$compile(errorspanElem_angular)(scope);
					}
				} else if (formController == null && errorspanElem_angular.length === 1) {
					__fn_consoleErrorOrWarnMsg("warn5", inputEl_name);
				}
			};
		}
	};
}
/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/

/**
 * @ngdoc directive
 * @name iscLoadingSpinner
 * @restrict EA
 * 
 * @description Shows loading spinner when AJAX calls are being made
 * 
 * @example
    
    <isc-loading-spinner ></isc-loading-spinner>
 */

angular.module('isc.shared').directive('iscLoadingSpinner', ['$http',function ($http) {
  return {
    restrict: 'EA',
    replace: true,        
    templateUrl:'./shared/app/loading-spinner.tpl.html',
		link: function (scope, element, attrs) {
      scope.$watch('activeCalls', function (newVal, oldVal) {
        if (newVal === 0) {
          scope.showLoader = false;
        }
        else {
          scope.showLoader = true;
        }				
      });
    }
  };
}]);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
/**
 * @ngdoc directive
 * @name iscMedia
 * @restrict A
 * 
 * @description This directive will create or destroy dom content based on media
 * 
 * Supported Media quiries
 * <br>xs - show content in extra small devices
 * <br>sm - show content in small devices
 * <br>md - show content in medium devices
 * <br>lg - show content in large devices
 * 
 * Note : This directive will not add a watcher to the window resolution.
 * 
 * @priority 600
 * @param {string} iscMedia If the media types matches the current window resolution 
 *      then the child elements will be created else it will be removed
 * 
 * 
 * @example
    <!-- to show content only in xs devices -->
    <div isc-media="xs">
      Content goes here
    </div>
    <!-- to show content only in xs & sm devices -->
    <div isc-media="xs sm">
      Content goes here
    </div>
 */



(function(){
  'use strict';
  
  angular.module("isc.shared").directive("iscMedia",["$window","iscMedia",function($window,iscMedia){
    /*
    var showContent = function showContent(mediaType){
      var show = false;
      var winWidth = $window.innerWidth || $window.outerWidth;
      var helper   = {
          isXs: function () { return winWidth < 768; },
          isSm: function () { return winWidth >= 768 && winWidth < 992; },
          isMd: function () { return winWidth >= 992 && winWidth < 1200; },
          isLg: function () { return winWidth >= 1200; }
      };
      var medias = mediaType.split(' ');
      var len = medias.length;
      
      while(len--){
        if( (medias[len]==="xs" && helper.isXs()) ||
            (medias[len]==="sm" && helper.isSm()) ||
            (medias[len]==="md" && helper.isMd()) ||
            (medias[len]==="lg" && helper.isLg())
          ){
          show = true;
          break;
        }
      }
      return show;
    };
    */
    return {
      multiElement: true,
      transclude: 'element',
      priority: 700,
      restrict: 'A',
      link : function ($scope, $element, $attr, ctrl, $transclude){
        var show = iscMedia.isMediaEnabled($attr.iscMedia);//showContent($attr.iscMedia);
        console.log(show);
        if (show) {
          $transclude(function(clone) {
            clone[clone.length++] = document.createComment(' end iscMedia: ' + $attr.iscMedia + ' ');
            $element.after(clone);
          });
        }
      }
    };
  }]);
  
})();

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/

/**
 * @ngdoc directive
 * @name iscNumberFormatter
 * @restrict A
 * 
 * @description Formats
 * 
 * @example
 		  <input type="number" isc-number-formatter ng-model="ui.Quantity">   
 */

angular.module('isc.shared').directive('iscNumberFormatter', ['$locale',function($locale) {
  return {
		restrict: 'A',
    require: 'ngModel',
    link: function(scope, element, attrs, ngModel) {
      ngModel.$parsers.push(function(value) {
    	  if (value != null) {
    		  return '' + value;
    	  } else {
    		  return value;
    	  }
      });
      ngModel.$formatters.push(function(value) {
    	  if (value != null) {
    		  var formats = $locale.NUMBER_FORMATS;
	  		  value=value.replace(formats.GROUP_SEP, '');
    		  return parseFloat(value, 10);
    	  } else {
    		  return value;
    	  }
      });
    }
  };
}])

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp.  2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
/**
 * @ngdoc directive
 * @name iscOnDomRender
 * @restrict A
 *
 * @description
 * Calls a function as soon as the DOM is rendered for the element where the directive is used. Use case is at Order History page where the API
 * to get order recommendations needs to be called as soon as the DOM for the order is loaded
 *
 * @example
 *  The HTML will have the directive specified like below. 
 *	The function uiLoadRecommendations is called as soon as the div is loaded.
 *   <div id="list-item_{{$index}}" isc-on-dom-render="uiLoadRecommendations(order)">
 *	 </div>
 */
(function(){
  'use strict';

    angular.module("isc.shared").directive("iscOnDomRender",[function(){

        return {
            restrict: 'A',
            scope:{
                iscOnDomRender:"&"
            },
            link:function($scope, $element, $attrs){
                $scope.iscOnDomRender();
            }
        };
    }])
})(); 
/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
angular.module("isc.shared").directive("iscPagination", iscPaginationFn);

/**
 * @ngdoc directive
 * @name iscPagination
 * @restrict A
 * @requires $interval
 * @requires $window
 *
 * @description
 * 	'iscPagination' is a directive that provides capability to scroll to last record and invoke next page handler. It
 * 	accepts the methods to be invoked on next page, orientation change, browser resize and other events.
 * 	The directive will not do anything by itself on these events, but invoke handlers configured on the controller. This
 * 	has been done to suit the various needs of each action on different views like: validations, API call, saving data
 * 	etc.
 * 	It is expected that this directive will be the direct parent of the repeating DOM elements created by ng-repeat.
 * 
 * @param {Object=} A configuration object that accepts the following properties. The functions mentioned below need to
 * 	be defined on the controller of the view that contains the directive:
 * 		- **type** - '{string}' - OPTIONAL attribute. Defaults to 'continuousscrolling'.
 * 		- **elementWithScrollbar** - '{string}' - OPTIONAL. Defaults to the element that has the directive. Allowed values
 *			are 'window', 'parent', 'parent.parent' and further chain of 'parent' elements. It should always correspond to
 *			the element on which we will have the scroll bar because we will listen to scroll on it. This attribute should
 *			only be used if you want scroll on window element. For all other scenarios, usage 'elementWithScrollbar_id' of
 *			is recommended. This attribute will be ignored if user gives 'elementWithScrollbar_id'.
 *		- **elementWithScrollbar_id** - '{string}' - OPTIONAL. Defaults to the element that has the directive. It should
 *			always correspond to the 'id' of the element on which we will have the scroll bar because we will listen to
 *			scroll on it. This will be given preference over 'elementWithScrollbar'.
 * 		- **nextPageHandler** - '{function}' - Method to invoke when you scroll to the last record OR next page button is
 * 			clicked. As per convention, must begin with 'ui'.
 * 		- **resizeHandler** - '{function}' - OPTIONAL. Method to invoke when window resize occurs. As per convention, must
 * 			begin with 'ui'.
 * 		- **orientationChangeHandler** - '{function}' - OPTIONAL. Method to invoke when device orientation changes. Can be
 * 			used to fetch more records when type is 'continuousscrolling'. As per convention, must begin with 'ui'.
 * 		- **requestedActionValidator** - '{function({"action"})}' - OPTIONAL. Function that can be used to validate if the
 * 			UI action or handler requested should be allowed or not. E.g.: when type is 'continuousscrolling' and we reach
 * 			the last record, nextPageHandler() will be called. User can trigger another scroll before the API returns. This
 * 			will call the nextPageHandler() again. To avoid such scenarios, we invoke the method on controller as it would
 * 			be aware of the state and return true or false. For this scenario, directive's default handler prevents a
 * 			second call to nextPageHandler() 1000ms of the first call.
 * 			As per convention, must begin with 'ui'.
 * 
 * @example
 * 	The HTML will have the directive specified like below:
 * 		<div ng-controller="MainCtrl as mainCtrl">
 *			<div ng-if="mainCtrl.showData" class="defaultHeight" isc-pagination="{
 *					'type': 'continuousScrolling',
 *					'nextPageHandler': mainCtrl.getNextPage
 *					}">
 *				<div ng-repeat="aData in mainCtrl.data track by aData.OrderNo">
 *				</div>
 *			</div>
 *		</div>
 */

iscPaginationFn.$inject = ["$interval", "$window"];
function iscPaginationFn($interval, $window) {
	
	// CURRENTLY NOT USER CONFIGURABLE, thus removed documentation.
	var _fn_default_previousPageHandler = function(paginationType) {
		if (paginationType !== _CONST_continuousScrollingStr) {
			console.warn("isc-pagination: Default Previous Page Handler: _fn_default_previousPageHandler()");
		}
	};
	
	// CURRENTLY NOT USER CONFIGURABLE, thus removed documentation.
	var _fn_default_pageSizeChangeHandler = function(paginationType) {
		if (paginationType !== _CONST_continuousScrollingStr) {
			console.warn("isc-pagination: Default Pagination Page Size Change Handler: _fn_default_pageSizeChangeHandler()");
		}
	};
	
	/**
	 * @private
	 * @description
	 *	Default handler for next page call.
	 */
	var _fn_default_nextPageHandler = function() {
		console.warn("isc-pagination: Default Next Page Handler: _fn_default_nextPageHandler()");
	};
	
	/**
	 * @private
	 * @description
	 *	Default handler for window resize event.
	 */
	var _fn_default_resizeHandler = function(event) {
		console.log("Default Window Resize Handler: _fn_default_resizeHandler()");
	};
	
	/**
	 * @private
	 * @description
	 *	Default handler for device orientation change event.
	 */
	var _fn_default_orientationChangeHandler = function() {
		console.log("Default Orientation Change Handler: _fn_default_orientationChangeHandler()");
	};
	
	/**
	 * @private
	 * @param {Object} A JSON object with the following attribute is supported:
	 * 		- **action** - The requested user action.
	 * @param {String} String telling the type of pagination in use.
	 * @param {Date} Javascript time indicating when the last request to fetch next set of records was made.
	 * @return {boolean} Returns true if requested action should be allowed to be performed.
	 * @description
	 *	Default handler to validate if requested user action should be allowed or not. When isc-pagination type is
	 *	'continuousscrolling', and user action is 'nextpage' we check if the difference between current and last such
	 *	request was 1000ms. If yes, then we return true to allow the action to proceed.
	 */
	var _fn_default_requestedActionValidator = function(inputJson, paginationType, nextPageRequestTime) {
		var returnResponse = false;
		if (paginationType === _CONST_continuousScrollingStr && inputJson.action === _CONST_action_nextPage) {
			if (((new Date() - nextPageRequestTime) > _CONST_bufferTimeForNextRequest)) {
				returnResponse = true;
			}
		}
		return returnResponse;
	};
	
		/**
		 * @private
		 * @description
		 *	Constant that parameterizes the string 'continuousscrolling'.
		 */
	var _CONST_continuousScrollingStr = "continuousscrolling",
			
		/**
		 * @private
		 * @description
		 *	Constant that parameterizes the string 'nextpage'.
		 */
		_CONST_action_nextPage = "nextpage",
		
		/**
		 * @private
		 * @description
		 *	Constant that parameterizes the string 'top'.
		 */
		_CONST_top = "top",
		
		/**
		 * @private
		 * @description
		 *	Constant that parameterizes the string 'mid'. Currently, we use this value in
		 *  '_lastRepeatingRecordRegionOfInterest'.
		 */
		_CONST_mid = "mid",
		
		/**
		 * @private
		 * @description
		 *	Constant that parameterizes the string 'end'.
		 */
		_CONST_end = "end",
		
		/**
		 * @private
		 * @description
		 *	Constant that holds the value of the time in milliseconds to wait before we return an OK response to permit UI
		 *	action to load the next page.
		 */
		_CONST_bufferTimeForNextRequest = 1000,
		
		/**
		 * @private
		 * @description
		 *	When the user scrolls to this part of the '_lastRepeatingRecord', next page request will be triggered.
		 *	Allowed values are: '_CONST_top', '_CONST_mid', '_CONST_end'.
		 *	Defaults to '_CONST_mid'.
		 */
		_lastRepeatingRecordRegionOfInterest = _CONST_mid,
		
		/**
		 * @private
		 * @description
		 *	Holder for angular.element($window) value. Required because this is an expensive operation. Best to perform it
		 *	once in the 'link()' function and share value in the directive.
		 */
		_angularWindowElement = null;
		
		
// TODO: Add parameter documentation from here.

	/**
	 * @private
	 * @description
	 * 	This method performs the check to determine if we have reached to the bottom/end or the configured regiod of the last
	 * 	repeating element which is a direct child of the 'isc-pagination' directive. Once this is confirmed, we invoke the
	 * 	next page handler method.
	 */
	var _fn_commonHandlingBeforeNextPage = function(paginationProps_editable, paginationProps_readOnly) {
		var elemToConsider = paginationProps_readOnly.elementToBind[0],
			isLastRecordRegionVisible = false,
			isWindowElem = false;
			
		if (elemToConsider === $window) {
			isWindowElem = true;
			elemToConsider = document.body;
		}
		
		paginationProps_editable.lastRepeatingRecord = _fn_getlastRepeatingElement(paginationProps_editable, paginationProps_readOnly.scopeElement);
		isLastRecordRegionVisible = _fn_isLastRecordVisible(elemToConsider, isWindowElem, paginationProps_editable.lastRepeatingRecord);
		var validationResponse = paginationProps_readOnly.fn_requestedActionValidator({"action": _CONST_action_nextPage}, paginationProps_readOnly.paginationType, paginationProps_editable.nextPageRequestTime);
		
		if (isLastRecordRegionVisible && validationResponse) {
			paginationProps_editable.nextPageRequestTime = new Date();
			
			if (paginationProps_editable.promiseFor_nextPage != null) {
				$interval.cancel(paginationProps_editable.promiseFor_nextPage);
			}
			paginationProps_editable.promiseFor_nextPage = $interval(paginationProps_readOnly.fn_nextPageHandler, 2, 1);
			paginationProps_editable.nextPageRequestSent = true;
		}
		return paginationProps_editable;
	};
	
	/**
	 * @private
	 * @return {element} Returns the last repeating element which is a direct child of the 'isc-pagination' directive.
	 * @description
	 * 	We intelligently determine if the next page request has returned with more records based on a few booleans and last
	 * 	count of the total number of repeating records instead of querying the DOM on every scroll as it is expensive (of the
	 * 	order of few microseconds).
	 */
	var _fn_getlastRepeatingElement = function(paginationProps_editable, scopeElement) {
		var allRepeatingChildren = null,
			lastRecord = paginationProps_editable.lastRepeatingRecord;
			
		if (paginationProps_editable.totalNumberOfRecords === 0 || paginationProps_editable.nextPageRequestSent) {
			allRepeatingChildren = scopeElement.children();
			paginationProps_editable.totalNumberOfRecords = allRepeatingChildren.length;
			lastRecord = allRepeatingChildren[paginationProps_editable.totalNumberOfRecords - 1];
			
			if (paginationProps_editable.totalNumberOfRecords > paginationProps_editable.totalNumberOfRecords_old) {
				paginationProps_editable.nextPageRequestSent = false;
			}
			paginationProps_editable.totalNumberOfRecords_old = paginationProps_editable.totalNumberOfRecords;
		}
		return lastRecord;
	};
	
	/**
	 * @private
	 * @param {element} The element on which the scroll bar is visible.
	 * @param {boolean} Informs if the element is the window/body element.
	 * @return {boolean} Returns true if the required part (top, middle, end) of last record is visible.
	 * @description
	 * 	This method calculates the coordinates of the 'scrollElement' and last repeating element inside the 'isc-pagination'
	 * 	directive. Based on coordinates it is determined if the area of interest (defaulted to end/bottom) of the repeating
	 * 	element is visible to the user or not.
	 * 	If the 'scrollElement' is window/body, then we consider the clientHeight to determine the bottom y coordinate.
	 * 	In other cases, we use the bottom attribute to determine the same.
	 */
	var _fn_isLastRecordVisible = function(scrollElement, isWindowElem, lastRepeatingRecord) {
		var scrollElementRect = scrollElement.getBoundingClientRect(),
			lastRepeatingRecordRect = lastRepeatingRecord.getBoundingClientRect(),
			scrollElem_bottom_y = scrollElementRect.bottom,
			lastRepeatingRecord_top_y = lastRepeatingRecordRect.top,
			lastRepeatingRecord_end_y = lastRepeatingRecordRect.bottom,
			lastRepeatingRecord_mid_y = (lastRepeatingRecord_top_y + lastRepeatingRecord_end_y)/2,
			lastRepeatingRecord_reqd_y = lastRepeatingRecord_end_y;
		
		if (_lastRepeatingRecordRegionOfInterest === _CONST_top) {
			lastRepeatingRecord_reqd_y = lastRepeatingRecord_top_y;
		} else if (_lastRepeatingRecordRegionOfInterest === _CONST_mid) {
			lastRepeatingRecord_reqd_y = lastRepeatingRecord_mid_y;
		}
		scrollElem_bottom_y = (isWindowElem === true) ? scrollElement.clientHeight : scrollElem_bottom_y;
		return (lastRepeatingRecord_reqd_y <= scrollElem_bottom_y);
	};
	
	return {
		restrict: "A",
		scope: true,
		link: function(scope, element, attributes) {
			// scope.$eval() is 10% - 20% slower than treating it as function using "&" in scope obj and calling scope.iscPagination(). But faster method seems like a quirk and not feature.
			
			var pagingConfigObj = scope.$eval(attributes.iscPagination) || {},
				paginationType = pagingConfigObj.type ? pagingConfigObj.type.toLowerCase() : _CONST_continuousScrollingStr,
				scopeElement = element,
				elementToBind = null,
				_lastScrollPosition = 0;
				
			var fn_previousPageHandler = pagingConfigObj.previousPageHandler || _fn_default_previousPageHandler,
				fn_nextPageHandler = pagingConfigObj.nextPageHandler || _fn_default_nextPageHandler,
				fn_pageSizeChangeHandler = pagingConfigObj.pageSizeChangeHandler || _fn_default_pageSizeChangeHandler,
				fn_resizeHandler = pagingConfigObj.resizeHandler || _fn_default_resizeHandler,
				fn_orientationChangeHandler = pagingConfigObj.orientationChangeHandler || _fn_default_orientationChangeHandler,
				fn_requestedActionValidator = pagingConfigObj.requestedActionValidator || _fn_default_requestedActionValidator;
			
			var paginationProps_editable = {
				"lastRepeatingRecord": null,
				"nextPageRequestTime": new Date(),
				"promiseFor_nextPage": null,
				"nextPageRequestSent": false,
				"totalNumberOfRecords": 0,
				"totalNumberOfRecords_old": 0
			};
			
			var paginationProps_readOnly = {
				"paginationType": paginationType,
				"scopeElement": scopeElement,
				"elementToBind": elementToBind,
				"fn_nextPageHandler": fn_nextPageHandler,
				"fn_requestedActionValidator": fn_requestedActionValidator
			};
			
			var fn_handleScroll = function() {
				if (paginationType === _CONST_continuousScrollingStr) {
					var scroll = 0;
					if (elementToBind[0] === $window) {
						scroll = Math.max($window.pageYOffset, document.documentElement.scrollTop, document.body.scrollTop);
					} else {
						scroll = elementToBind[0].scrollTop;
					}
					if (scroll > _lastScrollPosition && paginationProps_readOnly.scopeElement != null && paginationProps_readOnly.elementToBind != null) {
						paginationProps_editable = _fn_commonHandlingBeforeNextPage(paginationProps_editable, paginationProps_readOnly);
					} else {
						// scrolling Up
					}
					_lastScrollPosition = scroll;
				}
			};
			
			var fn_checkAndAddExtraCssForScrollbar = function() {
				if (elementToBind != null && elementToBind.prop != null) {
					if (elementToBind.prop("scrollHeight") > elementToBind.prop("offsetHeight")) {
						elementToBind.addClass("scrollBarVisible");
					} else {
						elementToBind.removeClass("scrollBarVisible");
					}
				}
			};
			
			if (_angularWindowElement == null) {
				_angularWindowElement = angular.element($window);
			}
			
			if (paginationType === _CONST_continuousScrollingStr) {
				elementToBind = element;
				if (pagingConfigObj.elementWithScrollbar === "window") {
					elementToBind = _angularWindowElement;
				} else if (pagingConfigObj.elementWithScrollbar != null && pagingConfigObj.elementWithScrollbar.indexOf("parent") !== -1) {
					var pathArray = pagingConfigObj.elementWithScrollbar.split(".");
					for (var i = 0; i < pathArray.length; i++) {
						elementToBind = elementToBind.parent();
					}
				}
				if (pagingConfigObj.elementWithScrollbar_id != null) {
					elementToBind = angular.element(document.getElementById(pagingConfigObj.elementWithScrollbar_id));
				}
				paginationProps_readOnly.elementToBind = elementToBind;
				
				elementToBind.on("scroll", fn_handleScroll);
				_angularWindowElement.on("resize", fn_resizeHandler);
				_angularWindowElement.on("orientationchange", fn_orientationChangeHandler);
				if (MutationObserver == null) {
					console.warn("MutationObserver is not supported, can't add extra css to detect presence of scroll bar.");
				} else {
					var whatToObserve = {
						"childList": true,
						"characterData": true,
						"subtree": true,
						"characterDataOldValue": true
					};
					var mutationObserver = new MutationObserver(function(mutationRecord, moInstance) {
						fn_checkAndAddExtraCssForScrollbar();
					});
					mutationObserver.observe(elementToBind[0], whatToObserve);
				}
				_angularWindowElement.on("resize", fn_checkAndAddExtraCssForScrollbar);
				_angularWindowElement.on("orientationchange", fn_checkAndAddExtraCssForScrollbar);
			}
			
			scope.$on("$destroy", function() {
				if (paginationProps_editable.promiseFor_nextPage != null) {
					$interval.cancel(paginationProps_editable.promiseFor_nextPage);
				}
				_angularWindowElement.off("scroll", fn_handleScroll);
				_angularWindowElement.off("resize", fn_resizeHandler);
				_angularWindowElement.off("orientationchange", fn_orientationChangeHandler);
				paginationProps_readOnly.scopeElement = null;
				paginationProps_readOnly.elementToBind = null;
			});
		}
	};
}

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp.  2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
angular.module("isc.shared").directive("iscPanelLoading",[function(){

	return {
		priority:200,
        transclude:true,
        scope:true,
        templateUrl:'./shared/app/panel-loading.tpl.html',
		link:function($scope, $element, $attr, ctrl, $transclude){
            $element.addClass('panel-loading-contaner');
			$scope.$watch($attr.iscShowLoading,function(newValue){
                $scope.showLoader = newValue;
            });
		},
        controller:["$scope",function($scope){
            
            
        }]
	}


}]);
/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
angular.module("isc.shared").directive("iscPerformance", iscPerformanceFn);

/**
 * @ngdoc directive
 * @name iscPerformance
 * @restrict E
 * @requires $rootScope
 * @requires $interval
 *
 * @description
 * 	iscPerformance directive can be used to track the UI and Ajax performance of the application. It records and reports the time taken
 *	for the DOM to respond after a user action.
 *	Enter, space, click, touch is interpreted as user action.
 *	The time taken is displayed in milliseconds separately as UI Time, Network time (Ajax + latency), Total Time. The total Ajax calls 
 *	made are also displayed.
 *	After the UI or Ajax calls complete, wait for up to 2 seconds to view the UI and Network timings.
 *	This can be of significant help to start understanding the performance of application in mobile devices where Chrome timeline is not
 *	available. Additionally, it must be noted that Chrome timeline also degrades performance. So, it is not the most accurate method to
 *	record application performance.
 *	Usage:
 *		1. The HTML part of jsp needs to contain: <isc-performance></isc-performance>
 *		2. Provide the following in the url of the application: &trackperf=y.
 */

/*
&trackperf=y
Click/enter/touchend triggers next loading cycle. It will log the existing data and start.
CURRENT ISSUES:
1. Apparently, layout and resize happens after MutationObeserver callback is called. So, we may still have some work to do. Also, exclude junk DOM/scope changes.
*2. Figure out a way to know if a request is getting served from cache so that you do not add its time.
FIXED: Not relying on $http. Some inaccuracy still there because possibly network connection is opened possibly after send() and status is set as 4 possibly after some delay.
*3. touchend - just like mousedown, it never gets triggered on a select drop down.
FIXED: Added "change" handler for combo. This is triggered both for touch and non-touch devices even before "click". This works in conjunction with #6. KNOWN ISSUE ON TOUCH DEVICES: Click on combo to open options, then immediately select an option in <2sec, then UI time lists the intervening time as well. If however u wait for 2sec so that polling is over, then time spent on open list is not counted.
4. Make 5 records, 2sec polling all configurable.
5. Remove window. reliance. Use directive scope. Also, register ajax interceptors only when directive is activated and not always like its done now.
*6. Some pages like Make Payment, when you select an option in combo, the old ajax call is going on, but since a programatic click() happens after "change", we have to clear old obj, now when the response comes, we need to ignore it and log it.
FIXED: Adding "change" handler in combo not enough as it is always triggered after OOB handling and no way to add it before. "click" is triggered even after this. So, we are too late. Had to implement backtrack in time feature for ajax calls where backtrack time = half of polling interval = 1sec. It will only enter when start and end counters are unequal.
7. iFrame - might need to re-attach all listeners and handlers there.
8. Tell action + dom element id/name/innerHTML for user information.

Priority:
*         - implies FIXED.
1. *6, *3 - makes the tool foolproof and very usable.
2. *2     - 
3. 8      - Increased understanding for tester.
3. 4, 5   - Good code.
4. 7, 1   - Resolving this will make it almost as good or better than timeline.
*/

iscPerformanceFn.$inject = ["$rootScope", "$interval"];

function iscPerformanceFn($rootScope, $interval) {
	
	window._fn_calcDetailedTimings = function(arrey_DOM, arrey_rootScope, arrey_M_or_KB_watch, ajaxStartEndDetailsObj, us_lastDOMTime, factorToUse) {
		var areAllAjaxCallsComplete = ajaxStartEndDetailsObj.areAllCallsCompleted,
			totTime_allCompletedAjaxCalls = ajaxStartEndDetailsObj.totTime_allCompletedAjaxCalls,
			totTime_gaps = ajaxStartEndDetailsObj.totTime_gaps,
			numCompletedAjaxCalls = ajaxStartEndDetailsObj.numCompletedAjaxCalls,
			startTime_firstAjaxCall = ajaxStartEndDetailsObj.startTime_firstAjaxCall,
			endTime_lastAjaxCall = ajaxStartEndDetailsObj.endTime_lastAjaxCall,
			us_start_userAction = (arrey_M_or_KB_watch.length === 0) ? -1 : parseInt(arrey_M_or_KB_watch[0]["time"] * factorToUse),
			us_lastRootScopeTime = (arrey_rootScope.length === 0) ? -1 : parseInt(arrey_rootScope[arrey_rootScope.length - 1]["time"] * factorToUse);
			
		if (startTime_firstAjaxCall !== -1 && startTime_firstAjaxCall*factorToUse < us_start_userAction) {
			us_start_userAction = startTime_firstAjaxCall*factorToUse;
		}
		
		var ms_totUserPercievedLoadTime_DOM = (us_lastDOMTime === -1) ? -1 : (us_lastDOMTime - us_start_userAction)/factorToUse,
			ms_totUserPercievedLoadTime_rootScope = (us_lastRootScopeTime === -1) ? -1 : (us_lastRootScopeTime - us_start_userAction)/factorToUse,
			ms_totUserPercievedLoadTime_Ajax = (endTime_lastAjaxCall === -1) ? -1 : (endTime_lastAjaxCall - us_start_userAction)/factorToUse,
			filtered_DOMArrey = [];
		// START - Filtering DOM and RootScope timings.
		for (var i = 0; i < arrey_DOM.length; i++) {
			var obj = arrey_DOM[i]["obj"];
			if (obj.length == undefined) {
				obj = [obj];
			}
			for (var j = 0; j < obj.length; j++) {
				var aRecord = obj[j],
					targetElem = aRecord["target"],
					targetElemParent = angular.element(targetElem).parent(),
					tagNameParent = targetElemParent.prop("tagName");
				if (tagNameParent && tagNameParent.toLowerCase() === "isc-performance") {
					// If any record has parent has isc-performance then stop.
					break;
				} else {
					filtered_DOMArrey.push(arrey_DOM[i]);
					break;
				}
			}
		}
		if (filtered_DOMArrey.length == 0) {
			us_lastDOMTime = -1;
			us_lastRootScopeTime = -1;
		} else {
			us_lastDOMTime = filtered_DOMArrey[filtered_DOMArrey.length - 1]["time"]*factorToUse;
			var us_uiOnlyTime = (us_lastDOMTime - (us_start_userAction + totTime_allCompletedAjaxCalls*factorToUse));
			for (var i = 0; i < arrey_rootScope.length; i++) {
				var us_currRootScopeTime = arrey_rootScope[i]["time"]*factorToUse,
					us_onlyRootScopeTime = (us_currRootScopeTime - (us_start_userAction + totTime_allCompletedAjaxCalls*factorToUse));
// APPROXIMATION: Accept at the max 20% bigger value.
				if (us_currRootScopeTime > us_lastDOMTime && us_onlyRootScopeTime <= (1.2 * us_uiOnlyTime)) {
					us_lastRootScopeTime = us_currRootScopeTime;
					if (arrey_rootScope.length - (i + 1) > 0) {
						console.warn("Ignoring last %d value(s) in 'rootScope_watch' array. Entire array for reference: ", (arrey_rootScope.length - (i + 1)), arrey_rootScope);
					}
					break;
				}
			}
		}
		ms_totUserPercievedLoadTime_DOM = (us_lastDOMTime === -1) ? -1 : (us_lastDOMTime - us_start_userAction)/factorToUse,
		ms_totUserPercievedLoadTime_rootScope = (us_lastRootScopeTime === -1) ? -1 : (us_lastRootScopeTime - us_start_userAction)/factorToUse;
		// END - Filtering DOM and RootScope timings.
		if (ms_totUserPercievedLoadTime_Ajax > ms_totUserPercievedLoadTime_DOM) {
			console.warn("ms_totUserPercievedLoadTime_Ajax > ms_totUserPercievedLoadTime_DOM, swapping... ", ms_totUserPercievedLoadTime_Ajax, ms_totUserPercievedLoadTime_DOM);
			ms_totUserPercievedLoadTime_DOM = ms_totUserPercievedLoadTime_Ajax;
		}
		window.__iscPerf["Global_completed_action_counter"]++;
		// TODO: I do not remember why *100/100 - it may be to get rid of something like: 1.7000000001 but I think parseInt() will do just fine. Not sure.
		var networkTime = parseInt(totTime_allCompletedAjaxCalls * 100)/100,
			totPercievedUITime = parseInt(ms_totUserPercievedLoadTime_DOM * 100)/100,
			totPercievedRootScopeTime = parseInt(ms_totUserPercievedLoadTime_rootScope * 100)/100,
			onlyUITime = parseInt((totPercievedUITime - networkTime) * 100)/100,
			onlyRootScopeTime = parseInt((totPercievedRootScopeTime - networkTime) * 100)/100,
			showTotPercievedUITime = (totPercievedRootScopeTime > totPercievedUITime) ? Math.ceil(totPercievedRootScopeTime) : Math.ceil(totPercievedUITime),
			showOnlyUITime = (onlyRootScopeTime > onlyUITime) ? Math.ceil(onlyRootScopeTime) : Math.ceil(onlyUITime),
			recToInsert = {
				"action": window.__iscPerf["Global_completed_action_counter"],
				"networkCalls": numCompletedAjaxCalls,
				"networkTime": Math.ceil(networkTime),
				"networkTime_gaps": Math.ceil(totTime_gaps),
				"totPercievedUITime": (totPercievedUITime === -1) ? 0 : totPercievedUITime,
				"totPercievedRootScopeTime": (totPercievedRootScopeTime === -1) ? 0 : totPercievedRootScopeTime,
				"onlyUITime": (onlyUITime === -1) ? 0 : onlyUITime,
				"onlyRootScopeTime": (onlyRootScopeTime === -1) ? 0 : onlyRootScopeTime,
				"showTotPercievedUITime": (showTotPercievedUITime === -1) ? 0 : showTotPercievedUITime,
				"showOnlyUITime": (showOnlyUITime === -1) ? 0 : showOnlyUITime
			};
		window.__iscPerf.perfTimerPresentationData.push(recToInsert);
		if (window.__iscPerf.perfTimerPresentationData.length > 5) {
			window.__iscPerf.perfTimerPresentationData.splice(0, 1);
		}
		window.__iscPerf.directiveScope.perfTimerPresentationData = window.__iscPerf.perfTimerPresentationData;
		// TODO: Fix for IE issue where $rootScope is in $digest phase. This part causes problems.
		window.__iscPerf.directiveScope.$digest();
	};
	
	window._fn_getAjaxStartEndDetails = function() {
		var ajaxArrey = window.__iscPerf["Ajax_watch"]["arrey"],
			allCallsComplete = true,
			totTime_allCompletedAjaxCalls = 0,
			totTime_gaps = -1,
			completedCallsCounter = 0,
			lastEndTime = -1,
			lastEndTime_recordIndex = -1;
			
		var refStartRecord = null,
			refEndTime = 0;
		
		for (var i = 0; i < ajaxArrey.length; i++) {
			var currRecord = ajaxArrey[i],
				currStartTime = currRecord["startTime"],
				currEndTime = currRecord["endTime"];
			
			if (currEndTime == null) {
				allCallsComplete = false;
				break;
			}
			completedCallsCounter++;
			if (currEndTime > lastEndTime) {
				lastEndTime = currEndTime;
				lastEndTime_recordIndex = i;
			}
			if (i === 0) {
				totTime_allCompletedAjaxCalls = currEndTime - currStartTime;
			} else {
				if (i === 1) {
					refStartRecord = ajaxArrey[0];
				}
				refEndTime = refStartRecord["endTime"];
				if (currStartTime > refEndTime) {
					totTime_allCompletedAjaxCalls = totTime_allCompletedAjaxCalls + (currEndTime - currStartTime);
					totTime_gaps = totTime_gaps + (currStartTime - refEndTime);
					refStartRecord = currRecord;
				} else {
					if (currEndTime > refEndTime) {
						totTime_allCompletedAjaxCalls = totTime_allCompletedAjaxCalls + (currEndTime - refEndTime);
						refStartRecord = currRecord;
					} else {
						// do nothing.
					}
				}
			}
		}
		return {
			"areAllCallsCompleted": allCallsComplete,
			"totTime_allCompletedAjaxCalls": totTime_allCompletedAjaxCalls,
			"totTime_gaps": totTime_gaps + 1,
			"numCompletedAjaxCalls": completedCallsCounter,
			"startTime_firstAjaxCall": (ajaxArrey.length === 0) ? -1 : ajaxArrey[0]["startTime"],
			"endTime_lastAjaxCall": lastEndTime,
			"endTime_lastAjaxCall_recordIndex": lastEndTime_recordIndex
		};
	};
	
	window._fn_updateAndSendAjaxWatch = function(ajaxWatchObj) {
		ajaxWatchObj["arrey"] = [];
		var startArr = ajaxWatchObj["_startArr"];
		var endArr = ajaxWatchObj["_endArr"];
		for (var i = 0; i < startArr.length; i++) {
			var recToInsert = {
				"obj": startArr[i]["obj"],
				"startTime": startArr[i]["time"],
				"endTime": null
			};
			if (endArr[i] != null) {
				if (startArr[i]["obj"].responseURL === endArr[i]["obj"].responseURL && startArr[i]["obj"]._startCounter === endArr[i]["obj"]._startCounter) {
					recToInsert["obj"] = endArr[i]["obj"];
					recToInsert["endTime"] = endArr[i]["time"];
				} else {
					for (var j = 0; j < endArr.length; j++) {
						if (startArr[i]["obj"].responseURL === endArr[j]["obj"].responseURL && startArr[i]["obj"]._startCounter === endArr[j]["obj"]._startCounter) {
							recToInsert["obj"] = endArr[j]["obj"];
							recToInsert["endTime"] = endArr[j]["time"];
							break;
						}
					}
				}
			}
			ajaxWatchObj["arrey"].push(recToInsert);
		}
		window.__iscPerf["Ajax_watch"] = ajaxWatchObj;
		return ajaxWatchObj;
	};
	
	window._fn_calcBasicTimings = function(intervalExecCounter, forceCalcData) {
		_fn_updateAndSendAjaxWatch(window.__iscPerf["Ajax_watch"]);
		
		var factorToUse = (window.performance != null) ? 1000 : 1,
			ajaxStartEndDetailsObj = _fn_getAjaxStartEndDetails(),
			arrey_DOM = window.__iscPerf["DOM_watch"]["arrey"],
			arrey_rootScope = window.__iscPerf["rootScope_watch"]["arrey"],
			arrey_M_or_KB_watch = window.__iscPerf["M_or_KB_watch"]["arrey"],
			us_currentTime = parseInt(perfTimer.now() * factorToUse),
			us_lastDOMTime = (arrey_DOM.length === 0) ? -1 : parseInt(arrey_DOM[arrey_DOM.length - 1]["time"] * factorToUse);
			
		if (forceCalcData === true || (((us_currentTime - us_lastDOMTime) > (2000 * factorToUse)) && ajaxStartEndDetailsObj.areAllCallsCompleted)) {
			_fn_calcDetailedTimings(arrey_DOM, arrey_rootScope, arrey_M_or_KB_watch, ajaxStartEndDetailsObj, us_lastDOMTime, factorToUse);
			$interval.cancel(window.__iscPerf.intervalInstance);
			window.__iscPerfOld = window.__iscPerf; // keep just to debug.
			if (forceCalcData !== true) {
				_fn_resetPerfObj(null, true);
			}
		}
		if (intervalExecCounter === 99) {
			$interval.cancel(window.__iscPerf.intervalInstance);
			window.__iscPerfOld = window.__iscPerf; // keep just to debug.
			_fn_resetPerfObj();
			console.warn("Waited too long and captured nothing... Resting... ;)");
		}
	};
	
	window._fn_resetPerfObj = function(scope, ajaxBacktrack) {
		var oldScope = (scope == null) ? window.__iscPerf["directiveScope"] : scope,
			oldPresentationData = (window.__iscPerf == null) ? [] : window.__iscPerf["perfTimerPresentationData"],
			oldCounter_start = (window.__iscPerf == null) ? 0 : window.__iscPerf["Global_ajax_call_counter_start"],
			oldCounter_end = (window.__iscPerf == null) ? 0 : window.__iscPerf["Global_ajax_call_counter_end"],
			oldCompletedActionCounter = (window.__iscPerf == null) ? 0 : window.__iscPerf["Global_completed_action_counter"],
			oldAjax_watch = (window.__iscPerf == null) ? {} : window.__iscPerf["Ajax_watch"],
			oldChangeFired = (window.__iscPerf == null) ? false : window.__iscPerf["changeFired"],
			oldSelectElemArray = (window.__iscPerf == null) ? [] : window.__iscPerf["selectElemArray"],
			currSelectElemArray = document.getElementsByTagName("select");
		
		window.__iscPerf = {
			"isDirectiveInitialized": true,
			"intervalInstance": null,
			"M_or_KB_watch": {
				"arrey": [],
				"maxLength": 5,
				"refreshCounter": 0
			},
			"DOM_watch": {
				"arrey": [],
				"maxLength": 100,
				"refreshCounter": 0
			},
			"rootScope_watch": {
				"arrey": [],
				"maxLength": 100,
				"refreshCounter": 0
			},
			"Ajax_watch": {
				"arrey": [],
				// _startArr will be in correct order. Same is not true for _endArr.
				"_startArr": [],
				"_endArr": []
			},
			"selectElemArray": oldSelectElemArray,
			"lastTouchEnd": 0,
			"changeFired": oldChangeFired,
			"directiveScope": oldScope,
			"perfTimerPresentationData": oldPresentationData,
			"Global_ajax_call_counter_start": oldCounter_start,
			"Global_ajax_call_counter_end": oldCounter_end,
			"Global_completed_action_counter": oldCompletedActionCounter
		};
		
		if (ajaxBacktrack === true && oldCounter_start !== oldCounter_end) {
			var currTime = perfTimer.now(),
				ajaxWatch__arrey = oldAjax_watch["arrey"],
				ajaxWatch__startArr = oldAjax_watch["_startArr"],
				newAjaxWatch__startArr = [],
				newAjaxWatch__endArr = [];
			for (var i = 0; i < ajaxWatch__startArr.length; i++) {
				var currRecordArrey = ajaxWatch__arrey[i],
					currRecord_startArr = ajaxWatch__startArr[i];
				if (/*currRecordArrey["endTime"] == null || */(currTime - currRecord_startArr["time"] < 1000)) {
					newAjaxWatch__startArr.push(currRecord_startArr);
					if (currRecordArrey != null && currRecordArrey["endTime"] != null) {
						newAjaxWatch__endArr.push({
							"obj": currRecordArrey["obj"],
							"time": currRecordArrey["endTime"]
						});
					}
				}
			}
			window.__iscPerf["Ajax_watch"] = {
				"arrey": [],
				"_startArr": newAjaxWatch__startArr,
				"_endArr": newAjaxWatch__endArr
			};
		}
		
		// TODO: Remove subscriber and old elem on destruction of DOM.
		var updatedSelectElemArray = oldSelectElemArray;
		for (var i = 0; i < currSelectElemArray.length; i++) {
			var aSelectElem = currSelectElemArray[i],
				alreadyListeningToElem = false;
			for (var j = 0; j < oldSelectElemArray.length; j++) {
				var oldSelectElem = oldSelectElemArray[j];
				if (aSelectElem === oldSelectElem) {
					alreadyListeningToElem = true;
					break;
				}
			}
			if (!alreadyListeningToElem) {
				updatedSelectElemArray.push(aSelectElem);
				aSelectElem.addEventListener("change", function (event) {
					window.__iscPerf.changeFired = true;
					_fn_updateReqdPefObj(window.__iscPerf, "M_or_KB_watch", event, true, false);
				});
			}
		}
		window.__iscPerf["selectElemArray"] = updatedSelectElemArray;
	};
	
	window._fn_updateReqdPefObj = function(perfObj, perfObjName, releventObj, startTimer, isTouchEnd) {
		var currentPerfTime = perfTimer.now();
		if (startTimer === true) {
			if (window.__iscPerf.intervalInstance != null) {
				_fn_calcBasicTimings(1000, true);
				$interval.cancel(window.__iscPerf.intervalInstance);
			}
			_fn_resetPerfObj(null, true);
			perfObj = window.__iscPerf;
			window.__iscPerf.intervalInstance = $interval(_fn_calcBasicTimings, 2000, 100, false);
		}
		if (isTouchEnd) {
			window.__iscPerf.lastTouchEnd = currentPerfTime;
		}
		
		var currentPerfObj = perfObj[perfObjName],
			maxLength = currentPerfObj["maxLength"],
			arrey = currentPerfObj["arrey"];
			
		if (arrey.length === maxLength) {
			// empty the array, but copy the last 3 entries.
			arrey = [arrey[maxLength - 3], arrey[maxLength - 2], arrey[maxLength - 1]];
		}
		arrey.push({
			"time": currentPerfTime,
			"obj": releventObj
		});
		currentPerfObj["refreshCounter"]++;
		currentPerfObj["arrey"] = arrey;
	};
	
	window._fn_addRequiredListeners = function(scope) {
		_fn_resetPerfObj(scope);
		
		document.addEventListener("click", function (event) {
			if (event.button === 0 && window.__iscPerf.changeFired !== true && (perfTimer.now() - window.__iscPerf.lastTouchEnd) > 2000) {
				_fn_updateReqdPefObj(window.__iscPerf, "M_or_KB_watch", event, true, false);
			} else if (window.__iscPerf.changeFired === true) {
				window.__iscPerf.changeFired = false;
			}
		}, true);
		document.addEventListener("touchend", function (event) {
			_fn_updateReqdPefObj(window.__iscPerf, "M_or_KB_watch", event, true, true);
			if (window.__iscPerf.changeFired === true) {
				window.__iscPerf.changeFired = false;
			}
		}, true);
		document.addEventListener("keydown", function (event) {
			if ((event.keyCode === 13 || event.keyCode === 32) && window.__iscPerf.changeFired !== true) {
				_fn_updateReqdPefObj(window.__iscPerf, "M_or_KB_watch", event, true, false);
			} else if (window.__iscPerf.changeFired === true) {
				window.__iscPerf.changeFired = false;
			}
		}, true);
		
		$rootScope.$watch(function(localScope) {
			_fn_updateReqdPefObj(window.__iscPerf, "rootScope_watch", localScope, false, false);
			return "_nonExistantValue";
		}, function() {});
		
		if (MutationObserver == null) {
			document.addEventListener("DOMSubtreeModified", function (event) {
				_fn_updateReqdPefObj(window.__iscPerf, "DOM_watch", event, false, false);
			});
		} else {
			var whatToObserve = {
				"childList": true,
				//"attributes": true, // triggers on css and style changes - hover, before click, focus etc. Needed to add too many css checks, thus removed.
				"characterData": true,
				"subtree": true,
				//"attributeOldValue": true,
				"characterDataOldValue": true
			};
			var mutationObserver = new MutationObserver(function(mutationRecord, moInstance) {
				_fn_updateReqdPefObj(window.__iscPerf, "DOM_watch", mutationRecord, false, false);
			});
			mutationObserver.observe(document.body, whatToObserve);
		}
		
		(function(send) {
			XMLHttpRequest.prototype.send = function() {
				this.addEventListener("readystatechange", function(e) {
					if (this.readyState === 4) {
						window.__iscPerf["Global_ajax_call_counter_end"]++;
						window.__iscPerf["Ajax_watch"]["_endArr"].push({
							"obj": this,
							"time": perfTimer.now()
						});
					}
				}, false);
				send.apply(this, arguments);
				window.__iscPerf["Global_ajax_call_counter_start"]++;
				this["_startCounter"] = window.__iscPerf["Global_ajax_call_counter_start"];
				window.__iscPerf["Ajax_watch"]["_startArr"].push({
					"obj": this,
					"time": perfTimer.now()
				});
			}
		})(XMLHttpRequest.prototype.send);
	};
	
	return {
		restrict: "E",
		scope: true,
		templateUrl: "./shared/app/performance.tpl.html",
		link: function fn_iscPerformanceLink(scope, lnkElement, lnkAttributes) {
			var href = window.location.href,
				params = href.split("&"),
				trackperf = false,
				ie8CompatObj = {
					"now": function() {
						return new Date().getTime();
					}
				};
			for (var i = 0; i < params.length; i++) {
				var keyNVal = params[i].split("="),
					key = keyNVal[0],
					val = keyNVal[1];
				key = key.toLowerCase();
				val = (val == null) ? val : val.toLowerCase();
				if (key === "trackperf" && val === "y") {
					trackperf = true;
					break;
				}
			}
			if (!trackperf) {
				scope.showUI = false;
				return;
			}
			if (window.__iscPerf != null) {
				return;
			} else if (document.addEventListener == null) {
				// msg about unsupported browser.
				alert("Could not setup performance resporting! Exiting.");
				return;
			}
			scope.showUI = true;
			// Best performance is achieved in the order: Date.now() (1 - 15ms accuracy), window.performance variable assignment (except Chrome DT), window.performance.
			window.perfTimer = (window.performance != null) ? window.performance : ((Date.now != null) ? Date : ie8CompatObj);
			window._fn_addRequiredListeners(scope);
		}
	};
}
/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp.  2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/

/**
 * @ngdoc directive
 * @name iscUpdateOnEnter
 * @restrict A
 * 
 * @description Formats
 * 
 * @example
 		  <input type="text" isc-update-on-enter ng-model="ui.Quantity">   
 */

angular.module('isc.shared').directive('iscUpdateOnEnter', [function() {
 
	return {
        restrict: 'A',
        require: 'ngModel',
        link: function (scope, elem, attrs, ngModelCtrl) {
            elem.bind("keyup",function(e) {
                if (e.keyCode === 13) {
                	console.log("commiting view value");
                    ngModelCtrl.$commitViewValue();
                }
            });
        }
    };
}])

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp. 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/

/**
 * @ngdoc directive
 * @name iscAppointmentListFilter
 * @restrict E
 *
 * @description
 * Displays Appointment list filter options as a popover
 *
 * @scope
 * @param {Object=} filterOptions - Holds Filter options data sent by the parent/calling screen
 * @param {String=} onApplyFilter - Call back handler in the parent screen that needs to be invoked when filter is applied.
 * @example
 *  The HTML will have the directive specified like below:
 *   <div>
 *		<isc-appointment-list-filter filter-options="model.filterOptions" on-apply-filter="uiApplyFilterOnAppointmentList"></isc-appointment-list-filter> 
 *   </div>
 */

(function(iscCore){
angular.module('isc.shared').directive('iscAppointmentListFilter', ['$window',function($window) {
	return {
		restrict: 'E',
		scope: {
			  filterOptions:"=",
			  onApplyFilter : '=',
			  getFilterFromContext:'=',
			  contextKeyName:'=?'
		    },
		    
		    link: function (scope, element, $attr, ctrl, $transclude){
	            // link parent controller's function and invoke them accordingly
	            scope.postCallbackData = function(orderListInput){
	               var callbackHandler = scope.onApplyFilter;
	               callbackHandler(orderListInput);
	            };
	         },

		 controller:['$scope','$rootScope','$document','iscMashup','iscAppContext','iscI18n','amSubtractFilter','amDifferenceFilter','iscDateFilter',function($scope,$rootScope,$document,iscMashup,iscAppContext,iscI18n,amSubtractFilter,amDifferenceFilter,iscDateFilter){
				var dateFormatForLocale = iscDateFilter.getDateFormatForLocale(iscAppContext.getFromContext('localeCode'));
				if(!dateFormatForLocale) dateFormatForLocale = 'yyyy/MM/dd';
				var dateFormatForMomentCalculations = dateFormatForLocale.toUpperCase();
				var dateFormatFromToDates = 'MMM dd,yyyy'.toUpperCase();
				
				$scope.uiForms = {};
		    	
		    	$scope.model = {
		    			orderStatusList:angular.copy(iscAppContext.getFromContext("orderStatusList"))
				};
		    	
		    	$scope.ui = {
		    			
		    			filterCriteria:{
		    				selectedAppointmentStatus : {},
	                		serachWithinStore: "N",
							selectedFromOrderDate : "",
							selectedToOrderDate : "",
							selectedFromDate : "",
							selectedToDate : "",
							maxDate: null,
							minDate: null,
							dateDisplayFormat : dateFormatForLocale,
							placeholderFormat : iscI18n.translate('orderFilter.placeholderFormat'),
							fromDateReturnFormat: "YYYY-MM-DDT00:00:00",
							toDateReturnFormat: "YYYY-MM-DDT23:59:59",
							orderDateFilterSuffix: "appointmentDateFilter",
							calleeId: "appointmentDateFilter",
							StatusList:{}
		    			},
		    			lastAppliedFilterCriteria : {},
		    			showFilter:false,
		    			currentStore : iscAppContext.getFromContext("storeName"),
						orderDateFilterInError: false,
						statusFilterInError: false,
						orderDateFilterErrorMessge: "",
						filterOptions:{},
						isFilterApplied : false,
						initialAppliedFilterCriteria:{}
		    	};
		    	
		    	$scope.popOverTemplate = 'shared/appointment/appointment-list-filter.tpl.html';
		    	
		    	var escapeBinderFn = function(event){
					  if(event.which === 27 && !event.defaultPrevented) {
			            $scope.ui.showFilter = false;
			            $document.off("keydown",escapeBinderFn);
			            $scope.$apply();
					  }
					};
					
					$scope.$on("$destroy", function () {
			            $document.off("keydown",escapeBinderFn);
			        });
					
					$rootScope.$on('closeOrderListFilter',function(event,args){
						 $scope.ui.showFilter = false;
		  			 });
					
				$scope.uiShowFilterOptions = function(){
					$scope.ui.showFilter = true;
			 		$document.on("keydown",escapeBinderFn);
				};
				
		    	$scope.init = function(){
		    		
		    		$scope.ui.filterOptions = angular.copy($scope.filterOptions); 
		    		$scope.ui.filterCriteria.StatusList = $scope.filterOptions;
		    		if(iscCore.isVoid($scope.contextKeyName)){
		    			$scope.contextKeyName = 'appointmentListFilter';
		    		}
		    		
		    		if($scope.getFilterFromContext){
		    			this.ui.filterCriteria = iscAppContext.getFromContext($scope.contextKeyName).filterCriteria;
		    			this.ui.isFilterApplied = true;
		    		}
		    		this.ui.isFilterApplied = true;
		    		this.ui.lastAppliedFilterCriteria = this.ui.filterCriteria;
		    		var tmpFilter = angular.copy(this.ui.filterCriteria);
                    $scope.ui.initialAppliedFilterCriteria = tmpFilter;
		    	};
		    	
		        
		        /**
				* @scDoc method
				* @method uiOpenFilterPopover
				* @description onclick handler function of filter icon.
				*             
				*/
				$scope.uiOpenFilterPopover = function(){
					if(!$scope.ui.showFilter){
						$scope.ui.showFilter = true;
						this.ui.orderDateFilterInError = false;
						this.ui.statusFilterInError = false;
				 		$document.on("keydown",escapeBinderFn);
					}
					else if($scope.ui.showFilter){
					  $scope.ui.showFilter = false;
					  $document.off("keydown",escapeBinderFn);
					}
				};
		        
		        $scope.uiApplyFilter=function() {
					var isDateFilterInError = this.checkDateFilterForErrors(this.ui.filterCriteria);
					var isStatusFilterInError = this.checkStatusFieldsForErrors(this.ui.filterCriteria);
					 
					if(!isDateFilterInError && !isStatusFilterInError) {
						this.ui.orderDateFilterInError = false;
						this.ui.statusFilterInError = false;
						this.ui.showFilter = false;
						this.ui.lastAppliedFilterCriteria = angular.copy(this.ui.filterCriteria);
						var workOrderListInput = this.getAppointmentFilter();
						
						$scope.postCallbackData(workOrderListInput);
					} 
		        };
				
		        $scope.checkStatusFieldsForErrors = function(filterCriteria){
		        	
		        	var statusArray = filterCriteria.StatusList.StatusList.Status;
					for(var j=0; j<statusArray.length; j++){
						if(statusArray[j].Checked=='Y'){
							return false;
						}
					}
					this.ui.statusFilterInError = true;
					return true;
					
		        };
		        
				$scope.checkDateFilterForErrors = function(filterCriteria) {
					var isError = false;
					if($scope.uiForms.appointmentDateFilter.$invalid) {
						this.ui.orderDateFilterErrorMessge = iscI18n.translate('datefilter.ERROR_invalid_format');
						isError = true;
					} else {
						var fromDate = filterCriteria.selectedFromDate;
						var toDate = filterCriteria.selectedToDate;
					
						if((fromDate && !toDate) || (!fromDate && toDate)) {
							this.ui.orderDateFilterErrorMessge = iscI18n.translate('datefilter.ERROR_date_missing');
							isError = true;
						}
					
						if(fromDate && toDate) {
							if(amDifferenceFilter(toDate,fromDate) < 0) {
								this.ui.orderDateFilterErrorMessge = iscI18n.translate('datefilter.ERROR_toDate_lesser');
								isError = true;
							}
							
							
							if(this.ui.filterCriteria.minDate && ((amDifferenceFilter(fromDate,this.ui.filterCriteria.minDate) < 0) || (amDifferenceFilter(toDate,this.ui.filterCriteria.minDate) < 0))) {
								this.ui.orderDateFilterErrorMessge = iscI18n.translate('datefilter.ERROR_date_greater_than_range');
								isError = true;
							}
						}
					}
					
					this.ui.orderDateFilterInError = isError;
					
					
					return isError;
				}
		        
		       
		        
		        $scope.getAppointmentFilter = function() {
		        	var workOrderListInput = {};
		        	workOrderListInput.WorkOrderAppointment = {};
		        	
		        	var isFilterApplied = false; //reset before calculating again
		        	if(!iscCore.isVoid(this.ui.filterCriteria.selectedFromOrderDate) && (!iscCore.isVoid(this.ui.filterCriteria.selectedToOrderDate))) {
		        		
		        		workOrderListInput.WorkOrderAppointment.PromisedApptStartDate = this.ui.filterCriteria.selectedFromOrderDate;
		        		workOrderListInput.WorkOrderAppointment.PromisedApptEndDate = this.ui.filterCriteria.selectedToOrderDate;
		        		isFilterApplied = true;
		        	}
		        	workOrderListInput.WorkOrderAppointment.WorkOrder={};
		        	workOrderListInput.WorkOrderAppointment.WorkOrder.Order = {};
		        	workOrderListInput.WorkOrderAppointment.StatusList = {};
		        	workOrderListInput.WorkOrderAppointment.StatusList = $scope.ui.filterCriteria.StatusList.StatusList;
					isFilterApplied = true;
					
		        	if("Y" == this.ui.filterCriteria.serachWithinStore) {
		        			workOrderListInput.WorkOrderAppointment.WorkOrder.NodeKey = this.ui.currentStore;
			        		isFilterApplied = true;
		        	}
		        	
		        	this.ui.isFilterApplied = isFilterApplied;
		        	return workOrderListInput;
		        	
		        };
		        
		        $scope.uiReset = function() {
					this.ui.filterCriteria.selectedFromDate = '';
		        	this.ui.filterCriteria.selectedToDate = '';
		        	this.ui.filterCriteria.serachWithinStore = "N";
		        	var tmpFiterCriteria = angular.copy(this.ui.initialAppliedFilterCriteria.StatusList.StatusList.Status);
		        	$scope.ui.filterCriteria.StatusList.StatusList.Status = angular.copy(tmpFiterCriteria);
					this.ui.orderDateFilterInError = false;
		        };
				
		        $scope.uiCloseFilter = function(){
		        	$scope.$emit('closeOrderListFilter',{});
		        };
		        
		        $scope.$watch('ui.showFilter', function(){
		        	if($scope.ui.showFilter){
		        		$scope.ui.filterCriteria = angular.copy($scope.ui.lastAppliedFilterCriteria);
		        		//$scope.setFilterToLastApplied();
		        	}
		        });
		        
		       
		        
		    	$scope.init();
		    }],
	    templateUrl:'./shared/appointment/appointment-list-filter-popover.tpl.html'	
	};
}]);
})(window.iscCore);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp. 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/


(function(iscCore){
    
    /**
     * @ngdoc directive
     * @name iscBatchLineFilter
     * @restrict E
     *
     * @description
     * Displays Batch Line filter options as a pop-over
     *
     * @scope
     * @param {String=} filtercontext - Specifies the context of the batch line. valid values are  pick or staging. 
     * @param {String=} filterAppliedCallback - Callback handler function to be executed on applying the filter.
     * @example
     *  The HTML will have the directive specified like below:
     *   <div>
     *       <isc-batch-line-filter filtercontext="pick" filter-applied-callback="uiApplyBatchListFilter"></isc-batch-line-filter>
     *   </div>
     */
    
    angular.module("isc.shared").directive("iscBatchLineFilter",[function(){
        
        return {
            restrict: 'E',
            templateUrl:'./shared/batch/batch-line-filter-popover.tpl.html',
            scope:{
                filterAppliedCallback:'=',
                filtercontext: '@'
                
            },
            link:function(scope, $element, $attr, ctrl, $transclude){
            	// link parent controller's function and invoke them accordingly.
            	scope.postCallbackData = function(filterDetails){
 	               var callbackHandler = scope.filterAppliedCallback;
 	               callbackHandler(filterDetails);
 	            };
            },
            controller:["$scope",'$rootScope','$document','iscI18n','iscMashup','iscAppContext',function($scope,$rootScope,$document,iscI18n,iscMashup,iscAppContext){
				
               
                $scope.ui = {
                   
                		filter:'IN_PROGRESS',
                		lastAppliedFilter:'',
        				inProgressLabelBundleKey : 'batchpick.LABEL_ToBePicked',
        				allLabelBundleKey : 'batchpick.LABEL_All'		
                   
                };
                
                /**
    			 * @ngdoc method
    			 * @name iscBatchLineFilter#uiOpenFilterPopover
    			 * @description Opens the BatchLine filter in Pop-over
    			 * 
    			 */
                $scope.uiOpenFilterPopover = function(){
                	if ($scope.filterData != null) {
                		for (var p in $scope.filterData) {
                			$scope.ui.filterCriteria[p] = $scope.filterData[p];
                		}
                	}
					if(!$scope.ui.showFilter){
						$scope.ui.showFilter = true;
				 		$document.on("keydown",escapeBinderFn);
					}
					else if($scope.ui.showFilter){
					  $scope.ui.showFilter = false;
					  $document.off("keydown",escapeBinderFn);
					}
				};
                
				$rootScope.$on('closeBatchLineFilter',function(event,args){
					 $scope.ui.showFilter = false;
	  			 });
				
                var escapeBinderFn = function(event){
                    if(event.which === 27 && !event.defaultPrevented) {
                        $scope.ui.showFilter = false;
                        $document.off("keydown",escapeBinderFn);
                        $scope.$apply();
                    }
                };
					
                $scope.$on("$destroy", function () {
                    $document.off("keydown",escapeBinderFn);
                });
					
                $scope.uiClearAll = function() {
		        	
					$scope.ui.filterCriteria.pickedFlag = 'N';
		        	$scope.ui.filterCriteria.inProgressFlag = 'N';
                    $scope.ui.filterCriteria.notStartedFlag = 'N';
                   
		        };
                
		        $scope.$watch('ui.showFilter', function(){
		        	if($scope.ui.showFilter){
		        		$scope.ui.filter = angular.copy($scope.ui.lastAppliedFilter);
		        	}
		        });
		        
				$scope.uiShowFilterOptions = function(){
					$scope.ui.showFilter = true;
			 		$document.on("keydown",escapeBinderFn);
				};
                
				/**
    			 * @ngdoc method
    			 * @name iscBatchLineFilter#uiApplyFilter
    			 * @description Invoked when Apply button is clicked in the filter pop-over
    			 * 
    			 */
                $scope.uiApplyFilter = function(){
                    
                	var data = {};
                	data.filter = $scope.ui.filter;
                	$scope.ui.lastAppliedFilter = angular.copy($scope.ui.filter);
                	$scope.ui.showFilter = false;
                    $scope.postCallbackData(data);
                };
                
                $scope.uiCancel = function() {
                	$scope.$emit('closeBatchLineFilter',{});
                };
                
                var init = function(){
                	
                	$scope.ui.lastAppliedFilter = $scope.ui.filter;
                	
    				
    				if($scope.filtercontext == "staging"){
    					$scope.ui.inProgressLabelBundleKey = 'batchpick.LABEL_ToBeStaged';
    				}
    					 
                }
                
                
                init();
                
               
            }]
        }
 
    }]);
    
})(window.iscCore);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp. 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
(function(iscCore){
    
    /**
     * @ngdoc directive
     * @name iscBatchListFilter
     * @restrict E
     *
     * @description
     * Displays Batch List filter options as a popover
     *
     * @scope
     * @param {Object=} filtermodel - Filter Options.
     * @param {String=} filterAppliedCallback - Callback handler function to be executed on applying the filter.
     * @example
     *  The HTML will have the directive specified like below:
     *   <div>
     *       <isc-batch-list-filter filter-applied-callback="uiApplyBatchListFilter" filtermodel="model.batchlist"></isc-batch-list-filter>	
     *   </div>
     */
    
    angular.module("isc.shared").directive("iscBatchListFilter",[function(){
        
        return {
            restrict: 'E',
            templateUrl:'./shared/batch-list/batch-list-filter-popover.tpl.html',
            scope:{
            	
            	filtermodel: '=',
                filterOptions:"=",
                filterData:"=",
                filterAppliedCallback:'='
                
            },
            link:function(scope, $element, $attr, ctrl, $transclude){
            	// link parent controller's function and invoke them accordingly.
            	scope.postCallbackData = function(filterDetails){
 	               var callbackHandler = scope.filterAppliedCallback;
 	               callbackHandler(filterDetails);
 	            };
            },
            controller:["$scope",'$rootScope','$document','iscI18n','iscMashup','amSubtractFilter','amDifferenceFilter','iscDateFilter','iscAppContext',function($scope,$rootScope,$document,iscI18n,iscMashup,amSubtractFilter,amDifferenceFilter,iscDateFilter,iscAppContext){
				
                $scope.ui = {
                   
                    filterCriteria:{
                    	pickedFlag:"",
                    	inProgressFlag:"",
                    	notStartedFlag:""
                        
                    },
                    filterOptions : {}, 
                    isFilterApplied: true
                };
                
                /**
    			 * @ngdoc method
    			 * @name iscBatchListFilter#uiOpenFilterPopover
    			 * @description Opens the BatchList filter in Pop-over
    			 * 
    			 */
                $scope.uiOpenFilterPopover = function(){
                	if ($scope.filterData != null) {
                		for (var p in $scope.filterData) {
                			$scope.ui.filterCriteria[p] = $scope.filterData[p];
                		}
                	}else{
                		$scope.uiResetToLastAppliedFilter();
                	}
					if(!$scope.ui.showFilter){
						$scope.ui.showFilter = true;
				 		$document.on("keydown",escapeBinderFn);
					}
					else if($scope.ui.showFilter){
					  $scope.ui.showFilter = false;
					  $document.off("keydown",escapeBinderFn);
					}
				};
                
                var escapeBinderFn = function(event){
                    if(event.which === 27 && !event.defaultPrevented) {
                        $scope.ui.showFilter = false;
                        $document.off("keydown",escapeBinderFn);
                        $scope.$apply();
                    }
                };
				
                $scope.$on("$destroy", function () {
                    $document.off("keydown",escapeBinderFn);
                });
				
                
                /**
    			 * @ngdoc method
    			 * @name iscBatchListFilter#uiResetToLastAppliedFilter
    			 * @description Resets the Filter with last applied filter options.
    			 */
                  $scope.uiResetToLastAppliedFilter = function() {
                	  $scope.ui.filterCriteria.pickedFlag = $scope.ui.filterOptions.Picked;
                      $scope.ui.filterCriteria.inProgressFlag = $scope.ui.filterOptions.InProgress;
                      $scope.ui.filterCriteria.notStartedFlag =$scope.ui.filterOptions.NotStarted;
		        };
		        
                $scope.uiClearAll = function() {
					$scope.ui.filterCriteria.pickedFlag = 'N';
		        	$scope.ui.filterCriteria.inProgressFlag = 'N';
                    $scope.ui.filterCriteria.notStartedFlag = 'N';
		        };
                
				$scope.uiShowFilterOptions = function(){
					$scope.ui.showFilter = true;
			 		$document.on("keydown",escapeBinderFn);
				};
                
				/**
    			 * @ngdoc method
    			 * @name iscBatchListFilter#uiApplyFilter
    			 * @description Invoked when Apply button is clicked in the filter pop-over
    			 * 
    			 */
                $scope.uiApplyFilter = function(){
                	var data = {};
    				data.FilterOptions = {};
    				data.FilterOptions.Picked = $scope.ui.filterCriteria.pickedFlag;
    				data.FilterOptions.InProgress = $scope.ui.filterCriteria.inProgressFlag ;
    				data.FilterOptions.NotStarted =  $scope.ui.filterCriteria.notStartedFlag;
                        if($scope.ui.filterCriteria.pickedFlag == 'Y' || $scope.ui.filterCriteria.inProgressFlag =='Y' || $scope.ui.filterCriteria.notStartedFlag =='Y'){
                     	   $scope.ui.isFilterApplied = true;
                     	   $scope.ui.showFilter = false;
                     	   $scope.ui.filterOptions = data.FilterOptions; 
                    	   $scope.postCallbackData(data);
                        }else{
                        	$scope.ui.isFilterApplied = false;
                        }
                };
                
                var init = function(){
                	    $scope.ui.filterOptions = angular.copy($scope.filtermodel.Page.Output.StoreBatchList.FilterOptions); 
                    	$scope.ui.filterCriteria.pickedFlag = $scope.ui.filterOptions.Picked;
                        $scope.ui.filterCriteria.inProgressFlag = $scope.ui.filterOptions.InProgress;
                        $scope.ui.filterCriteria.notStartedFlag = $scope.ui.filterOptions.NotStarted;
                        
                       if($scope.ui.filterCriteria.pickedFlag == 'Y' || $scope.ui.filterCriteria.inProgressFlag =='Y' || $scope.ui.filterCriteria.notStartedFlag =='Y'){
                    	   $scope.ui.isFilterApplied = true;
                       }else{
                    	   $scope.ui.isFilterApplied = false;
                       }
                       
                       $scope.$watch("ui.filterCriteria.pickedFlag",function(){
         					if($scope.ui.filterCriteria.pickedFlag == 'Y') {
         					 $scope.ui.isFilterApplied = true;
         					}
         				});
                         
                         $scope.$watch("ui.filterCriteria.inProgressFlag",function(){
            					if($scope.ui.filterCriteria.inProgressFlag == 'Y') {
            					 $scope.ui.isFilterApplied = true;
            					}
            				});
                         
                         $scope.$watch("ui.filterCriteria.notStartedFlag",function(){
            					if($scope.ui.filterCriteria.notStartedFlag == 'Y') {
            					 $scope.ui.isFilterApplied = true;
            					}
            					
            				});
                          
                }
                
                init();
                
            }]
        }
 
    }]);
    
})(window.iscCore);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp. 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/


/*
 * Events subscribed by calendar-day-agenda-view (might not be valid any more):
 * 1. event_calendarEventsAvailable - calendar events for the passed "selectedDayString" are available.
 * 		- If day is not passed, it is usafe to assume selected day. Thus, "selectedDayString" is a must.
 * 		- Day must be in format 2017-07-05T10:03:06(at max. T may be ommitted).
 * 		- Day must be the same as the one selected in calendar. This is because you can click on multiple days before API returns.
 * 			So, last selected on UI must be horoured.
 * 2. event_schedulerSlotsAvailable - scheduler slots for the passed "selectedDayString" are available.
 * 		- All above points for #1 apply.
 * 3. event_calendarWeeklyScheduleAvailable
 * 
 * Events published by calendar-day-agenda-view: on UI selection
 * "lastSelectedDayString", "selectedDayString" are args for 1st 3 events.
 * 1. event_calendarDaySelectionChange - Triggered on click of date from ui, on week and month selection change as well.
 * 2. event_calendarWeekSelectionChange - Triggered on click of week/month from ui. Never on day change (E.g.: Friday and
 * 		Monday on week view are visible, click on Monday will not trigger week change becuase we are in same week on ui.)
 * 3. event_calendarMonthSelectionChange - Triggered on click of day/week/month from ui.
 * 4. event_calendarAppointmentSelected - details of selected appointment.
 * 5. event_schedulerTimeSlotSelected - details of the selected slot.
 * 
 */


angular.module("isc.shared").directive("iscCalendarDayAgendaView", iscCalendarDayAgendaViewFn);

iscCalendarDayAgendaViewFn.$inject = ["$window", "$timeout", "$filter", "iscI18n", "iscCalendarDayAgendaViewPvdr", "iscCalendarCommonService", "iscMedia", "iscCalendarDayAgendaViewOverridesService", "iscCalendarDayAgendaViewService", "iscAppInfo"];

function iscCalendarDayAgendaViewFn($window, $timeout, $filter, iscI18n, iscCalendarDayAgendaViewPvdr, iscCalendarCommonService, iscMedia, iscCalendarDayAgendaViewOverridesService, iscCalendarDayAgendaViewService, iscAppInfo) {
	// "gt-480 xs" - 2 is default query and goes in else.
	var CONST_threshold = 2;
	var CONST_threshold_const = 0.46;
	var CONST_threshold_popup_const = 0.44;
	
	var __fn_determineConstantsForEventsPerSlot = function() {
		if (iscMedia.isMediaEnabled("lte-480")) {
			CONST_threshold = 1;
			CONST_threshold_const = 0.85;
			CONST_threshold_popup_const = 0.82;
		} else if (iscMedia.isMediaEnabled("gte-768")) {
			CONST_threshold = 3;
			CONST_threshold_const = 0.31;
			CONST_threshold_popup_const = 0.3;
		} else {
			CONST_threshold = 2;
			CONST_threshold_const = 0.46;
			CONST_threshold_popup_const = 0.44;
		}
	};
	
	var _fn_eventRenderFn = function(calEvent, element) {
		return $(iscCalendarDayAgendaViewService.getElementStringForCalEvent(calEvent, element));
	};
	
	var _fn_getClonedEventElemArrayCoveredByTimeSlot = function(domAnchorElem, allEventHolderDiv, directiveScope) {
		var refCoord = domAnchorElem.getBoundingClientRect();
		var allEventAnchorElem = allEventHolderDiv.children();
		var allCloneElem = [];
		var clonedArray = [];
		for (var i = 0; i < allEventAnchorElem.length; i++) {
			var currAnchorElem = allEventAnchorElem[i];
			var coords = currAnchorElem.getBoundingClientRect();
			var copiedElem = angular.copy(currAnchorElem);
			allCloneElem.push(copiedElem);
			if (domAnchorElem != currAnchorElem && (coords.top < refCoord.bottom && coords.bottom > refCoord.top)) {
				copiedElem.addEventListener("click", function(event) {
					var reqdElem = iscCalendarDayAgendaViewService.getAnchorElemFromJSEvent(event);
					for (var z = 0; z < allCloneElem.length; z++) {
						if (reqdElem[0] == allCloneElem[z]) {
							directiveScope._directlyGotoEvent = true;
							allEventAnchorElem[z].click();
							break;
						}
					}
				}.bind(directiveScope));
				clonedArray.push(copiedElem);
			}
		}
		return clonedArray;
	};
	
	var _fn_handleEventClick = function(calEvent, jsEvent, calViewInstance) {
		//window._calenderDayAgendaViewDir_origElArray = [];
		
		var currEventAnchorElem = iscCalendarDayAgendaViewService.getAnchorElemFromJSEvent(jsEvent);
		if (this._directlyGotoEvent === true) {// We have clicked on one of the clones in clonedAnchorElemArray, do not expand, just directly goto event.
			delete this._directlyGotoEvent;
			this.fn_updateSelectedAppointment(calEvent);
		} else if (currEventAnchorElem != null && currEventAnchorElem[0] != null && calEvent.thresholdExceededBy == null) {
			// We are determinig if some content is obscured/cut off vertically (not horizontally) due to sizing. There should be no null elements - thus no checks.
			var elem_div = currEventAnchorElem.find("div.fc-content");
			var height_a = currEventAnchorElem[0].getBoundingClientRect().height;
			var height_div = elem_div[0].getBoundingClientRect().height;
			
			if (height_div > (height_a - 4)) {//subtract 4px because of 4px vertical border.
				var cloneAnchor = jQuery.clone(currEventAnchorElem[0]);
				cloneAnchor.addEventListener("click", function() {
					this.fn_updateSelectedAppointment(calEvent);
				}.bind(this));
				iscCalendarDayAgendaViewService.showDetailsPopupForEvent(cloneAnchor, currEventAnchorElem[0], calViewInstance);
			} else {
				this.fn_updateSelectedAppointment(calEvent);
			}
		} else if (currEventAnchorElem != null && currEventAnchorElem[0] != null && currEventAnchorElem.parent != null) {
			var allEventHolderDiv = currEventAnchorElem.parent();
			var clonedAnchorElemArray = _fn_getClonedEventElemArrayCoveredByTimeSlot(currEventAnchorElem[0], allEventHolderDiv, this, calEvent);
			iscCalendarDayAgendaViewService.showAllEventsPopupForEvents(calEvent, clonedAnchorElemArray, currEventAnchorElem[0], calViewInstance, CONST_threshold, CONST_threshold_popup_const);
		}
	};
	
	var fn_createChildCalendar = function(calJsonProps, scopeInst) {
		/*
			We cant make the days selectable on top. So, we will do this instead:
			1. Select day view, have a different header, that will have left and right arrows that will trigger next week for the calendar (hopefully we have events and methods)
			2. Model days as buttons - gives us flexibility to have 1st day as current (can do via setting in calendar too: firstDay).
			3. Buttons are clickable and load that day's calendar below. But this means there will be 7 day long calendars (hopefully we have events and methods) - .fullCalendar( 'gotoDate', date )
			
			May define custom views instead of #1, #2, #3 combination - but might be tough.
		*/
		//console.log("creating valendar with %s", args.selectedDayString);
		var nowMoment = iscCalendarCommonService.getMomentForTimezone(undefined, scopeInst.timezoneOffset, false);
		var scrollTimeStr = undefined;
		var duration_minTime = moment.duration(calJsonProps.minTime);
		var duration_scrollTime = moment.duration(nowMoment.format("HH:mm:ss"));
		// If not same day or if diff is less than 1hour or -ve, do not scroll.
		// Also, scroll only if scrollTimeStr exceeds minTime by > 1.5hours. And always ensure scrollTimeStr is 1.5hours less than nowMoment.
		if (iscCalendarCommonService.areSameMomentDays(nowMoment, scopeInst.ui.selectedDateMoment) && (duration_scrollTime - duration_minTime) >= 5400000) {
			scrollTimeStr = nowMoment.clone().subtract("5400000").format("HH:mm:ss");
		}
		
		var idSelector = "#" + calJsonProps.id + "_calendarContent";
		var fc = $(idSelector).fullCalendar();
		if (fc != null || fc.length > 0) {
			$(idSelector).fullCalendar("destroy");
		}
		$(idSelector).removeClass("hideContent"); // required because we need either $timeout or user input to trigger a digest, so that class is removed before calc begins.
		$(idSelector).fullCalendar({
			id: calJsonProps.id,
			header: calJsonProps.header,
			eventOrder: iscCalendarCommonService.compareAndSort,
			//now: new moment("2017-08-17T14:38:15"),
			now: nowMoment,
			//firstDay: 3,
			//timezone: scopeInst.timezoneKey,
			//timezone: "-04:00",
			//slotLabelFormat: ,
			scrollTime: scrollTimeStr,//nowMoment.format("HH:mm:ss"),
			//titleFormat: 'MMMM YYYY',
			nowIndicator: calJsonProps.nowIndicator,
			allDaySlot: calJsonProps.allDaySlot,
			minTime: calJsonProps.minTime,
			maxTime: calJsonProps.maxTime,
			slotEventOverlap: calJsonProps.slotEventOverlap,
			isRTL: (iscAppInfo.getDirection().toLowerCase() === "rtl") ? true : false,
			slotDuration: iscCalendarDayAgendaViewPvdr.getCalendarMinTimeSlotDuration(),
			locale: iscCalendarDayAgendaViewPvdr.getCalendarLocale(),
			//timeFormat: iscCalendarDayAgendaViewPvdr.getCalendarTimeFormat(),
			defaultDate: calJsonProps.selectedDayString,
			defaultView: calJsonProps.defaultView,
			displayEventTime: calJsonProps.displayEventTime,
			//defaultTimedEventDuration: iscCalendarDayAgendaViewPvdr.getCalendarMinTimeSlotDuration(),
			//businessHours: calJsonProps.businessHours,
			//aspectRatio: calJsonProps.aspectRatio,
			views: calJsonProps.views,
			editable: calJsonProps.editable,
			events: scopeInst.calenderEventsData.eventArray,
			eventRender: _fn_eventRenderFn.bind(this),
			eventClick: _fn_handleEventClick.bind(scopeInst)
		});
	};
	
	var _fn_getCalendarJson = function(scopeObj) {
		var calendarJson = {
			"id": scopeObj.id
		};
		for (var p in scopeObj) {
			if (p !== "constructor" && p.indexOf("$") !== 0 && p.indexOf("calendar_") === 0) {
				var value = scopeObj[p];
				var reqdAttr = p.replace("calendar_", "");
				calendarJson[reqdAttr] = iscCalendarDayAgendaViewService.transformStringToCorrectTypeAndReturnValue(value);
			}
		}
		return calendarJson;
	};
	
	return {
		restrict: "E",
		require: "?^ngModel",
		// NOTE: I am not using anything yet on scope. Relying on attributes - should we do this?
		scope: {
			"id": "@",
			dateDataLoading: '=dateDataLoading',
			calenderWeekData: '=calenderWeekData',
			timezoneOffset: '=timezoneOffset',
			timezoneKey: '=timezoneKey',
			//"calenderDayEventsArray": "=calenderDayEventsArray",
			"calenderEventsData": "=calenderEventsData",
			"onCalendarAppointmentSelection": "&onCalendarAppointmentSelection",
			"minTimeClass": "@minTimeClass",
			"maxTimeClass": "@maxTimeClass",
			
			
			"calendar_class": "@calendarClass",
			"calendar_header": "@calendarHeader",
			"calendar_nowIndicator": "@calendarNowindicator",
			"calendar_allDaySlot": "@calendarAlldayslot",//find out what this does.
			//"calendar_minTime": "@calendarMintime",
			//"calendar_maxTime": "@calendarMaxtime",
			"calendar_slotEventOverlap": "@calendarSloteventoverlap",
			//"calendar_slotDuration": "@calendarSlotduration",
			"calendar_defaultView": "@calendarDefaultview",
			"calendar_displayEventTime": "@calendarDisplayeventtime",//find out what this does.
			//"calendar_defaultTimedEventDuration": "@calendarDefaulttimedeventduration",//get this from provider. Do not use from instance.
			//"calendar_businessHours": "@calendarBusinesshours",
			//"calendar_aspectRatio": "@calendarAspectratio",
			"calendar_views": "@calendarViews",
			//"calendar_editable": "@calendarEditable",// it should be false.
			//"scheduler_headertpl": "@schedulerHeadertpl",
			//"scheduler_footertpl": "@schedulerFootertpl"
		},
		
		controller: ["$scope", function($scope) {
			
			$scope.ui = {
				"selectedDate": null,
				"selectedDateMoment": null,
				"calendarJsonProps": null
			};
			
			$scope.$watch("calenderEventsData", function(calenderEventsData) {
				if (calenderEventsData != null) {
					$scope.ui.calendarJsonProps = _fn_getCalendarJson($scope);
					$scope.ui.calendarJsonProps.minTime = calenderEventsData.selectedDayData.min;
					$scope.ui.calendarJsonProps.maxTime = calenderEventsData.selectedDayData.max;
					$scope.ui.calendarJsonProps.selectedDayString = calenderEventsData.selectedDayData.selectedDayString;
					__fn_determineConstantsForEventsPerSlot();// recalculate on receiving new data. We are not doing this on orientation change or resize.
					iscCalendarDayAgendaViewOverridesService.overrideCoreMethods($scope.ui.calendarJsonProps, CONST_threshold, CONST_threshold_const);
					fn_createChildCalendar($scope.ui.calendarJsonProps, $scope);
				}
			}.bind(this));
			
			$scope.$watch("calenderWeekData", function(weekAvailabilityArray) {
				if (weekAvailabilityArray != null && weekAvailabilityArray.length > 0) {
				}
				//fn_updateWeekDays(null, weekAvailabilityArray);
			}.bind(this));
			
			$scope.uiHandleMoreDetailsMaskClick = function() {
				var allElemArray = iscCalendarDayAgendaViewService.getAllRequiredElementsForPopup($scope.id, "_calEvent_moreDetails");
				var moreDetailsPopupEl_holder = allElemArray[0];
				var moreDetailsPopupEl = allElemArray[1];
				var moreDetailsPopupEl_arrow = allElemArray[2];
				var moreDetailsPopupEl_mask = allElemArray[3];
				
				if (moreDetailsPopupEl.length === 1) {
					moreDetailsPopupEl.empty();
					
					moreDetailsPopupEl_holder.attr("style", "");
					moreDetailsPopupEl.attr("style", "");
					
					iscCalendarDayAgendaViewService.removeClazzes(moreDetailsPopupEl_arrow, []);
					iscCalendarDayAgendaViewService.removeClazzes(moreDetailsPopupEl_holder, iscCalendarDayAgendaViewService.getCssArrayUsedToShowHolder());
					iscCalendarDayAgendaViewService.addClazzes(moreDetailsPopupEl_holder, iscCalendarDayAgendaViewService.getCssArrayUsedToHideHolderAndMask());
				}
				if (moreDetailsPopupEl_mask.length === 1) {
					moreDetailsPopupEl_mask.attr("style", "");
					
					iscCalendarDayAgendaViewService.removeClazzes(moreDetailsPopupEl_mask, iscCalendarDayAgendaViewService.getCssArrayUsedToShowMask());
					iscCalendarDayAgendaViewService.addClazzes(moreDetailsPopupEl_mask, iscCalendarDayAgendaViewService.getCssArrayUsedToHideHolderAndMask());
				}
			};
			
			$scope.uiHandleAllEventsMaskClick = function() {
				var allElemArray = iscCalendarDayAgendaViewService.getAllRequiredElementsForPopup($scope.id, "_calEvents_allEvents", true);
				var allEventsPopupEl_holder = allElemArray[0];
				var allEventsPopupEl = allElemArray[1];
				var allEventsPopupEl_arrow = allElemArray[2];
				var allEventsPopupEl_mask = allElemArray[3];
				var allEventsPopupEl_header = allElemArray[4];
				
				if (allEventsPopupEl.length === 1) {
					allEventsPopupEl.empty();
					
					allEventsPopupEl_holder.attr("style", "");
					allEventsPopupEl.attr("style", "");
					allEventsPopupEl_arrow.attr("style", "");
					
					iscCalendarDayAgendaViewService.removeClazzes(allEventsPopupEl_holder, iscCalendarDayAgendaViewService.getCssArrayUsedToShowHolder());
					iscCalendarDayAgendaViewService.addClazzes(allEventsPopupEl_holder, iscCalendarDayAgendaViewService.getCssArrayUsedToHideHolderAndMask());
				}
				if (allEventsPopupEl_mask.length === 1) {
					allEventsPopupEl_mask.attr("style", "");
					
					iscCalendarDayAgendaViewService.removeClazzes(allEventsPopupEl_mask, iscCalendarDayAgendaViewService.getCssArrayUsedToShowMask());
					iscCalendarDayAgendaViewService.addClazzes(allEventsPopupEl_mask, iscCalendarDayAgendaViewService.getCssArrayUsedToHideHolderAndMask());
				}
			};
			
			$scope.fn_updateSelectedAppointment = function(selectedEventData) {
				$timeout(function() {
					if ($scope.onCalendarAppointmentSelection) {
						$scope.onCalendarAppointmentSelection({"selectedEventData": selectedEventData});
					}
				}, 5);
			};
			
		}],
		
		templateUrl: "./shared/calendar/calendar-day-agenda-view.tpl.html",
		
		link: function fn_iscCalendarDayAgendaViewLink($scope, $element, $attrs, ngModelCtrl) {
			if (ngModelCtrl != null) {
				$scope.$watch("ui.selectedDate", function(val) {
					ngModelCtrl.$setViewValue(val);
				});
				ngModelCtrl.$render = function() {
					if (ngModelCtrl.$viewValue) {
						$scope.ui.selectedDate = ngModelCtrl.$viewValue;
						$scope.ui.selectedDateMoment = iscCalendarCommonService.getMomentWithStartOfDayTimeForLocal($scope.ui.selectedDate);
					}
				}
			}
		}
		
	};
	
}

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp. 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/


/**
	 * @ngdoc directive
	 * @name iscDateSelector
	 * @restrict E
	 * 
	 * @description This directive will create date selector options
	 * 
     * @param {boolean} dateDataLoading Flag to indicate whether to show laoding mask or not
     * @param {Object} calenderWeekData Calender week data
     * @param {Function} onDateSelectionChange Function to be called when date selection changed
     * @param {model} ngModel Model to be used to get|set value
	 * 
	 * 
	 * @example
        <isc-date-selector ng-model="ui.selectedDate" calender-week-data="" 
            on-date-selection-change="" on-week-selection-change="" on-month-selection-change=""  
            on-date-selection-change="" date-data-loading="" >
        </isc-date-selector>
                    
	 */
angular.module('isc.shared').directive('iscDateSelector', ['$timeout', '$filter', 'iscCalendarCommonService', 'iscModal', function($timeout, $filter, iscCalendarCommonService, iscModal) {
	return {
		restrict: 'E',
		replace: true,
		require: '^ngModel',
		scope: {
			id: '@id',
			//selectedDate: '=selectedDate',//this really never gets updated. ng-model based binding updates ui.selectedDate.
			//firstDayOfWeek: '=firstDayOfWeek',
			//dateDataLoading: '=dateDataLoading',
			//dateGroupData: '=dateGroupData',
			calenderWeekData: '=calenderWeekData',
			onDateSelectionChange: '&onDateSelectionChange',
			onDateSelectionChangeIsHoliday: '&onDateSelectionChangeIsHoliday',
			onWeekSelectionChange: '&onWeekSelectionChange',
			onMonthSelectionChange: '&onMonthSelectionChange',
			timezoneOffset: '=timezoneOffset',
			calenderMaxAllowedDays: "=calenderMaxAllowedDays"
		},
		controller: ["$scope", "$locale", "iscI18n", "iscCalendarCommonService", function($scope, $locale, iscI18n, iscCalendarCommonService) {
			
			var CONST_minSelectable_moment = null;
			var CONST_maxSelectable_moment = null;
			var CONST_minSelectableWeek = 0;
			var CONST_minSelectableMonth = 0;
			var CONST_minSelectableYear = 0;
			//var cSelectedDate = null;
			//var cSelectedWeek = 0;
			//var cSelectedMonth = 0;
			//var cSelectedYear = 0;
			
			$scope.ui = {
				"selectedDate": undefined,
				"selectedDateMoment": null,
				"selectedMonthYear": "",
				"weekDays": [],
				"showPrevWeekBtn": false,
				"showPrevMonthBtn": false
			};
			
			$scope.$watch("timezoneOffset", function(newTimzoneOffset) {
				if (newTimzoneOffset != null && newTimzoneOffset != "") {
					init();
				}
			}.bind(this));
			
			$scope.$watch("calenderWeekData", function(weekAvailabilityArray) {
				fn_updateWeekDays(null, weekAvailabilityArray);
				// we need to set the flag when data is updated, thus call this method here.
				fn_handleDayChangeAndUpdateHolidayFlag();
			}.bind(this));
			
			$scope.uiUpdateSelectedDate = function(aDayObj, isInit, whatIsChanging, actionText) {
				whatIsChanging = (whatIsChanging == null) ? "day" : whatIsChanging;
				var oldSelectedDateMomentClone = $scope.ui.selectedDateMoment.clone();
				if (isInit !== true && aDayObj != null && iscCalendarCommonService.areSameMomentDays(aDayObj.currentDayMoment, $scope.ui.selectedDateMoment)) {
					return;
				} else if (aDayObj == null) {
					aDayObj = {
						"currentDayMoment": oldSelectedDateMomentClone
					};
				}
				var retMoment = fn_getFinalSelectedDateForDayOrWeekOrMonthChange(aDayObj.currentDayMoment, whatIsChanging, actionText);
				if (retMoment == null) {
					iscModal.showErrorMessage(iscI18n.translate("calendar.MSG_MaxDateLimitExceeded"));
					return;
				} else {
					$scope.ui.selectedDateMoment = retMoment;
				}
				if (whatIsChanging !== "day" || isInit === true || fn_hasWeekChanged($scope.ui.selectedDateMoment)) {
					fn_updateWeekDays($scope.ui.selectedDateMoment, null);
				}
				fn_updateSelectedMonthYearString();
				if (isInit !== true) {
					fn_handleDayChange();
					$scope.uiLoadWeek(actionText, oldSelectedDateMomentClone, true);
					$scope.uiLoadMonth(actionText, oldSelectedDateMomentClone, true);
				}
			};
			
			$scope.uiLoadWeek = function(actionText, oldSelectedDateMomentClone, skipDateUpdate) {
				oldSelectedDateMomentClone = (oldSelectedDateMomentClone == null) ? $scope.ui.selectedDateMoment.clone() : oldSelectedDateMomentClone;
				if (skipDateUpdate != true) {
					$scope.uiUpdateSelectedDate(null, false, "week", actionText);
					return;
				}
				// only fire week change when we have actionText => event came from ui week change. Because we can't rely on isoWeek() as our start of week days are not fixed.
				if (actionText != null) {
					fn_handleWeekChange();
					fn_validateConditionAndShowPrevWeekButton();
				}
			};
			
			$scope.uiLoadMonth = function(actionText, oldSelectedDateMomentClone, skipDateUpdate) {
				oldSelectedDateMomentClone = (oldSelectedDateMomentClone == null) ? $scope.ui.selectedDateMoment.clone() : oldSelectedDateMomentClone;
				if (skipDateUpdate != true) {
					$scope.uiUpdateSelectedDate(null, false, "month", actionText);
					return;
				}
				var newMonth = $scope.ui.selectedDateMoment.month();
				var newYear = $scope.ui.selectedDateMoment.year();
				if (newYear !== oldSelectedDateMomentClone.year() || newMonth !== oldSelectedDateMomentClone.month()) {
					fn_handleMonthChange();
					fn_validateConditionAndShowPrevMonthButton();
				}
			};
			
			$scope.uiAddCorrectCss = function(aDayObj) {
				return {
					"selected": iscCalendarCommonService.areSameMomentDays(aDayObj.currentDayMoment, $scope.ui.selectedDateMoment),
					"holiday": aDayObj.isHoliday
				};
			};
			
			// Might need to consider timezones.
			var fn_isDiffLessThanAWeek = function(smallerMoment, largerMoment) {
				var durationWeek = 7 * moment.duration("24:00:00");
				smallerMoment = smallerMoment.clone();
				largerMoment = largerMoment.clone();
				
				return (smallerMoment.add(durationWeek) > largerMoment);
			};
			
			var fn_hasWeekChanged = function(dateMoment){
	            return !dateMoment.isBetween($scope.ui.weekDays[0].currentDayMoment, $scope.ui.weekDays[6].currentDayMoment, 'days', '[]');
	        };
	        
	        var fn_validateConditionAndShowPrevWeekButton = function() {
				var newWeek = $scope.ui.selectedDateMoment.isoWeek();
				var newYear = $scope.ui.selectedDateMoment.year();
				$scope.ui.showPrevWeekBtn = (newWeek <= CONST_minSelectableWeek  && newYear <= CONST_minSelectableYear) ? false : true;
				// There is a special scenario - shift month, then shift week backwards. You may end up with a scenario where you can not navigate to today. To avoid this, check if diff between curr selection and orig is less than a week, allow back.
				if (!iscCalendarCommonService.areSameMomentDays(CONST_minSelectable_moment, $scope.ui.selectedDateMoment) && fn_isDiffLessThanAWeek(CONST_minSelectable_moment, $scope.ui.selectedDateMoment)) {
					$scope.ui.showPrevWeekBtn = true;
				}
			};
			
			var fn_validateConditionAndShowPrevMonthButton = function() {
				var newMonth = $scope.ui.selectedDateMoment.month();
				var newYear = $scope.ui.selectedDateMoment.year();
				$scope.ui.showPrevMonthBtn = (newMonth > CONST_minSelectableMonth || newYear > CONST_minSelectableYear)? true : false;
			};
			
			var fn_updateWeekDays = function(passedMoment, weekAvailabilityArray) {
				if (passedMoment != null && (weekAvailabilityArray == null || weekAvailabilityArray.length === 0)) {
					passedMoment = passedMoment.clone();
					$scope.ui.weekDays = [];
					var dayDuration = moment.duration("24:00:00");
					for (var i = 0; i < 7; i++) {
						var aDayObj = {
							"currentDayMoment": passedMoment.clone(),
							"dayOfMonth": passedMoment.format("DD"),
							"dayOfWeekName": passedMoment.format("ddd"),
							"isHoliday": false
						};
						//aDayObj["isHoliday"] = fn_isHolidayDayObj(aDayObj);
						$scope.ui.weekDays.push(aDayObj);
						passedMoment.add(dayDuration);
					}
				} else if (weekAvailabilityArray != null && weekAvailabilityArray.length > 0) {
					// we have called this method after api call on parent screen to update isHoliday.
					for (var i = 0; i < 7; i++) {
						var cWeekDay = $scope.ui.weekDays[i];
						var aWeekDay = weekAvailabilityArray[i];
						if (aWeekDay["date"] === cWeekDay.currentDayMoment.format("YYYY-MM-DD") && aWeekDay["isWorkingDay"] === "0") {
							cWeekDay["isHoliday"] = true;
						}
					}
				}
			};
			
			var fn_getValidSelectedMoment = function(momentToValidate, findNextAvailable) {
				var validSelectedDateMoment = momentToValidate.clone();
				if (validSelectedDateMoment < CONST_minSelectable_moment) {
					console.log("validSelectedDateMoment < CONST_minSelectable_moment");
					validSelectedDateMoment = CONST_minSelectable_moment;
				} else if (validSelectedDateMoment > CONST_maxSelectable_moment) {
					console.log("validSelectedDateMoment > CONST_maxSelectable_moment");
					validSelectedDateMoment = null;
				}
				return validSelectedDateMoment;
			};

			var fn_getFinalSelectedDateForDayOrWeekOrMonthChange = function(selectedDateClone, whatIsChanging, prevOrNext) {
				selectedDateClone = selectedDateClone.clone();
				if (whatIsChanging === "week") {
					selectedDateClone = $scope.ui.weekDays[0]["currentDayMoment"].clone();
					var durationToAdd = (prevOrNext === "prev") ? -7 * moment.duration("24:00:00") : 7 * moment.duration("24:00:00");
					selectedDateClone.add(durationToAdd);
				} else if (whatIsChanging === "month") {
					var currMonth = (prevOrNext === "prev") ? selectedDateClone.month() - 1 : selectedDateClone.month() + 1;
					selectedDateClone.month(currMonth);
					selectedDateClone.date(1); //set to 1st day of the month.
				}
				return fn_getValidSelectedMoment(selectedDateClone);
			};
			
			var fn_updateSelectedMonthYearString = function() {
				$scope.ui.selectedMonthYear = $scope.ui.selectedDateMoment.format("MMMM YYYY");
			};
			
			// NOTE: we do not handle scenario when we are at 11:55pm and spend 10min on calendar. Then select next week and come back - we still allow selection of old current day instead of updating it as past. This is because we do not update time ever until referesh.
			var init = function() {
				// Today is the min selectable day. We can not select past.
				CONST_minSelectable_moment = iscCalendarCommonService.getMomentForTimezone(undefined, $scope.timezoneOffset, true);
				CONST_maxSelectable_moment = fn_getMaxSelectableMoment();
				CONST_minSelectableWeek = CONST_minSelectable_moment.isoWeek();
				CONST_minSelectableMonth = CONST_minSelectable_moment.month();
				CONST_minSelectableYear = CONST_minSelectable_moment.year();
				
				if (iscCore.isVoid($scope.ui.selectedDateMoment) && iscCore.isVoid($scope.ui.selectedDate)) {
					$scope.ui.selectedDateMoment = iscCalendarCommonService.getMomentForTimezone(undefined, $scope.timezoneOffset, true);// During 1st time load of screen/directive in non-edit mode, this is void.
				} else if (iscCore.isVoid($scope.ui.selectedDateMoment)) {
					//day is selected, do not find offset, as it may .
					$scope.ui.selectedDateMoment = iscCalendarCommonService.getMomentWithStartOfDayTimeForLocal($scope.ui.selectedDate);
				}

				$scope.uiUpdateSelectedDate({
					"currentDayMoment": $scope.ui.selectedDateMoment
				}, true, null, "next");
				
				fn_handleWeekChange();
				fn_handleDayChange();
				
				fn_validateConditionAndShowPrevWeekButton();
				fn_validateConditionAndShowPrevMonthButton();
			};
			
			var fn_getMaxSelectableMoment = function() {
				var maxMoment = null;
				if (!iscCore.isVoid($scope.calenderMaxAllowedDays) && !isNaN(parseInt($scope.calenderMaxAllowedDays))) {
					// Time component will not be an issue because the time component when user selects will always exceed when we create this.
					maxMoment = CONST_minSelectable_moment.clone().add(parseInt($scope.calenderMaxAllowedDays) * moment.duration("24:00:00"));
					maxMoment.set({"hours": 23, "minutes": 59, "seconds": 59});
				}
				return maxMoment;
			};
			
			var fn_handleDayChange = function() {//event_calendarDaySelectionChange
				var dateData = {
					"selectedDate": iscCalendarCommonService.getMomentStringWithoutTime($scope.ui.selectedDateMoment)
				};
				$timeout(function() {
					if ($scope.onDateSelectionChange) {
						$scope.onDateSelectionChange({dateData: dateData});
					}
					fn_handleDayChangeAndUpdateHolidayFlag();
				}, 5);
			};
			
			var fn_handleDayChangeAndUpdateHolidayFlag = function() {
				var holidayData = {
					"isHoliday": iscCalendarCommonService.isCurrentDayAHolidayInWeek($scope.ui.selectedDateMoment, $scope.ui.weekDays)
				};
				$timeout(function() {
					if ($scope.onDateSelectionChangeIsHoliday) {
						$scope.onDateSelectionChangeIsHoliday({holidayData: holidayData});
					}
				}, 5);
			};
			
			var fn_handleWeekChange = function() {//event_calendarWeekSelectionChange
				var weekData = {
					"selectedDate": iscCalendarCommonService.getMomentStringWithoutTime($scope.ui.selectedDateMoment),
					"fromDate": iscCalendarCommonService.getMomentStringWithoutTime($scope.ui.weekDays[0]["currentDayMoment"]),
					"toDate": iscCalendarCommonService.getMomentStringWithoutTime($scope.ui.weekDays[6]["currentDayMoment"])
				};
				$timeout(function() {
					if ($scope.onWeekSelectionChange) {
						$scope.onWeekSelectionChange({weekData: weekData});
					}
				}, 5);
			};
			
			var fn_handleMonthChange = function() {//event_calendarMonthSelectionChange
				var monthData = {
					"selectedDate": iscCalendarCommonService.getMomentStringWithoutTime($scope.ui.selectedDateMoment)
				};
				$timeout(function() {
					if ($scope.onMonthSelectionChange) {
						$scope.onMonthSelectionChange({monthData: monthData});
					}
				}, 5);
			};
		
		}],
	
		link: function($scope, $element, $attrs, ngModelCtrl) {
			if (ngModelCtrl != null) {
				$scope.$watch("ui.selectedDate", function(val) {
					ngModelCtrl.$setViewValue(val);
				});
				ngModelCtrl.$render = function() {
					if (!iscCore.isVoid(ngModelCtrl.$viewValue)) {
						$scope.ui.selectedDate = ngModelCtrl.$viewValue;
						if (iscCore.isVoid($scope.ui.selectedDateMoment) && iscCore.isVoid($scope.ui.selectedDate) && !iscCore.isVoid($scope.timezoneOffset)) {
							$scope.ui.selectedDateMoment = iscCalendarCommonService.getMomentForTimezone(undefined, $scope.timezoneOffset, true);// During 1st time load of screen/directive in non-edit mode, this is void.
						} else if (iscCore.isVoid($scope.ui.selectedDateMoment)) {
							//day is selected, do not find offset, as it may .
							$scope.ui.selectedDateMoment = iscCalendarCommonService.getMomentWithStartOfDayTimeForLocal($scope.ui.selectedDate);
						}
						// TODO: Try to reduce the number of times you trigger this. Esp. when ngModelCtrl.$viewValue or $scope.ui.selectedDate is void. It is handled upstream but look to handle it here too.
						$scope.uiUpdateSelectedDate({
							"currentDayMoment": iscCalendarCommonService.getMomentWithStartOfDayTimeForLocal($scope.ui.selectedDate)
						}, false, null, "next");
					}
				}
			}
		},
		
		templateUrl: './shared/calendar/date-selector.tpl.html'
	};
}]);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp. 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/


/**
	 * @ngdoc directive
	 * @name iscTimeSlotSelector
	 * @restrict E
	 * 
	 * @description This directive will time slot selector options
	 * 
     * @param {string} slotDuration Slot duration
     * @param {boolean} slotDataLoading Flag to indicate whether to show laoding mask or not
     * @param {Object} slotGroupData Slot group data
     * @param {Function} onSlotSelectionChange Function to be called when slot selection changed
     * @param {model} ngModel Model to be used to get|set value
	 * 
	 * 
	 * @example
        <isc-time-slot-selector ng-model="ui.selectedTimeSlot" slot-duration="" 
            slot-group-data="" on-slot-selection-change="" slot-data-loading="" >
        </isc-time-slot-selector>
                    
	 */
angular.module('isc.shared').directive('iscTimeSlotSelector', ['$timeout','$filter',function($timeout,$filter) {
  return {
    restrict: 'E',
    replace:true,
    require:'^ngModel',
    scope: {
        slotDuration : '=slotDuration',
		slotDataLoading:'=slotDataLoading',
        slotGroupData:'=slotGroupData',
		onSlotSelectionChange:'&onSlotSelectionChange'
    },
	
	controller:["$scope","$locale","iscI18n",function($scope,$locale,iscI18n){	
		
        $scope.ui={};
        
        
		init= function(){
			
		}
		
		init();
        
        $scope.uiSlotSelected = function(slot){
            $scope.ui.selectedTimeSlot = slot;
            $timeout(function(){
                if($scope.onSlotSelectionChange){
                    $scope.onSlotSelectionChange();	
                }					
            },5);
        }
	}],
	
	link:function($scope, $element, $attrs,ngModelCtrl){		
		
		$scope.$watch('ui.selectedTimeSlot',function(val){
            ngModelCtrl.$setViewValue(val);
		});
		
        
        ngModelCtrl.$render = function(){
            $scope.ui.selectedTimeSlot = ngModelCtrl.$viewValue?ngModelCtrl.$viewValue:{};
        };
	},
    templateUrl: './shared/calendar/time-slot-selector.tpl.html'
  };
}]);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp.  2015, 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
/**
 * @ngdoc directive
 * @name iscApplyCouponEditOrder
 * @restrict E
 *
 * @description
 * Displays the coupon information associated with an order. If there are no coupons associated with the order, message indicating the same is displayed
 *
 * @scope
 * @param {Object=} ordermodel - Model containing order details with total number of lines and the Promotion element
 * @param {String=} orderdetailsmashupid - Mashup id to be called after changeOrder is called to add or remove the coupon. Default value is store.views.order.modification.getCompleteOrderDetails.
 * @param {String=} coupon-applied-callback - call backhandler method in the screen which will be invoked after changeOrder is called to add or remove the coupon.
 * @example
 *  The HTML will have the directive specified like below:
 *   <div>
 *      <isc-apply-coupon ordermodel="model.getCompleteOrderDetails" orderdetailsmashupid="'store.views.order.modification.getCompleteOrderDetails'"
					 coupon-applied-callback="uiCouponApplied"></isc-apply-coupon>		
 *   </div>
 */

(function(iscCore){
angular.module('isc.shared').directive('iscApplyCouponEditOrder', function() {
	return {
		restrict: 'E',
		scope: {
			  ordermodel: '=',
			  orderdetailsmashupid:'=',
			  couponAppliedCallback:'='
		    },
		    link: function (scope, element, $attr, ctrl, $transclude){
	            // link parent controller's function and invoke them accordingly.
	            scope.postCallbackData = function(orderDetails){
	               var callbackHandler = scope.couponAppliedCallback;
	               callbackHandler(orderDetails);
	            };
	         },
		    controller:['$scope','$document','$timeout','iscMashup','iscWizard','iscModal','iscAppContext','iscI18n','iscResourcePermission',function($scope,$document,$timeout,iscMashup,iscWizard,iscModal,iscAppContext,iscI18n,iscResourcePermission){
				
				$scope.ui = {
						applyCouponResourcePermission:false
				};
				$scope.couponInput = {};
				/**
				* @scDoc method
				* @method uiOpenMiniCartPopover
				* @description onclick handler function of minicart icon.
				*              calls api to fetch all orderlines of the order and displays them.
				*/
				$scope.uiShowCouponScan = function(){
					$scope.ui.showCouponScanField = true;
				};
				
				$scope.initialize = function(){
		  			if(iscResourcePermission.hasPermission("WSC000052")){
		  				$scope.ui.applyCouponResourcePermission=true;
					}
	            };
				
				$scope.uiApplyCoupon = function(couponID){
					if(!iscCore.isVoid(couponID)){
						var apiInput = {"BarCode" : { "BarCodeData" : couponID ,"OrderHeaderKey" : $scope.ordermodel.Order.OrderHeaderKey}};
	            		apiInput.BarCode.OrderDetailsMashupid = $scope.orderdetailsmashupid;
	            		apiInput.BarCode.RecordPendingChanges="Y";
	            		apiInput.BarCode.CurrentOrderModel = angular.copy($scope.ordermodel);
	            		iscMashup.callSimpleMashup($scope,"coupon_translateBarcode",apiInput,{}).then($scope.handleApplyCoupon.bind($scope),angular.noop);
	  	        	}else{
	  	        		$scope.ui.showCouponError = true;
						document.getElementById('coupon_barcode').focus();
	  	        	}
				};
				
				$scope.handleApplyCoupon = function(response){
					var output = iscMashup.getSimpleMashupOutput(response,"coupon_translateBarcode");
					/*BarCode data is returned from mashup if a duplicate couponId is entered */
					if(output.BarCode){
						iscModal.showErrorMessage(iscI18n.translate('globals.MSG_CouponAlreadyApplied'));
						//document.getElementById('coupon_barcode').value = "";
						document.getElementById('coupon_barcode').focus();
						return;
					}
					$scope.ui.showCouponError = false;
					$scope.couponInput.couponID ="";
					$scope.ordermodel = output;
					var alertMessage = iscI18n.translate("viewcartdetails.aria_applyCouponSuccessMessage");
					iscModal.showA11YAlertMessage(alertMessage);
					$scope.postCallbackData(output);
				};

				$scope.uiRemoveCoupon = function(promotion){
	            	var apiInput ={'Order':{'OrderHeaderKey':$scope.ordermodel.Order.OrderHeaderKey,'Promotions':[{'Promotion':{'Action':'REMOVE','PromotionId' : promotion.PromotionId}}],'PendingChanges':{'RecordPendingChanges':'Y'}}}; 
	            	apiInput.Order.OrderDetailsMashupid = $scope.orderdetailsmashupid;
	            	iscMashup.callSimpleMashup($scope,"coupon_changeOrderRemove",apiInput,{}).then($scope.handleRemoveCoupon.bind($scope),angular.noop);
	            };
	            
	            $scope.handleRemoveCoupon = function(response){
					var output = iscMashup.getSimpleMashupOutput(response,"coupon_changeOrderRemove");
					$scope.couponInput.couponID ="";
					$scope.ordermodel = output;
					var alertMessage = iscI18n.translate("viewcartdetails.aria_deleteCouponSuccessMessage");
					iscModal.showA11YAlertMessage(alertMessage);
					$scope.postCallbackData(output);
				};
				
				$scope.initialize();
			}],
		templateUrl: './shared/coupon/apply-coupon-edit-order-pnl.tpl.html'
	};
});
})(window.iscCore);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp.  2015, 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
/**
 * @ngdoc directive
 * @name iscApplyCoupon
 * @restrict E
 *
 * @description
 * Displays a scan field for coupon to scan. On scan, coupon is added to the order and coupon amount is displayed.
 * If coupon fails, then coupon failure reason is displayed
 *
 * @scope
 * @param {Object=} ordermodel - Model containing order details with total number of lines and the Promotion element
 * @param {String=} orderdetailsmashupid - Mashup id to be called after changeOrder is called to add or remove the coupon. Default value is viewcart_getCompleteOrderDetails.
 * @param {String=} coupon-applied-callback - call backhandler method in the screen which will be invoked after changeOrder is called to add or remove the coupon.
 * @example
 *  The HTML will have the directive specified like below:
 *   <div>
 *      <isc-apply-coupon ordermodel="model.getCompleteOrderDetails" orderdetailsmashupid="'viewcart_getCompleteOrderDetails'"
					 coupon-applied-callback="uiCouponApplied"></isc-apply-coupon>		
 *   </div>
 */

(function(iscCore){
angular.module('isc.shared').directive('iscApplyCoupon', function() {
	return {
		restrict: 'E',
		scope: {
			  ordermodel: '=',
			  orderdetailsmashupid:'=',
			  couponAppliedCallback:'='
		    },
		    link: function (scope, element, $attr, ctrl, $transclude){
	            // link parent controller's function and invoke them accordingly.
	            scope.postCallbackData = function(orderDetails){
	               var callbackHandler = scope.couponAppliedCallback;
	               callbackHandler(orderDetails);
	            };
	         },
		    controller:['$scope','$document','$timeout','iscMashup','iscWizard','iscModal','iscAppContext','iscI18n','iscResourcePermission',function($scope,$document,$timeout,iscMashup,iscWizard,iscModal,iscAppContext,iscI18n,iscResourcePermission){
				
				$scope.ui = {
						applyCouponResourcePermission:false
				};
				$scope.couponInput = {};
				/**
				* @scDoc method
				* @method uiOpenMiniCartPopover
				* @description onclick handler function of minicart icon.
				*              calls api to fetch all orderlines of the order and displays them.
				*/
				$scope.uiShowCouponScan = function(){
					$scope.ui.showCouponScanField = true;
				};
	           
				$scope.initialize = function(){
		  			if(iscResourcePermission.hasPermission("WSC000052")){
		  				$scope.ui.applyCouponResourcePermission=true;
					}
	            };
				
				$scope.uiApplyCoupon = function(couponID){
					if(!iscCore.isVoid(couponID)){
						var apiInput = {"BarCode" : { "BarCodeData" : couponID ,"OrderHeaderKey" : $scope.ordermodel.Order.OrderHeaderKey}};
	            		apiInput.BarCode.OrderDetailsMashupid = $scope.orderdetailsmashupid;
	            		apiInput.BarCode.CurrentOrderModel = angular.copy($scope.ordermodel);
	            		iscMashup.callSimpleMashup($scope,"coupon_translateBarcode",apiInput,{}).then($scope.handleApplyCoupon.bind($scope),angular.noop);
	  	        	}else{
	  	        		$scope.ui.showCouponError = true;
						document.getElementById('coupon_barcode').focus();
	  	        	}
				};
				
				$scope.handleApplyCoupon = function(response){
					var output = iscMashup.getSimpleMashupOutput(response,"coupon_translateBarcode");
					/*BarCode data is returned from mashup if a duplicate couponId is entered */
					if(output.BarCode){
						iscModal.showErrorMessage(iscI18n.translate('globals.MSG_CouponAlreadyApplied'));
						//document.getElementById('coupon_barcode').value = "";
						document.getElementById('coupon_barcode').focus();
						return;
					}
					$scope.ui.showCouponError = false;
					$scope.couponInput.couponID ="";
					$scope.ordermodel = output;
					var alertMessage = iscI18n.translate("viewcartdetails.aria_applyCouponSuccessMessage");
					iscModal.showA11YAlertMessage(alertMessage);
					$scope.postCallbackData(output);
				};

				$scope.uiRemoveCoupon = function(promotion){
	            	var apiInput ={'Order':{'OrderHeaderKey':$scope.ordermodel.Order.OrderHeaderKey,'Promotions':[{'Promotion':{'Action':'REMOVE','PromotionId' : promotion.PromotionId}}]}}; 
	            	apiInput.Order.OrderDetailsMashupid = $scope.orderdetailsmashupid;
	            	iscMashup.callSimpleMashup($scope,"coupon_changeOrderRemove",apiInput,{}).then($scope.handleRemoveCoupon.bind($scope),angular.noop);
	            };
	            
	            $scope.handleRemoveCoupon = function(response){
					var output = iscMashup.getSimpleMashupOutput(response,"coupon_changeOrderRemove");
					$scope.couponInput.couponID ="";
					$scope.ordermodel = output;
					var alertMessage = iscI18n.translate("viewcartdetails.aria_deleteCouponSuccessMessage");
					iscModal.showA11YAlertMessage(alertMessage);
					$scope.postCallbackData(output);
				};
				
				$scope.initialize();
			}],
		templateUrl: './shared/coupon/apply-coupon-pnl.tpl.html'
	};
});
})(window.iscCore);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp.  2015, 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/

/**
 * @ngdoc directive
 * @name iscCurrencyInput
 *
 * @description
 * Used to capture a currency field input. 
 * It handles formatting of the value on tab-out of the field along with mandatory and data type validation of the field.

 *
 * @example
 * <isc-currency-input currency="ui.Currency" input-attr="ui.UnitPrice" input-form="priceOverrideForm" 
 * label="'priceOverride.LABEL_new_Price'" input-name="'UnitPrice'" on-enter="uiOnEnterInputField" 
 * css-class="'form-control currency-box'"></isc-currency-input>
 *
 * @param {String} currency Id.
 * @param {String} inputAttr model Object attribute for binding value.
 * @param {Object} inputForm form name (object) to identify the form to perform field validations.
 * @param {String} label for label of the field. 
 * @param {String} inputName form field name. 
 * @param {Object} onEnter function object to bind onEnter event to. 
 * @param {Object} onChange function object to bind onChange event to. 
 * @param {Object} onBlur function object to bind onBlur event to. 
 * @param {Object} onFocus function object to bind onFocus event to. 
 * @param {String} cssClass css to apply on the field.  
 * @param {Boolean} mandatory used to mark field as required.
 *
 */


angular.module('isc.shared').directive('iscCurrencyInput', ['$filter', 'iscModal', 'iscWizard', 'iscI18n', function($filter, iscModal, iscWizard, iscI18n) {
  return {
  
		scope: {
			currency:'=',
			inputAttr:'=',
			inputForm:'=',
			inputName:'=',
			displayAttr:'=?',
			cssClass:'=',
			onChange:'=',
			onEnter:'=',
			onFocus:'=',
			onBlur:'=',
			mandatory:'=?',
			label:'='
		},
  
     	controller:['$scope', '$rootScope', '$filter', 'iscModal', 'iscMashup', function($scope, $rootScope, $filter, iscModal, iscMashup){
     		
     		if(!iscCore.isVoid($scope.inputAttr)){
     			$scope.displayAttr = $filter('iscCurrency')(angular.copy($scope.inputAttr),$scope.currency);
     		}
     		else {
     			$scope.displayAttr = "";
     		}
     		
     		if($scope.mandatory == undefined){
     			$scope.mandatory = false;
     		}
     		
     		if($scope.label == undefined){
     			$scope.label = "globals.Field";
     		}
     		
     		$scope.uiOnEnterInput = function(){
     			if($scope.onEnter){
					$scope.onEnter($scope.inputForm);
				}
     		};
     		
     		$scope.uiUpdateInput = function () {
				$scope.focusInInputtField = false;
				$scope.inputAttr = angular.copy($scope.displayAttr);
				var valueEntered = angular.copy($scope.displayAttr);
				if(!$scope.inputForm.currencyField.$valid){
					$scope.displayAttr = valueEntered;
					$scope.inputAttr = valueEntered;
					$scope.inputForm.displayCurrencyField.$setValidity("",false);
				}
				else {
					$scope.inputForm.displayCurrencyField.$setValidity("",true);
					if(!iscCore.isVoid($scope.inputAttr)){
						var groupingRegExp = new RegExp(",", "g");
						$scope.inputAttr = $scope.inputAttr.replace(groupingRegExp, "");
						$scope.displayAttr = $filter('iscCurrency')(angular.copy($scope.inputAttr),$scope.currency);
					}
					else {
						$scope.displayAttr = "";
					}
				}
				if($scope.onBlur){
					$scope.onBlur({form:$scope.inputForm});
				}
			};
			$scope.uiOnChangeInput = function(){
				if($scope.focusInInputtField){
					$scope.inputAttr = $scope.displayAttr;
					if($scope.onChange){
						$scope.onChange({form:$scope.inputForm});
					}
				}
			};
			$scope.uiOnFocusInput = function(){
				$scope.focusInInputtField = true;
				if(!iscCore.isVoid($scope.inputAttr)){
					var originalPrice = angular.copy($scope.inputAttr);
					$scope.inputAttr = $scope.displayAttr = originalPrice;
				}
				else {
					$scope.inputAttr = $scope.displayAttr = "";
				}
				if($scope.onFocus){
					$scope.onFocus({form:$scope.inputForm});
				}
			};
			$scope.$watch("inputForm.currencyField.$valid",function(newValue){
				if($scope.inputForm.displayCurrencyField){
					$scope.inputForm.displayCurrencyField.$setValidity("",newValue);
				}
			});
     	}],
	 	templateUrl: './shared/currency/templates/currency-input.tpl.html'
  };
}]);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp. 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
/**
 * @ngdoc directive
 * @name iscDateFilter
 * @restrict E
 *
 * @description
 * Helps to choose date range by either 
 *
 * a) Picking the dates from a calendar or 
 *
 * b) Entering the date in a format appropriate to the user locale or 
 *
 * c) Choosing a pre-configured date range in a date selection combobox
 *
 * @param {Date=} selected-from-date - Date model object that contains the selected 'From Date' in the format that appears on UI
 * @param {Date=} selected-from-date-to-db - Date model object that contains the selected 'From Date' in the format specified by from-date-return-format
 * @param {Date=} selected-to-date - Date model object that contains the selected 'To Date' in the format that appears on UI
 * @param {Date=} selected-to-date-to-db - Date model object that contains the selected 'To Date' in the format specified by to-date-return-format
 * @param {String=} from-date-return-format - String that contains the date format for the 'From Date'. For example, 'YYYY-MM-DDT00:00:00'
 * @param {String=} to-date-return-format - String that contains the date format for the 'To date'. For example, 'YYYY-MM-DDT23:59:59'
 * @param {Date=} max-date - Date object that specifies the maximum possible date that can be chosen or entered for 'From' and 'To' dates
 * @param {Date=} min-date - Date object that specifies the minimum possible date that can be chosen or entered for 'From' and 'To' dates
 * @param {String=} date-display-format - Date format understood by Angular Bootstrap datepicker widget to display the dates on UI
 * @param {String=} placeholder-format - Placeholder value for 'From' and 'To' dates to let user key in the dates in the locale specific format
 * @param {String=} filter-id-suffix - Used internally by date filter to uniquely identify the input widgets and button on the date filter
 * @param {String=} callee-id - Used internally by date filter to get the date filter combobox options configured for the screen/directive identified by callee-id
 *
 * @example
 *  The HTML will have the directive specified like below:
 *	<isc-date-filter selected-from-date-to-db="ui.filterCriteria.selectedFromOrderDate"
 *		selected-to-date-to-db="ui.filterCriteria.selectedToOrderDate" 
 * 		max-date="ui.filterCriteria.maxDate"
 *		date-display-format="ui.filterCriteria.dateDisplayFormat" 
 *		placeholder-format="ui.filterCriteria.placeholderFormat"
 *		from-date-return-format="ui.filterCriteria.fromDateReturnFormat"
 *		to-date-return-format="ui.filterCriteria.toDateReturnFormat"
 *		selected-from-date="ui.filterCriteria.selectedFromDate"
 *		selected-to-date="ui.filterCriteria.selectedToDate"
 *		filter-id-suffix="ui.filterCriteria.orderDateFilterSuffix"
 *		callee-id="ui.filterCriteria.calleeId">
 *	</isc-date-filter>
 */
(function(iscCore){
angular.module('isc.shared').directive('iscDateFilter', function() {
	return {
		restrict: 'E',
		require: '^form',
		scope: {
			selectedFromDate: "=",
			selectedToDate: "=",
			selectedFromDateToDb: "=",
			selectedToDateToDb: "=",
			minDate : "=",
			maxDate : "=",
			dateDisplayFormat : "=",
			placeholderFormat : "=",
			fromDateReturnFormat: "=",
			toDateReturnFormat: "=",
			filterIdSuffix: "=",
			calleeId: "="
		},
		    
		controller:['$scope','iscI18n','amSubtractFilter','iscDateFilterComboBox',function($scope,iscI18n,amSubtractFilter,iscDateFilterComboBox){
			$scope.isFromDateOpened = false;	
			$scope.isToDateOpened = false;	
			$scope.$showDatePopupButtonBar = false;
			
			$scope.datePopupOptions = {
				showWeeks: false,
				maxDate: $scope.maxDate,
				minDate: $scope.minDate
			};
			
			var dateRangeSelectionOptions = iscDateFilterComboBox.getComboOptions($scope.calleeId);
			if(dateRangeSelectionOptions) {
				angular.forEach(dateRangeSelectionOptions, function(value) {
					value.label = iscI18n.translate(value.labelBundleKey);
				});
			}
			$scope.dateRangeSelectionOptions = dateRangeSelectionOptions;
			
			/**
			 * @ngdoc method
			 * @name iscDateFilter#uiOpenFromDatePopup
			 * @description Opens the 'From' date picker popup. This can be opened either by mouse click or pressing Enter key at the input field designated for 'From Date'.
			 * 
			 */
			$scope.uiOpenFromDatePopup = function() {
				$scope.isToDateOpened = false;
				$scope.isFromDateOpened = true;
			};
			
			/**
			 * @ngdoc method
			 * @name iscDateFilter#uiOpenToDatePopup
			 * @description Opens the 'To' date picker popup. This can be opened either by mouse click or pressing Enter key at the input field designated for 'To Date'.
			 * 
			 */
			$scope.uiOpenToDatePopup = function() {
				$scope.isFromDateOpened = false;
				$scope.isToDateOpened = true;
			};
			
			/**
			 * @ngdoc method
			 * @name iscDateFilter#uiSetDateRange
			 * @description Sets the value for 'From Date' and 'To Date' based upon the option chosen in the date range picker combobox.
			 * 
			 */
			$scope.uiSetDateRange = function(selectedDateRange) {
				$scope.selectedFromDate = new Date(selectedDateRange.startDate);
				$scope.selectedToDate  = new Date(selectedDateRange.endDate);
			}
			
			$scope.$watch("selectedFromDate",function(newValue){
				if(newValue){
					$scope.selectedFromDateToDb = amSubtractFilter($scope.selectedFromDate).format($scope.fromDateReturnFormat);
				} else {
					$scope.selectedFromDateToDb = "";
				}
			});
			
			$scope.$watch("selectedToDate",function(newValue){
				if(newValue) {
					$scope.selectedToDateToDb = amSubtractFilter($scope.selectedToDate).format($scope.toDateReturnFormat);
				} else {
					$scope.selectedToDateToDb = "";
				}
			});
		}],
		
		templateUrl: './shared/datefilter/datefilter.tpl.html'
	};
});
})(window.iscCore);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp. 2016, 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
 
angular.module("isc.shared").directive("iscDialChartD3", iscDialChartD3Fn);

/**
 * @ngdoc directive
 * @name iscDialChartD3
 * @restrict E
 * @requires $window
 * @requires iscDialChartD3Service
 *
 * @description
 * 	iscDialChartD3 is a directive that creates dial charts using the D3 cjarting library. Configuration details for the
 *	chart is taken from iscDialChartD3Service.
 *	For best results and responsiveness, the directive should be added to a container or element with a height configured
 *	through css. This is set as the outer radius for the chart.
 *	The charts created have their arcs and central area clickable by default. Additionally, legends corresponding to each
 *	chart region are automatically created.
 *  Subscribes to: event_createChart to render the chart.
 *  Publishes: event_chartRegionSelection and event_chartCenterRegionSelection events on click of chart regions/legends and center region.
 *
 * @param {String} id mandatory attribute. Used to get the correct configuration from iscDialChartD3Service.
 * @param {String} class css class to apply on the base/root element of the chart.
 * @param {String} regionPadding the space in percentage to be left between two regions on the chart.
 * @param {String} textAreaText the text to display below the quantity or total number of records. This option should only be used if iconClass is not given.
 * @param {String} iconClass the css class to apply in the central region of the chart to display an icon. The quantity or total number of records are always displayed below this.
 * @param {String} innerRadius a percentage number that is used to calculate the inner radius and hence thickness of the chart. It is passed as ending with %.
 * @param {String} ignoreResizeAndOrientationchange pass it as true if the chart is located in a container that will manage or update itself on browser resize. Else this will be managed by the directive itself.
 * 
 * @example
 * 	The HTML will have the directive specified like below:
 * 		<isc-dial-chart-d3 id="bopusChart_sla" class="mgr-dashboard-chart duein" region-padding="2" 
			icon-class="app-glyphicons app-icon-pickUp_85x85" inner-radius="92%" ignore-resize-and-orientationchange="true">
		</isc-dial-chart-d3>
 */

iscDialChartD3Fn.$inject = ["$window", "iscDialChartD3Service"];

function iscDialChartD3Fn($window, iscDialChartD3Service) {
	
	var style_absoluteTransparent = "position: absolute; opacity: 0;";
	var class_regionPadClazz = "regionPadClazz";
	var class_noChartDataClazz = "noChartDataClazz";
	var class_internalPadClazz = "internalPadClazz";
	var class_cursorPointer = "show-cursor-pointer";
	var class_topPadding = "quantity-text-holder-padding";
	
	var _fn_handleErrorsAndWarnings = function(code) {
		switch(code) {
			case "e1":
				console.error("dial-chart-d3 directive: Invalid configuration error! Element does not have an id.");
				break;
				
			case "e2":
				console.error("dial-chart-d3 directive: No data! Can not create chart.");
				break;
				
			case "e3":
				console.error("dial-chart-d3 directive: Data not passed for all the regions of the chart. Can not create chart.");
				break;
				
			default:
		}
	}
	
	var _fn_prepareAndUpdateConfigJson = function(id, element, scope) {
		var configJson = null,
			chartData = iscDialChartD3Service.getDialChartRegionsConfigFromMgrDbConfig(id);
		
		scope.chartHolderId = id + "_chartHolder";
		scope.svgElemId = id + "_svg";
		scope.iconAreaId = id + "_iconArea";
		scope.textAreaId = id + "_textArea";
		scope.quantityTextId = id + "_quantityText",
		scope.legendAreaId = id + "_legendElem",
		scope.legendJsonConfigArray = [];
		scope.handleLegendClick = function(name) {
			scope.$emit("event_chartRegionSelection", {"id": scope["id"], "name": name});
		}
		
		configJson = {
			"chartData": chartData,
			"noChartDataConfig": iscDialChartD3Service.getNoChartDataConfig(),
			"innerRadius": scope["innerRadius"],
			"outerRadius": (scope["outerRadius"] == null) ? null : +scope["outerRadius"],
			"iconClass": scope["iconClass"],
			"textAreaText": scope["textAreaText"],
			"regionPadding": (scope["regionPadding"] == null) ? 3 : +scope["regionPadding"],
			"ignoreResizeAndOrientationchange": scope["ignoreResizeAndOrientationchange"]
		};
		
		iscDialChartD3Service.updateIdToConfigAndScopeMap(id, {
			"id": id,
			"scope": scope,
			"configJson": configJson
		});
		
		return configJson;
	}

	var _fn_handleChartCreation = function(event, args) {
		var id = args["id"],
			isDomEventHandler = args["isDomEventHandler"];
		
		if (id == null) {
			_fn_handleErrorsAndWarnings("e1");
			return;
		}
		
		var json = iscDialChartD3Service.getConfigAndScopeFromMap(id),
			scope = json["scope"],
			elemOfInterest_rect = document.getElementById(scope.chartHolderId).getBoundingClientRect(),
			configData = json["configJson"],
			total = 0,
			chartData = configData["chartData"],
			noChartDataConfig = configData["noChartDataConfig"],
			chartData_copy = [],
			data = [],
			radii = _fn_getRadii(elemOfInterest_rect, configData["innerRadius"], configData["outerRadius"]),
			iconClass = configData["iconClass"],
			textAreaText = configData["textAreaText"],
			regionPadding = configData["regionPadding"],
			ignoreResizeAndOrientationchange = configData["ignoreResizeAndOrientationchange"],
			dataFraction = 1 - (regionPadding*chartData.length)/100,
			isNoDataCase = false;
		
		if (event != null) {
			data = args["data"];
			if (data == null) {
				_fn_handleErrorsAndWarnings("e2");
				return;
			}
		}
		if (data.length !== chartData.length && data.length !== 0) {
			_fn_handleErrorsAndWarnings("e3");
			return;
		}
		data = iscDialChartD3Service.correctDataForChartDisplay(data);
		if (data.length === chartData.length) {
			for (var i = 0; i < chartData.length; i++) {
				chartData[i]["value"] = +data[i];
				total = total + chartData[i]["value"];
			}
			// In scenarios where ignoreResizeAndOrientationchange !== true, user will not call API again. So, you will need to persist data and re-paint old stuff.
			iscDialChartD3Service.updateChartDataInConfigAndScopeMap(id, chartData);
		}
		
		if (data.length !== 0 && total !== 0) {
			for (var i = 0; i < chartData.length; i++) {
				chartData_copy.push({
					"name": chartData[i]["name"],
					"label": chartData[i]["label"],
					"value": chartData[i]["value"],
					"clazz": chartData[i]["class"],
					"unitValueInnerPadding": chartData[i]["unitValueInnerPadding"],
					"radiusInnerPadding": (chartData[i]["radiusInnerPadding"] == null) ? 0 : chartData[i]["radiusInnerPadding"]
				});
				var currentChartData_percent = chartData_copy[i]["value"]*100/total;
				chartData_copy[i]["percentValue"] = currentChartData_percent;
				if (currentChartData_percent === 0) {
					dataFraction = dataFraction + (regionPadding/100);
				}
			}
		} else {
			isNoDataCase = true;
			chartData_copy.push(noChartDataConfig);
			chartData_copy[0]["value"] = 1;
			chartData_copy[0]["percentValue"] = 100;
			dataFraction = 1;
			total = 0;
		}
		
		for (var i = 0; i < chartData_copy.length; i++) {
			chartData_copy[i]["percentValue"] = chartData_copy[i]["percentValue"] * dataFraction;
		}
		
		var graphData = _fn_getProcessedChartData(chartData_copy, regionPadding, isNoDataCase);
		_fn_paintChart(scope, id, elemOfInterest_rect, radii, graphData, total, iconClass, textAreaText);
		_fn_updateLegendData(scope, chartData);
	}
	
	var _fn_getRadii = function(elemOfInterest_rect, ir, or) {
		if (or == null) {
			or = elemOfInterest_rect.height/2;
		}
		if (ir == null) {
			ir = or*0.85;
		} else if (ir != null && ir.indexOf("%") != -1) {
			// ignoring decimals in %
			var matches = ir.match(/\d+/g);
			if (matches != null) {
				ir = or*matches[0]/100;
			}
		}
		return {
			"ir": ir,
			"or": or
		};
	}
	
	var _fn_getProcessedChartData = function(chartData_copy, regionPadding, isNoDataCase) {
		var graphData = [],
			blankJson = iscDialChartD3Service.getBlankJsonDataWithPassedValue(regionPadding),
			blankJson_half = iscDialChartD3Service.getBlankJsonDataWithPassedValue(regionPadding/2);
			
		if (!isNoDataCase) {
			_fn_updateGraphData(graphData, blankJson_half, null, null, null, null, null);
			
			var chartDataCounter = 0,
				currentChartData = chartData_copy[chartDataCounter],
				currentChartDataPercent = currentChartData["percentValue"],
				percentCounter = regionPadding/2,
				isFirst = true;
				
			while (percentCounter <= 100) {
				while (currentChartData["percentValue"] === 0) {
					chartDataCounter++;
					currentChartData = chartData_copy[chartDataCounter];
					currentChartDataPercent = currentChartData["percentValue"];
					isFirst = true;
				}
				if (currentChartData["unitValueInnerPadding"] == null || currentChartData["unitValueInnerPadding"] === 0) {
					_fn_updateGraphData(graphData, null, currentChartData["name"], currentChartData["label"], currentChartData["percentValue"], 0, currentChartData["radiusInnerPadding"], currentChartData["clazz"]);
					percentCounter = percentCounter + currentChartData["percentValue"];
					currentChartDataPercent = 0;
				} else {
					if (isFirst) {
						isFirst = false;
						_fn_updateGraphData(graphData, null, currentChartData["name"], currentChartData["label"], currentChartData["unitValueInnerPadding"]/2, currentChartData["unitValueInnerPadding"]/2, currentChartData["radiusInnerPadding"], class_internalPadClazz);
					}
					_fn_updateGraphData(graphData, null, currentChartData["name"], currentChartData["label"], (1 - currentChartData["unitValueInnerPadding"]), (1 - currentChartData["unitValueInnerPadding"]), currentChartData["radiusInnerPadding"], currentChartData["clazz"]);
					_fn_updateGraphData(graphData, null, currentChartData["name"], currentChartData["label"], currentChartData["unitValueInnerPadding"], currentChartData["unitValueInnerPadding"], currentChartData["radiusInnerPadding"], class_internalPadClazz);
					percentCounter = percentCounter + 1;
				}
				currentChartDataPercent--;
				if (currentChartDataPercent <= 0) {
					if (currentChartData["unitValueInnerPadding"] > 0) {
						graphData.pop();
						_fn_updateGraphData(graphData, null, currentChartData["name"], currentChartData["label"], currentChartData["unitValueInnerPadding"]/2, currentChartData["unitValueInnerPadding"]/2, currentChartData["radiusInnerPadding"], class_internalPadClazz);
					}
					_fn_updateGraphData(graphData, blankJson, null, null, null, null, null);
					percentCounter = percentCounter + regionPadding;
					chartDataCounter++;
					currentChartData = chartData_copy[chartDataCounter];
					if (currentChartData == null) {
						break;
					}
					currentChartDataPercent = currentChartData["percentValue"];
					isFirst = true;
				}
			}
			graphData.pop();
			_fn_updateGraphData(graphData, blankJson_half, null, null, null, null, null);
		} else {
			_fn_updateGraphData(graphData, null, chartData_copy[0]["name"], chartData_copy[0]["label"], 100, chartData_copy[0]["unitValueInnerPadding"], chartData_copy[0]["radiusInnerPadding"], chartData_copy[0]["clazz"]);
		}
		return graphData;
	}
	
	var _fn_updateGraphData = function(graphData, blankJson, name, label, value, unitValueInnerPadding, radiusInnerPadding, clazz) {
		if (blankJson != null) {
			graphData.push(blankJson);
		} else {
			graphData.push({
				"name": name,
				"label": label,
				"value": value,
				"unitValueInnerPadding": (unitValueInnerPadding == null) ? 0 : unitValueInnerPadding,
				"radiusInnerPadding": (radiusInnerPadding == null) ? 0 : radiusInnerPadding,
				"clazz": clazz
			});
		}
	}
	
	var _fn_paintChart = function(scope, id, elemOfInterest_rect, radii, graphData, totalValue, iconClass, textAreaText) {
		var pieDataFn = d3.pie().sort(null).value(function(d) {
				return d.value;
			}),
			clazzFn = function (d, i) {
				var clazz = d["data"]["clazz"];
				if (clazz !== class_regionPadClazz && clazz !== class_noChartDataClazz) {
					clazz = clazz + " " + class_cursorPointer;
				}
				return clazz;
			},
			attr_d_fn = function (d, i) {
				var localArc = d3.arc().outerRadius(radii.or),
					radiusInnerPadding = d["data"]["radiusInnerPadding"],
					dialThickness = radii.or - radii.ir;
					
				d.innerRadius = radii.ir;
				d.outerRadius = radii.or;
				if (radiusInnerPadding !== 0) {
					d.innerRadius = d.innerRadius + dialThickness*radiusInnerPadding;
					d.outerRadius = d.outerRadius - dialThickness*radiusInnerPadding;
					localArc = d3.arc().outerRadius(d.outerRadius);
				}
				return localArc(d);
			},
			arcClickFn = function(d, i) {
				var name = d["data"]["name"];
				if (name !== "blank" && name != "noChartData") {
					scope.$emit("event_chartRegionSelection", {"id": scope["id"], "name": name});
				}
			},
			centerAreaOnClickFn = function() {
				scope.$emit("event_chartCenterRegionSelection", {"id": scope["id"]});
			};
			
		var elemObj = _fn_positionAndGetAllChartElem(scope, id, elemOfInterest_rect, radii, totalValue, iconClass, textAreaText);
		var svgElem_g = elemObj.svgElem_g,
			iconAreaElem = elemObj.iconAreaElem,
			textAreaElem = elemObj.textAreaElem,
			quantityTextElem = elemObj.quantityTextElem;
			
		iconAreaElem.on("click", centerAreaOnClickFn);
		quantityTextElem.on("click", centerAreaOnClickFn);
		if (textAreaElem != null) {
			textAreaElem.on("click", centerAreaOnClickFn);
		}
		
		var arcs = svgElem_g.selectAll("path");
		if (arcs._groups[0][0] != null) {
			arcs.remove();
		}
		arcs = svgElem_g.selectAll("path").data(pieDataFn(graphData)).enter().append("path").attr("class", clazzFn).attr("d", attr_d_fn).on("click", arcClickFn);
	}
	
	var _fn_positionAndGetAllChartElem = function(scope, id, elemOfInterest_rect, radii, totalValue, iconClass, textAreaText) {
		// We can't have all 3 - iconAreaElem, quantityTextElem and textAreaText together. iconAreaElem and quantityTextElem OR quantityTextElem and textAreaText.
		var textAreaElem = null;
		var svgElem = d3.select("#" + scope.svgElemId),
			svgElem_g = d3.select("#" + scope.svgElemId + " " + "g"),
			svgElem_styleStr = "position: absolute; left: " + (elemOfInterest_rect.width - radii.or*2)/2 + "px; top: " + (elemOfInterest_rect.height - radii.or*2)/2 + "px;";
		svgElem.attr("width", radii.or*2).attr("height", radii.or*2);
		svgElem.attr("style", svgElem_styleStr);
		if (svgElem_g._groups[0][0] == null) {
			svgElem_g = svgElem.append("g");
		}
		svgElem_g = svgElem_g.attr("transform", "translate(" + radii.or + "," + radii.or + ")");
		
		var iconAreaElem = d3.select("#" + scope.iconAreaId),
			iconAreaElem_styleStr = "",
			iconAreaElemRect = {};
		iconAreaElem.attr("style", style_absoluteTransparent);
		if (iconClass != null) {
			var existingClass = iconAreaElem.attr("class");
			iconAreaElem.attr("class", (existingClass + " " + iconClass));
			iconAreaElemRect = iconAreaElem._groups[0][0].getBoundingClientRect();
			// Position the icon such that only 15% comes below the center point of the chart circle.
			iconAreaElem_styleStr = "position: absolute; left: " + (elemOfInterest_rect.width - iconAreaElemRect.width)/2 + "px; top: " + (elemOfInterest_rect.height/2 - (0.8 * iconAreaElemRect.height)) + "px;";
			iconAreaElem.attr("style", iconAreaElem_styleStr);
		}
		
		var quantityTextElem_styleStr = "",
			quantityTextElem = d3.select("#" + scope.quantityTextId),
			quantityTextElemRect = {};
		quantityTextElem.attr("style", style_absoluteTransparent).text(totalValue);
		quantityTextElemRect = quantityTextElem._groups[0][0].getBoundingClientRect();
		if (iconClass != null) {
			// Position such that it is just below iconAreaElem. Padding takes care of spacing.
			var existingClass2 = quantityTextElem.attr("class");
			quantityTextElem.attr("class", (existingClass2 + " " + class_topPadding));
			quantityTextElem_styleStr = "position: absolute; left: " + (elemOfInterest_rect.width - quantityTextElemRect.width)/2 + "px ;top: " + (elemOfInterest_rect.height/2 + (0.2 * iconAreaElemRect.height)) + "px;";
		} else {
			// Position in the middle.
			quantityTextElem_styleStr = "position: absolute; left: " + (elemOfInterest_rect.width - quantityTextElemRect.width)/2 + "px ;top: " + (elemOfInterest_rect.height - quantityTextElemRect.height)/2 + "px;";
		}
		quantityTextElem.attr("style", quantityTextElem_styleStr);
		
		var textAreaElem = d3.select("#" + scope.textAreaId),
			textAreaElem_styleStr = "",
			textAreaElemRect = {};
		textAreaElem.attr("style", style_absoluteTransparent).text(textAreaText);
		textAreaElemRect = textAreaElem._groups[0][0].getBoundingClientRect();
		if (textAreaText != null && quantityTextElem_styleStr == "") {
			// Position in the middle.
			textAreaElem_styleStr = "position: absolute; left: " + (elemOfInterest_rect.width - textAreaElemRect.width)/2 + "px ;top: " + (elemOfInterest_rect.height - textAreaElemRect.height)/2 + "px;";
		} else if (textAreaText != null && quantityTextElem_styleStr != "") {
			// Position such that it is just below quantityTextElem as it is in the middle. Padding takes care of spacing.
			textAreaElem_styleStr = "position: absolute; left: " + (elemOfInterest_rect.width - textAreaElemRect.width)/2 + "px ;top: " + (elemOfInterest_rect.height/2 + quantityTextElemRect.height/2) + "px;";
		}
		textAreaElem.attr("style", textAreaElem_styleStr);
		
		var legendAreaElem_styleStr = "",
			legendAreaElem = d3.select("#" + scope.legendAreaId),
			legendAreaElemRect = {};
		legendAreaElem.attr("style", style_absoluteTransparent);
		legendAreaElem_styleStr = "position: absolute; left: 0px; top: 0px;";
		legendAreaElem.attr("style", legendAreaElem_styleStr);
		
		return {
			"svgElem_g": svgElem_g,
			"iconAreaElem": iconAreaElem,
			"textAreaElem": textAreaElem,
			"quantityTextElem": quantityTextElem
		};
	}
	
	var _fn_updateLegendData = function(scope, chartData) {
		// Legend is reverse of chart data.
		for (var i = chartData.length - 1; i >= 0; i--) {
			var aRegion = chartData[i];
			scope.legendJsonConfigArray[chartData.length - (i + 1)] = {
				"cssClass": aRegion["class"],
				"iconClass": aRegion["iconClass"],
				"statusName": aRegion["name"],
				"value": aRegion["value"],
				"label": aRegion["label"]
			};
		}
	}

	return {
		restrict: "E",
		scope: {
			"id": "@",
			"chartData": "=",// not designed for right now. May be future.
			"innerRadius": "@",
			"outerRadius": "@",
			"iconClass": "@",
			"textAreaText": "@",
			"regionPadding": "@",
			"ignoreResizeAndOrientationchange": "@"
		},
		templateUrl: "./shared/dial-chart-d3/dial-chart-d3.tpl.html",
		link: function fn_iscDialChartD3Link(scope, element, attributes) {
			var id = scope["id"];
				//chartData = scope["chartData"],
			_fn_prepareAndUpdateConfigJson(id, element, scope);
			
			scope.$on("event_createChart", _fn_handleChartCreation);
			
			if (scope["ignoreResizeAndOrientationchange"] !== "true") {
				var _angularWindowElement = angular.element($window);
				// TODO: How to trigger only once? - some browsers will trigger both events according to docs. Need to verify.
				_angularWindowElement.on("resize", function() {_fn_handleChartCreation(null, {"id": id, "isDomEventHandler": true})});
				_angularWindowElement.on("orientationchange", function() {_fn_handleChartCreation(null, {"id": id, "isDomEventHandler": true})});
			}
		}
	};
}
/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
 /**
 * @ngdoc directive
 * @name iscAutofocus
 *
 * @requires iscAppContext
 * @requires iscAutofocus
 *
 * @restrict A
 *
 * @description
 * Sets focus on the element on which the directive is applied. This directive is used in the modal windows (including the error/confirmation/information modal windows) to put focus on the first
 * editable/focusable element. Focus will not be put on mobile devices and tablets using this directive. This is because, we don't want the 
 * mobile keyboard to come up by default because of the focus. 
 *
 * When focus needs to be set for a bootstrap element tag, an attribute 'isc-tag-name' needs to be set in the HTML with the tag name of the element. Focus logic is pre-configured for each bootstrap element in autofocus.config.js. If needed, new logic for focus can be added in that config file by the user for a bootstrap element.
 *
 * @example
 * <button class="btn" isc-autofocus ng-click="uiAction(action.actionName)" 
 *
 *	ng-repeat="action in options.action"></button> 
 *
 *	<uib-tab select="uiNearbyView()" isc-autofocus isc-tag-name="uib-tab"></uib-tab>
 */
 
angular.module('isc.shared').directive('iscAutofocus',['iscAppContext','iscAutofocus','$timeout',function(iscAppContext,iscAutofocus,$timeout){
   return {
      restrict: 'A',
	  priority: -100,
      link : function(scope,element,attr) {
			
    	  scope.$watch(attr.iscAutofocus,function(value) {
    		  
    		  if(value === null || value === undefined){
    			  value = true;
    		  } 
              if(value){
            	var nativeHTMLTabbableElementsArray = ["A","AREA","INPUT","BUTTON","SELECT","TEXTAREA","IFRAME","OBJECT","EMBED"];
      			var htmlElementTagName = element[0].tagName;
      			
                  if(!iscAppContext.isMobile()) {
      				if(nativeHTMLTabbableElementsArray.indexOf(htmlElementTagName) > 1) {
      					if(!element[0].disabled) // If the element is disabled, do not focus
      						element[0].focus();
							element[0].autofocus = true;
      				} else {
      					if(element[0].getAttribute('isc-tag-name'))
      						iscAutofocus.setFocusOnElement(scope,element,attr);
      				}
      			} else {
      				var focusElement = element[0];
					/*if(focusElement && focusElement.tagName != 'INPUT') { *////RTC 520658 Keyboard doesn't come up for text fields in mobile
						if(!focusElement.hasAttribute('readonly')) {
      					focusElement.setAttribute('readonly','readonly');
						}
						focusElement.autofocus = true;
						focusElement.focus();
						$timeout(function ()
						{					
							focusElement.removeAttribute('readonly');
						}, 50);
					/*}*/
      			}
			}
		});
	}
   };
}]);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
angular.module('isc.shared').directive('iscFocus',function(){
   return {
      restrict: 'A',
      link : function(scope,element,attr) {
            scope.$watch(attr.iscFocus,function(value) {
                    if(value){
                     // $timeout(function(){
                        element[0].focus();
                     // });
                    }
            });
        }
   };
});

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
/**
 * @ngdoc directive
 * @name iscI18n
 * @restrict A
 * 
 * @description Transaltes the bundle key and places the localized content inside current element or to the attributes
 * <p>syntax single - <[i18n:sep:attributename]<({dynamicdata})>bundlekey
 * <p>For Multile &lt;single&gt;;&lt;tsingle&gt;
 * 
 * Note : 
 * This directive will add a watcher if [i18n] is added as prefix
 * This directive will not support using filters in the expression binding
 * 
 * @param {string} bundleKeys The bundleKeys that needs to be translated
 * 
 * @example
    <!-- to translate static bundle key -->
    <span isc-i18n="global.TITLE_Product_name"></span>
    <!-- to translate bundle key dynamic data -->
    <span isc-i18n="[i18n]({context:'{{shipent.DeliveryMethod}}'})shipment.LABEL_Shipment_method" ></span>
    <!-- to translate bundle key and add : as separator -->
    <span isc-i18n="[sep]user.LABEL_First_name" ></span>
    <!-- to translate bundle key and place it to an attribute -->
    <span isc-i18n="[title]user.ARIA_First_name" ></span>
		<!-- multilple otions -->
    <span isc-i18n="[i18n:title:sep]({"data":"{{bindData}}"})user.LABEL_Multi_options" ></span>
 */



(function(iscCore){
  
  iscCore._parseI18nOptions = function(options){
    var res = {
			attr: 'text'
		};
		options = options.split(':');
		for (var i = 0; i < options.length; ++i) {
			if (options[i] === 'i18n') {
				res[options[i]] = true;
			}
			else if (options[i] === 'sep') {
				res[options[i]] = true;
			}
			else {
				res.attr = options[i];
			}
		}
		return res;
  };
  
  iscCore._parseI18nKey = function(key) {
		var options = {
				attr: 'text'
			},
			i18nOptions = '{}',
			tmp;
		key = key.trim();
		if (key.indexOf('[') === 0) {
			tmp = key.split(']');
			options = iscCore._parseI18nOptions(tmp.shift().substr(1).trim());
			key = tmp.join(']');
		}
		if (options.i18n && key.indexOf('(') === 0 && key.indexOf(')') >= 0) {
			tmp = key.split(')');
			key = tmp.pop().trim();
			i18nOptions = tmp.join(')').substr(1).trim();
		}
		return {
			key: key,
			options: options,
			i18nOptions: i18nOptions
		};
	};
  
  
})(window.iscCore);



angular.module('isc.shared').directive('iscI18n', ['iscI18n', '$compile', '$parse', '$interpolate', function (iscI18n, $compile, $parse, $interpolate) {
  'use strict';
  
	
	function hasDynanicValue(key){
		return key.indexOf('i18n') > 0;
	}
  
	
  
  
  function I18nCtrl($scope, $element) {
		var argsUnregister;
		var stringUnregister;

		function parse(key) {
			var parsedKey = iscCore._parseI18nKey(key);
			parsedKey.i18nOptions = $parse(parsedKey.i18nOptions);

			// If there are watched values, unregister them
			if (argsUnregister) {
				argsUnregister();
			}
			if (stringUnregister) {
				stringUnregister();
			}

			function render(i18nOptions) {
				if (i18nOptions.sprintf) {
					i18nOptions.postProcess = 'sprintf';
				}
				if(angular.isString(i18nOptions.count)){
				  i18nOptions.count = parseInt(i18nOptions.count);
				  //console.log(i18nOptions.count);
				}
				var string = iscI18n.translate(parsedKey.key, i18nOptions);
				if(parsedKey.options['sep']===true){
				  string+=': ';
				}
				if (parsedKey.options.attr === 'html') {
					$element.empty().append(string);
					$compile($element.contents())($scope);
					return;
				}
				if (stringUnregister) {
					stringUnregister();
				}
				var insertText = $element.text.bind($element);
				if (parsedKey.options.attr !== 'text') {
					insertText = $element.attr.bind($element, parsedKey.options.attr);
				}
				string = $interpolate(string);
				stringUnregister = $scope.$watch(string, insertText);
				insertText(string($scope));
			}
			//argsUnregister = $scope.$watch(parsedKey.i18nOptions, render, true);
			render(parsedKey.i18nOptions($scope));
		}

		this.localize = function localize(key) {
			var keys = key.split('[}{]');//key.split(';');
			var len = keys.length;
			while(len--){
				key = keys[len].trim();
				if (key === '') {
					continue;
				}
				parse(key);
			}
		};
	}

  
  return {
   
    restrict: 'A',
		scope: false,
		require: 'iscI18n',
		
		controller: ['$scope', '$element', I18nCtrl],
		compile : function($element, $attrs, $transclude){			
			//$attrs.$set("iscI18nKey",$attrs.iscI18n.replace(/\{\{/g,"{]{").replace(/\}\}/g,"}[}"));
			$attrs.$set("iscI18n",$attrs.iscI18n.replace(/'/g,"[}]").replace(/"/g,"[{]").replace(/;/g,"[}{]"));
			//console.log($attrs.iscI18n);			
			return {
				pre : function postLink(scope, element, attrs, ctrl) {
		  //add a watcher only if there is dynamic value
		  if(hasDynanicValue(attrs.iscI18n)){
				
		    var translationValue = '';
			  var observe = function (value) {
				  translationValue = value.replace(/^\s+|\s+$/g, ''); // RegEx removes whitespace
  				if (translationValue === '') {
  					return setupWatcher();
  				}
					//var textKey = attrs.iscI18nKey.replace(/\{\]\{/g,"{{").replace(/\}\[\}/g,"}}");
					//textKey = textKey.replace(/'/g,"{]}").replace(/"/g,"{[}");
					//var textInter = $interpolate(textKey);
					//var textValue = textInter(scope);
					var textValue = translationValue;
					textValue = textValue.replace(/'/g,"\\'").replace(/"/g,"\\\"").replace(/\[\}\]/g,"'").replace(/\[\{\]/g,"\"");
					//textValue = textValue.replace(/^\s+|\s+$/g, '')
					ctrl.localize(textValue);
  				//ctrl.localize(translationValue);
  			};  
  			var setupWatcher = function() {
  				// Prevent from executing this method twice
  				if (setupWatcher.done) {
  					return;
  				}
  				// interpolate is allowing to transform {{expr}} into text
  				var interpolation = $interpolate(element.html());
  				scope.$watch(interpolation, observe);
  				setupWatcher.done = true;
  			};
  			attrs.$observe('iscI18n', observe);		    
		  }
		  else{
		    ctrl.localize(attrs.iscI18n.replace(/^\s+|\s+$/g, ''));
		  }
		  
		}    
				
			}
			
		}
		/*
		link: function postLink(scope, element, attrs, ctrl) {
		  //add a watcher only if there is dynamic value
		  if(hasDynanicValue(attrs.iscI18n)){
		    var translationValue = '';
			  var observe = function (value) {
				  translationValue = value.replace(/^\s+|\s+$/g, ''); // RegEx removes whitespace
  				if (translationValue === '') {
  					return setupWatcher();
  				}
  				ctrl.localize(translationValue);
  			};  
  			var setupWatcher = function() {
  				// Prevent from executing this method twice
  				if (setupWatcher.done) {
  					return;
  				}
  				// interpolate is allowing to transform {{expr}} into text
  				var interpolation = $interpolate(element.html());
  				scope.$watch(interpolation, observe);
  				setupWatcher.done = true;
  			};
  			attrs.$observe('iscI18n', observe);		    
		  }
		  else{
		    ctrl.localize(attrs.iscI18n.replace(/^\s+|\s+$/g, ''));
		  }
		  
		}  */  
	};
}]);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
angular.module("isc.shared").directive("iscItemAdditionalDetails", iscItemAdditionalDetailsFn);
/**
 * @ngdoc directive
 * @name iscItemAdditionalDetails
 * @restrict E
 *
 * @description
 * # Overview
 * Displays additional details for an item like: detailed description or the variation panel for a variant item.
 * The directive will automatically update the parent controller/screen with the selected variant in case of a 
 * variation item selection.
 *
 * @example
 *  The HTML will have the directive specified like below:
 *		<isc-item-additional-details id="itemDetailsWithVariationContainer"
 *			class="detailsContainer show-tab-details"
 *			ng-if="ui.showItemDesc"
 *			config-data="{
 *				'itemDetails': model.itemDetails,
 *				'variationList': model.getCompleteItemList.ItemList.VariationList,
 *				'variantItemId': ui.variantItemId,
 *				'showItemDesc': ui.showItemDesc
 *			}">
 *		</isc-item-additional-details>
 */
 
iscItemAdditionalDetailsFn.$inject = [];
// Future TODO: Try to isolate the scope and update parent scope instead of shared scope. This will be cleaner.
function iscItemAdditionalDetailsFn() {
	return {
		restrict: "E",
		scope: true,
		templateUrl: "./shared/item/item-additional-details.tpl.html",
		link: function(scope, element, attributes) {
			var configObj = scope.$eval(attributes.configData) || {};
			var itemDetails = configObj.itemDetails;
			
			scope.ui.variationList = configObj.variationList;
			scope.ui.variantItemId = configObj.variantItemId;
			scope.ui.showItemDesc = configObj.showItemDesc;
			
			scope.ui.showVariationPanel = itemDetails.ShowVariationPanel;
			scope.ui.description = itemDetails.PrimaryInformation.Description;
			
		},
		controller: [
			"$scope",
			"$sce",
			"iscModal",
			"iscI18n",
			"iscWizard",
			function($scope, $sce, iscModal, iscI18n, iscWizard) {
				$scope.uiRenderHtml = function(itemDesc) {
					return $sce.trustAsHtml(itemDesc);
				};
				
				$scope.uiHandleValiationItemSelection = function(itemId) {
					if (iscCore.isVoid(itemId)) {
						iscModal.showErrorMessage(iscI18n.translate('addItems.MSG_ProductSearchError'));
					} else if (this.ui.isScreenDirty) {
						iscModal.showConfirmationMessage(iscI18n.translate('addItems.MSG_Screen_dirty')).then(function(action) {
							if (iscCore.isBooleanTrue(action)) {
								iscWizard.gotoCustomPage('addItems', {input: itemId}, {removeCurrent: true});
							} else {
								// action is no. so clear search text.
								this.model.searchInput = '';
							}
						});
					} else {
						iscWizard.gotoCustomPage('addItems', {input: itemId}, {removeCurrent: true});
					}
				}.bind($scope);
			}
		]
	};
}
/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp.  2015, 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
angular.module("isc.shared").directive("iscItemAvailability", iscItemAvailabilityFn);
/**
 * @ngdoc directive
 * @name iscItemAvailability
 * @restrict E
 *
 * @description
 * # Overview
 * Displays all information related to item availability such as: if the item is available in store or for shipping 
 * or for pickup. Directive also includes capability to change delivery method and open store selection popup. The
 * directive will automatically update the parent controller/screen with the selections made.
 *
 * @example
 *  The HTML will have the directive specified like below:
 *		<isc-item-availability class="col-xsm-12 col-sm-12 item-availability"
 *			config-data="{
 *				'itemDetails': model.itemDetails,
 *				'availability': ui.availability,
 *				'deliveryMethod': ui.deliveryMethod
 *			}">
 *		</isc-item-availability>
 */

iscItemAvailabilityFn.$inject = [];
// Future TODO: Try to isolate the scope and update parent scope instead of shared scope. This will be cleaner.
function iscItemAvailabilityFn() {
	var _fn_resetAttributesOnScope = function(scope, configData) {
		scope.ui.deliveryMethod = configData.deliveryMethod;
		scope.model.itemDetails = configData.itemDetails;
		scope.ui.availability = configData.availability;
	};
	
	return {
		restrict: "E",
		scope: true,
		templateUrl: "./shared/item/item-availability.tpl.html",
		link: function(scope, element, attributes, ctrl) {
			var configObj = scope.$eval(attributes.configData) || {};
			_fn_resetAttributesOnScope(scope, configObj);
		},
		controller: [
			"$scope",
			"iscModal",
			"iscI18n",
			"$filter",
			function($scope, iscModal, iscI18n, $filter) {
				/* This will override the value on scope in link and we do not get anything from the config obj.
				$scope.ui = {
					"deliveryMethod": "",
					"isScreenDirty": false,
					"selectedShipNode": {
						"shipNode": "",
						"shipNodeDesc": ""
					},
					"availability": {
						//shp ui attributes
						"itemShpAvailableDate": "",
						"itemShpAvailableText": "",
						"itemShpAvailable": false,
						"itemShpAvailableToday": false,
						
						//pick ui attributes
						"itemPickAvailable": false,
						"itemPickAvailableText": "",
						"itemPickAvailableDate": "",
						
						//carry ui attributes.
						"itemCarryAvailable": false,
						"itemCarryAvailableDate": ""
					}
				};
				
				$scope.model = {
					"itemDetails": {}
				};
				*/
				
				$scope.init = function() {
					// might need to do something in future, possibly.
				};
				
				$scope.uiSetDeliveryMethod = function(delMethod) {
					// checking for isShippingAllowed/IsPickAllowed as ng-click handler gets triggered even when links are disabled.
					if (delMethod === "SHP" && window.iscCore.isBooleanTrue(this.model.itemDetails.PrimaryInformation.IsShippingAllowed)) {
						this.ui.deliveryMethod = delMethod;
					}
					if (delMethod === "PICK" && window.iscCore.isBooleanTrue(this.model.itemDetails.PrimaryInformation.IsPickupAllowed)) {
						this.ui.deliveryMethod = delMethod;
					}
					if (delMethod === "CARRY") {
						this.ui.deliveryMethod = delMethod;
					}
				};

				$scope.uiOpenStoreSearch = function(fromContext) {
					if (this.model.itemDetails.PrimaryInformation.IsPickupAllowed === "Y") {
						var that = this;
						that.fromContext = fromContext;
						var storeSearchModalInput = {
							"modalInput": function() {
								return {
									"inputData": {
										"callingMode": "ADDITEMS",
										"itemDetails": that.model.itemDetails,
										"RequiredQty": that.ui.defaultQty
									}		
								};
							}
						};
						iscModal.openModal("store.views.common.storesearch.storesearch", storeSearchModalInput, {}).then(function(callBackData) {
							that.afterStoreSelection.call(that, callBackData.data, that.fromContext);
						}, angular.noop);
					}
				};
				
				$scope.afterStoreSelection = function(data, fromContext) {
					this.ui.isScreenDirty = true;
					this.ui.selectedShipNode.shipNode = data.selectedStore.ShipNode;
					this.ui.selectedShipNode.shipNodeDesc = data.selectedStore.Description;

					if (window.iscCore.isBooleanTrue(data.selectedStore.Availability.IsAvailable) && window.iscCore.isBooleanFalse(data.selectedStore.Availability.IsFutureAvailability)) {
						//item is available today
						this.ui.availability.itemPickAvailable = true;
						this.ui.availability.itemPickAvailableDate = data.selectedStore.Availability.AvailableDate;
						this.ui.availability.itemPickAvailableText = iscI18n.translate("globals.LABEL_ItemAvailableTodayAtStore", {
							"date": $filter("date")(data.selectedStore.Availability.AvailableDate, "mediumDate"),
							"shipNodeDesc": this.ui.selectedShipNode.shipNodeDesc
						});
					} else if (window.iscCore.isBooleanTrue(data.selectedStore.Availability.IsAvailable) && window.iscCore.isBooleanTrue(data.selectedStore.Availability.IsFutureAvailability)) {
						// item is available at future date.
						this.ui.availability.itemPickAvailable = true;
						this.ui.availability.itemPickAvailableDate = data.selectedStore.Availability.AvailableDate;
						this.ui.availability.itemPickAvailableText = iscI18n.translate("addItems.LABEL_ItemPickAvailableNotTodaySameStore", {
							"date": $filter("date")(data.selectedStore.Availability.AvailableDate, "fullDate"),
							"shipNodeDesc": this.ui.selectedShipNode.shipNodeDesc
						});
					} else if(window.iscCore.isBooleanFalse(data.selectedStore.Availability.IsAvailable) && window.iscCore.isBooleanFalse(data.selectedStore.Availability.IsFutureAvailability)) {
						this.ui.availability.itemPickAvailable = false;
					}
					
					this.uiSetDeliveryMethod("PICK");
					_fn_resetAttributesOnScope(this, {
						"deliveryMethod": this.ui.deliveryMethod,
						"itemDetails": this.model.itemDetails,
						"availability": this.ui.availability
					});
					/* Not required/possible for returns.
					if (fromContext !== null && fromContext !== undefined && fromContext === "addToCart") {
						this.uiHandleAddToCart();
					}
					*/
				};
				
				$scope.init();
			}
		]
	};
}
/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp.  2015, 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
angular.module("isc.shared").directive("iscItemDetails", iscItemDetailsFn);
/**
 * @ngdoc directive
 * @name iscItemDetails
 * @restrict E
 *
 * @description
 * # Overview
 * Displays all item related details like: item image, description, id and price. It also includes buttons to increase or
 * decrease item quantity. There is also an add to cart button option that can be configured to invoke any handler on the
 * parent controller/screen.
 *
 * @example
 *  The HTML will have the directive specified like below:
 *		<isc-item-details id="itemDetailsContainer"
 *			config-data="{
 *				'itemDetails': model.itemDetails,
 *				'getCompleteItemList': model.getCompleteItemList,
 *				'priceOverride': ui.priceOverride,
 *				'selectedShipNode': ui.selectedShipNode,
 *				'gift': ui.gift,
 *				'defaultQty': ui.defaultQty,
 *				'deliveryMethod': ui.deliveryMethod,
 *				'isShippingAllowed': model.itemDetails.PrimaryInformation.IsShippingAllowed,
 *				'isPickupAllowed': model.itemDetails.PrimaryInformation.IsPickupAllowed,
 *				'handleAddAction': uiHandleAddToCart
 *			}">
 *		</isc-item-details>
 */

iscItemDetailsFn.$inject = [];
// Future TODO: Try to isolate the scope and update parent scope instead of shared scope. This will be cleaner.
function iscItemDetailsFn() {
	return {
		restrict: "E",
		scope: true,
		templateUrl: "./shared/item/item-details.tpl.html",
		link: function(scope, element, attributes) {
			var configObj = scope.$eval(attributes.configData) || {};
			
			var itemDetails = configObj.itemDetails;
			var getCompleteItemList = configObj.getCompleteItemList;
			var priceOverride = configObj.priceOverride;
			var gift = configObj.gift;
			
			scope.ui.getCompleteItemList = getCompleteItemList;
			// originally model.itemDetails
			scope.ui.itemDetails = itemDetails;
			scope.ui.selectedShipNode = configObj.selectedShipNode;
			scope.ui.defaultQty = configObj.defaultQty;
			scope.ui.deliveryMethod = configObj.deliveryMethod;
			scope.ui.isShippingAllowed = configObj.isShippingAllowed;
			scope.ui.isPickupAllowed = configObj.isPickupAllowed;
			
			scope.handleAddAction = configObj.handleAddAction;
			
			scope.ui.imageURL = itemDetails.PrimaryInformation.ImageURL;
			scope.ui.extendedDisplayDescription = itemDetails.PrimaryInformation.ExtendedDisplayDescription;
			scope.ui.itemID = itemDetails.ItemID;
			scope.ui.variations = itemDetails.Variations;
			scope.ui.classificationModel = itemDetails.ClassificationCodes.Model;
			scope.ui.modelItem = itemDetails.PrimaryInformation.IsModelItem;
			scope.ui.kitCode = itemDetails.PrimaryInformation.KitCode;
			scope.ui.isPriceOverridden = priceOverride.isPriceOverriden;
			scope.ui.unitPrice = itemDetails.ComputedPrice.UnitPrice;
			scope.ui.listPrice = itemDetails.ComputedPrice.ListPrice;
			scope.ui.currency = getCompleteItemList.ItemList.Currency;
			scope.ui.displayUnitOfMeasure = itemDetails.DisplayUnitOfMeasure;
			scope.ui.giftOptionsAvailable = gift.giftOptionsAvailable;
		},
		controller: [
			"$scope",
			"iscMashup",
			"iscAppContext",
			"iscI18n",
			"$filter",
			"iscItem",
			"iscModal",
			function($scope, iscMashup, iscAppContext, iscI18n, $filter, iscItem, iscModal) {
				/*
				$scope.ui = {
					"isScreenDirty": false,
					"defaultQty": 1,
					"deliveryMethod": "",
					"selectedShipNode": {
						"shipNode": "",
						"shipNodeDesc": ""
					},
					"availability": {
						//shp ui attributes
						"itemShpAvailableDate": "",
						"itemShpAvailableText": "",
						"itemShpAvailable": false,
						"itemShpAvailableToday": false,
						
						//pick ui attributes
						"itemPickAvailable": false,
						"itemPickAvailableText": "",
						"itemPickAvailableDate": "",
						
						//carry ui attributes.
						"itemCarryAvailable": false,
						"itemCarryAvailableDate": ""
					}
				};
				$scope.model = {
					"itemDetails": {}
				};
				$scope.mashupRefs = [{
					"mashupRefId": "getItemAvailabilityForStore",
					"mashupId": "addItems_getItemAvailabilityForStore",
					"modelName": "getItemAvailabilityForStore"
				}];
				// model.itemDetails is now ui.itemDetails
				*/
				
				$scope.init = function() {
					// might need to do something in future, possibly.
				};
				
				$scope.uiHandlePriceOverride = function() {
					// open override price popup and process the data returned from popup.
					var ovpInput = {
							"price": {
								"listPrice": this.ui.listPrice,
								"unitPrice": this.ui.unitPrice,
								"Currency": this.ui.currency
							}
						},
						priceOverrideInput = {
							"modalInput": function() {
								return ovpInput;
							}
						};
					
					iscModal.openModal("store.views.common.priceoverride.priceoverride", priceOverrideInput, {}).then((function(callBackData) {
						if (!iscCore.isVoid(callBackData) && !iscCore.isVoid(callBackData.data)) {
							this.ui.unitPrice = callBackData.data.newprice;
							this.ui.priceOverride.priceOverrideReason = callBackData.data.reason;
							this.ui.priceOverride.isPriceOverriden = true;
							this.ui.isScreenDirty = true;
// TODO: Needed to update model on screen. Thus, had to use this. Figure a better way when you fix the shared scope.
							if (this.model != null && this.model.itemDetails!= null && this.model.itemDetails.ComputedPrice != null) {
								this.model.itemDetails.ComputedPrice.UnitPrice = this.ui.unitPrice;
							}
						}
					}).bind(this), angular.noop);
				};
				
				$scope.uiIncreaseQty = function() {
					this.ui.isScreenDirty = true;
					this.ui.defaultQty++;
					this.callGetItemAvailabilityForStoreApi(this.ui.defaultQty);
				};
				
				$scope.uiDecreaseQty = function() {
					if (this.ui.defaultQty !== 1) {
						this.ui.isScreenDirty = true;
						this.ui.defaultQty--;
						this.callGetItemAvailabilityForStoreApi(this.ui.defaultQty);
					}
				};
				
				$scope.callGetItemAvailabilityForStoreApi = function(qty) {
					var input = this.getItemAvailabilityForStoreApiInput(qty);
					iscMashup.callSimpleMashup(this, "getItemAvailabilityForStore", input, {}).then((function(data) {
						var apiOutput = iscMashup.getSimpleMashupOutput(data, "getItemAvailabilityForStore");
						var promiseLine = apiOutput.Promise.PromiseLines.PromiseLine[0];
						if (!iscCore.isVoid(promiseLine.Availabilities)) {
							retObj = iscItem.handleItemAvailability(promiseLine.Availabilities, this.ui.selectedShipNode, this.ui.isShippingAllowed, this.ui.isPickupAllowed);
							this.ui.availability = retObj.availability;
							this.ui.deliveryMethod = retObj.deliveryMethod;
							if (retObj.selectedShipNode != null) {
								this.ui.selectedShipNode = retObj.selectedShipNode;
							}
						}
					}).bind(this),angular.noop);
				};
				
				$scope.getItemAvailabilityForStoreApiInput = function(qty) {
					var currentStoreAddress = iscAppContext.getFromContext("storeAddress")["ShipNodePersonInfo"];
					var input = {
						"Promise": {
							"ShipToAddress": currentStoreAddress,
							"PromiseLines": [{
								"PromiseLine": {
									"ItemID": this.ui.itemDetails.ItemID,
									"UnitOfMeasure": this.ui.itemDetails.UnitOfMeasure,
									"ProductClass": this.ui.itemDetails.ProductClass,
									"RequiredQty": qty
								}
							}]
						}
					};
					return input;
				};
				
				$scope.init();
			}
		]
	};
}
/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
angular.module('isc.shared').directive('iscItemImageResize', ["$timeout",function ($timeout) {
    return {
        restrict: 'A', 
        link: function (scope, element, attrs) {
            var onImageLoad = function () {
                var naturalHeight = ele[0].naturalHeight;
                var naturalWidth = ele[0].naturalWidth;
                var clientWidth = ele[0].parentNode.clientWidth + "px";
                var style = "", width = "auto", height = "auto";
                if(clientWidth == "0px") {
                    width="100%";
                } 
                else if (naturalHeight > naturalWidth) {
                    style = "width:auto;height:" + clientWidth;
                    height = "" + clientWidth;
                }
                else {
                    style = "height:auto;width:" + clientWidth;
                    width = "" + clientWidth;
                }
                ele[0].style.width = width;
                ele[0].style.height = height;
            }
            var ele = element;
            element.bind('load', onImageLoad);
            
            element.bind('error', function () {
                var ele = element;
                ele[0].className += " item-image-blank";
            });
            
            if(!iscCore.isVoid(attrs.iscItemImageResize)){
                scope.$watch(attrs.iscItemImageResize, function (newValue) {
                    $timeout(onImageLoad,10)
                });
            }
            
        }
    };
}]);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/

angular.module('isc.shared').directive('iscItemImage', function() {
  return {
    restrict: 'E',
	  replace:true,
    scope: {
      imageLocation: '=imageLocation',
	  imageId:'=imageId'	  
    },
    templateUrl: './shared/item/item-image.tpl.html'
  };
});

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
 
(function(iscCore){
	/**
	 * @ngdoc directive
	 * @name iscItemVariation
	 * @restrict E
	 *
	 * @description
	 * # Overview
	 * Paints the variation item attributes, determines allowed combination for the selected attribute
	 * and displays them in the view.When any attribute is clicked in view, all the selected combinations
	 * are compared with allowed combination and if selected combination is available then varaint item
	 * details are loaded highlighting the variant product's combination.
	 *
	 * @scope
	 * @param {Object=} Object having the variation product details.
	 * @param {String=} Callback handler function to be executed on selection of child product.
	 * @param {String} child product of variation product.
	 * @example
	 *  The HTML will have the directive specified like below:
	 *   <div>
	 *       <isc-item-variation data="model.getCompleteItemList.ItemList.VariationList"  
	 *        post-variantitem-select="uiOpenItemDetails" variant-item-id="ui.variantItemId">
	 *        </isc-item-variation>
	 *   </div>
	 */
  angular.module('isc.shared').directive('iscItemVariation', function() {
     return {
        restrict: 'E',
        scope: {
             data: '=',
             variantItemId: '=',
             postSelect: '=postVariantitemSelect'
        },
        link: function (scope, element, $attr, ctrl, $transclude){
           // link parent controller's function and invoke them accordingly.
           scope.handleVariantItemSelection = function(itemId){
              var variantItemSelectHandler = scope.postSelect;
              variantItemSelectHandler(itemId);
           };
        },
        controller:['$scope','iscItemVariation','iscAppInfo','iscI18n',function($scope,iscItemVariation,iscAppInfo,iscI18n){
           /**
            * @ngdoc method
            * @name iscItemVariation#initialize
            * @description This method stores the allowed combinations for all the attributes and also creates
            * map to store the selected attributes.
            */
           $scope.initialize = function(){
              var variantList = $scope.data.ItemList;
              iscItemVariation.populateAllowedCombinationList(variantList);
              iscItemVariation.populateItemAttrMap(variantList);
              iscItemVariation.setVariationList(variantList);
              $scope.selectedComb = iscItemVariation.getNewCombinationObj();
              if(!iscCore.isVoid($scope.variantItemId)){
                 // select variant item combination by default.
                 $scope.showVariantItemCombination();
              }
           };

           $scope.uiShowVariations = function(attribute,assignedValue){
              attribute.selectedOption = assignedValue.DisplayAttributeValue === ""? 
              iscI18n.translate('addItems.LABEL_None') : assignedValue.DisplayAttributeValue;
              $scope.selectedComb.setAttributeValue(attribute.AttributeID,assignedValue.DisplayAttributeValue);
              iscItemVariation.markSelectedForAttributes($scope.selectedComb);
              $scope.chooseVariations(attribute.AttributeID,assignedValue.DisplayAttributeValue);
              // check if allowed and selected attributes are same. if yes, then get varint item id and load child item details.
              var allowedCombList = iscItemVariation.getAllowedCombinationList();
              for(var i = 0; i < allowedCombList.length; i++){
                var allowedComb = allowedCombList[i];
                if(angular.equals(allowedComb.getAttributeValuesMap(),$scope.selectedComb.getAttributeValuesMap())){
                  if($scope.variantItemId !== allowedComb.getItemID()){
                    //$scope.variantItemId = allowedComb.getItemID();
                    $scope.handleVariantItemSelection(allowedComb.getItemID());
                  }
                  break; 
                }
              }
           };

          /**
            Iterate through each attribute list, get selected values from view except current selected attribute
            and filter allowed combination for selected combination.
            Iterate through allowed combination list, get allowed values for current attribute and set invalidCombination
            to false if value is present in allowed values(show as avaialable in view).
            Check if current selected value is present in allowed list. If not present, then selected value is not allowd
            and show selected attribute as unavailable in view.
           */
           $scope.chooseVariations = function(attrId,displayAttrValue){
              var attrList = $scope.data.ItemList.AttributeList.Attribute;
              for(var i =0; i < attrList.length; i++){
                var attribute = attrList[i];
                var combExceptCurrentAttr = $scope.getSelectedComb($scope.selectedComb,attribute.AttributeID);
                if(!iscCore.isVoid(combExceptCurrentAttr.getAttributeValuesMap())){
                    var validCombList = iscItemVariation.getValidCombinationList(combExceptCurrentAttr);
                    var allowedValues = $scope.getAllowedValueForCurrentAttr(validCombList,attribute.AttributeID);
                    var assignedValueList = attribute.AssignedValueList.AssignedValue;
                    // mark values as available if present in allowed values.
                    for(var j = 0; j < assignedValueList.length; j++){
                      var assignedValue = assignedValueList[j];
                      var isAllowed = iscItemVariation.isValuePresentInAllowedArray(assignedValue.DisplayAttributeValue,allowedValues);
                      if(isAllowed === true){
                        assignedValue.InvalidCombination = false;
						assignedValue.categoryAvailability = 'Available';
                      }
                      else{
                        assignedValue.InvalidCombination = true;
						assignedValue.categoryAvailability = 'Unavailable';
                      }
                    }
                    //check if selected value is present in allowed array.if not present,show unavialable text for attribute.
                   var selectedValue = $scope.selectedComb.getAttributeValue(attribute.AttributeID);
                   if(!iscCore.isVoid(selectedValue)){
                      var isCurrentValAllowed = iscItemVariation.isValuePresentInAllowedArray(selectedValue,allowedValues);
                      if (!isCurrentValAllowed){
                          if(!iscCore.isVoid(selectedValue)){
                            attribute.unavailableText = iscI18n.translate
                            ('addItems.MSG_Unavailable_txt',
                            {value: selectedValue});
                          }
                      }
                      else if(!iscCore.isVoid(attribute.unavailableText)){
                        delete attribute.unavailableText;
                      }
                    }
                  }
              }
           };

           $scope.getAllowedValueForCurrentAttr = function(validCombList,currentAttrId){
             var allowedValues = [];
             for(i = 0; i < validCombList.length; i++){
                var comb = validCombList[i];
                var allowedVal = comb.getAttributeValue(currentAttrId);
                if(allowedValues.indexOf(allowedVal) < 0){
                    allowedValues.push(allowedVal);
                }
             }
             return allowedValues;
           }

           $scope.getSelectedComb = function(selectedComb,attrIdToSkip){
              var comb = iscItemVariation.getNewCombinationObj();
              var attrMap = selectedComb.getAttributeValuesMap();
              for(var key in attrMap){
                if(key !== attrIdToSkip){
                    comb.setAttributeValue(key,attrMap[key]);
                }
              }
              return comb;
           };
          $scope.showVariantItemCombination = function(){
                // mark selected comb as available and selected.*/
                var combination = iscItemVariation.getVariantItemCombination($scope.variantItemId);
                $scope.setSelectedCombination(combination);
                iscItemVariation.markSelectedForAttributes($scope.selectedComb);
                // show available combinations for variant item.
                var attrMap = combination.getAttributeValuesMap();
                for(var key in attrMap){
                  $scope.chooseVariations(key,attrMap[key]);
                }
           };
           $scope.setSelectedCombination = function(combination){
              var attributeValueMap = combination.getAttributeValuesMap();
              for(var key in attributeValueMap){
                    $scope.selectedComb.setAttributeValue(key,attributeValueMap[key]);
              }
           };
           $scope.$watch("data",function(newData){
              $scope.data = newData;
               $scope.initialize();
           });
        }],
        templateUrl: './shared/item/item-variation.tpl.html'
     };
  });
})(window.iscCore);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp.  2015, 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
 /**
 * @ngdoc directive
 * @name iscRelatedItem
 * @restrict E
 *
 * @description
 * # Overview
 * Displays all the product associations of a product in carousel. The number of associated products are split into slides
 * with each slide displaying 9 products at a time.The associated products are split into slides as carousel expects data in slides.
 *
 * @scope
 * @param {String=} Object containning all the product associations.
 * @param {String=} Callback handler function that will be invoked by the directive to display the related product
 * details.
* @example
*  The HTML will have the directive specified like below:
*   <div>
*       <isc-related-item input="model.relatedItemDetails" on-item-click="uiOpenItemDetails">
*        </isc-related-item>
*   </div>
*/

(function(iscCore){
angular.module('isc.shared').directive('iscRelatedItem', function() {
   return{
      restrict: 'E',
      scope: {
           input: '=',
           onSelect: '=onItemClick'
      },
      link: function (scope, element, $attr, ctrl, $transclude){
         // link parent controller's function and invoke them accordingly.
         scope.uiGetItemDetails = function(itemId){
            var relatedItemClickHandler = scope.onSelect;
            relatedItemClickHandler(itemId);
         };
      },
      controller:['$scope',function($scope){
         $scope.carousel={
            dataToSlide: '',
            data:[],
            active:0,
            myInterval: 0,
            noWrapSlides: false
         };
         $scope.noRelatedItems = false;

         $scope.initialize= function(){
            if(iscCore.isVoid($scope.input.ItemList.Item[0].AssociationTypeList) &&
               iscCore.isVoid($scope.input.ItemList.Item[0].AssociationTypeList.AssociationType)){
               $scope.noRelatedItems = true;
            }
            $scope.paintCrousel();
         };
         $scope.paintCrousel= function(){
            var associationTypeList = $scope.input.ItemList.Item[0].AssociationTypeList;
            if(!iscCore.isVoid(associationTypeList) && !iscCore.isVoid(associationTypeList.AssociationType)){
              var associationList = associationTypeList.AssociationType[0].AssociationList;
              if(!iscCore.isVoid(associationList)){
                 var associations = associationList.Association;
                 if(!iscCore.isVoid(associations) && associations instanceof Array){
                   $scope.getCarouselSlideData(associations);
                 }
               }
            }
         };
         $scope.getCarouselSlideData= function(associations){
            var i = 0;
            var len = associations.length;
            $scope.carousel.data = [];
            $scope.carousel.dataToSlide = 0;
            while(i < len){
               $scope.carousel.data[$scope.carousel.dataToSlide] =
                  associations.slice(i, i + 9);
               $scope.carousel.data[$scope.carousel.dataToSlide].id = $scope.carousel.dataToSlide;
               $scope.carousel.dataToSlide++;
                i += 9;
            }
         };
         $scope.initialize();
      }],
      templateUrl: './shared/item/related-item.tpl.html'
   };
});
})(window.iscCore);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp. 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
(function(iscCore) {
	angular
			.module('isc.shared')
			.directive(
					'iscKeywordList',
					function() {
						return {
							restrict : 'E',
							transclude: false,
							scope : {
								keywordListData:'=',
								onKeywordSelection:'&'
							},
					        link: function (scope, element, $attr, ctrl, $transclude){
					            
					         },
							controller : [
									'$scope',
									'$document',
									'$filter',
									'iscMashup',
									'iscModal',
									'iscAppContext',
									'iscI18n',
									'$interval',
									'$rootScope',
									'$timeout',
									'iscResourcePermission',
									'iscState',
									'iscObjectUtility',
								    function($scope, $document, $filter,iscMashup,iscModal,iscAppContext,iscI18n,$interval,$rootScope,$timeout,iscResourcePermission,iscState,iscObjectUtility) {
										
										$scope.ui = {
												
												keywordNavigationBarSettings : {
													isNavigationBarInMotion: false,
													navigationBarDirection: "",
													navigationBarScrollOffset: 150,
													showRightNavigator:true,
													showLeftNavigator:true,
													hideNavigators:false
												}
											
										};
										
										 /**
									       *@scDoc ModelList
									       *@description Model that can used in template html to display data
									       * 
									       */
									     
										$scope.model = {
												keywordList:{}
										};
										
										/**
										 * @description This method is used to initialize the navigation bar. TODO
										 */
										$scope.initialize = function(){
											
											 $timeout( function(){
												 $scope.initializeNavigationBar();
										        }, 100 );
											
										};
										
										/**
										 * @description This method toggles the display of right and left navigation actions. TODO
										 */
										$scope.initializeNavigationBar = function() {
											
								            	var pnProductNav = document.querySelector('div.search-keywords-holder');
								            	var pnProductNavContents = document.querySelector('div.search-keywords-list');
								            	
								            	if(pnProductNavContents && pnProductNav) {
								            		var overflowDirection = $scope.determineOverflow(pnProductNavContents, pnProductNav);
									        		if(overflowDirection == "none") {
									        			$scope.ui.keywordNavigationBarSettings.hideNavigators = true;
									        		} else if(overflowDirection == "right") {
								            			$scope.ui.keywordNavigationBarSettings.showLeftNavigator = false;
								            		} else if(overflowDirection == "left") {
								            			$scope.ui.keywordNavigationBarSettings.showRightNavigator = false;
								            		}
								            	}
								            
							        		
										};
										
										/**
										 * @description This method determines the overflow direction. TODO
										 */
										$scope.determineOverflow = function(content, container) {
							            	
								            	var containerMetrics = container.getBoundingClientRect();
								            	var containerMetricsRight = Math.floor(containerMetrics.right);
								            	var containerMetricsLeft = Math.floor(containerMetrics.left);
								            	var contentMetrics = content.getBoundingClientRect();
								            	var contentMetricsRight = Math.floor(contentMetrics.right);
								            	var contentMetricsLeft = Math.floor(contentMetrics.left);
								            	
								            	if (containerMetricsLeft > contentMetricsLeft && containerMetricsRight < contentMetricsRight) {
								            		return "both";
								            	} else if (contentMetricsLeft < containerMetricsLeft) {
								            		return "left";
								            	} else if (contentMetricsRight > containerMetricsRight) {
								            		return "right";
								            	} else {
								            		return "none";
								            	}
							            	
							            };
							            
							            /**
										 * @description This method is handler for right arrow click action. This method scrolls the navigation bar to the right, by particular offset value.
										 * This method also toggles the display of right & left arrows on reaching the end of the panel. 
										 * 
										 */
							            $scope.uiShowPrevious = function() {
							
								            	var pnProductNav = document.querySelector('div.search-keywords-holder');
								            	var pnProductNavContents = document.querySelector('div.search-keywords-list');
								            	
								            	if(pnProductNav && pnProductNavContents) {
								            	
									            	var overflowDirection = $scope.determineOverflow(pnProductNavContents, pnProductNav);
									            	pnProductNav.scrollLeft -= $scope.ui.keywordNavigationBarSettings.navigationBarScrollOffset;
								            		
								            		if(overflowDirection == "right") {
								            			$scope.ui.keywordNavigationBarSettings.showLeftNavigator = false;
								            		} else {
								            			$scope.ui.keywordNavigationBarSettings.showRightNavigator = true;
								            		}
								            	}
							            };
						            
							            /**
										 * @description This method is handler for left arrow click action. This method scrolls the navigation bar to the left, by particular offset value.
										 * This method also toggles the display of right & left arrows on reaching the end of the panel.
										 */
							            $scope.uiShowNext = function() {
							            	
								            	var pnProductNav = document.querySelector('div.search-keywords-holder');
								            	var pnProductNavContents = document.querySelector('div.search-keywords-list');
								            	
								            	if(pnProductNav && pnProductNavContents) {
								            		
								            		var overflowDirection = $scope.determineOverflow(pnProductNavContents, pnProductNav);
									            	pnProductNav.scrollLeft += $scope.ui.keywordNavigationBarSettings.navigationBarScrollOffset;
								            		
								            		if(overflowDirection == "left") {
								            			$scope.ui.keywordNavigationBarSettings.showRightNavigator = false;
								            		} else {
								            			$scope.ui.keywordNavigationBarSettings.showLeftNavigator = true;
								            		}
								            	}
								            	
							            };
										
							            /**
										 * @description This method invokes the method on the parent controller on clicking on any keyword.
										 */
										$scope.uiSearchProductsByKeyword = function(keyword) {
											$scope.onKeywordSelection({itemKeyword:keyword.Value});
										};
										
										$scope.initialize();

									} ],
							templateUrl : './shared/keywords-list/keywords-list.tpl.html'
						};
					});
})(window.iscCore);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp. 2016, 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/

/**
 * @ngdoc directive
 * @name iscLookup
 *
 * @description Directive to paint lookup for Sales Order, Product and Customer. This is mainly used as an entry point to create returns.
 * @example
 * <isc-lookup search-result-callback="uiHandleSearchResult" ordermodel="model.returnOrder" config="model.lookupConfig"></isc-lookup>
 *
 * @param {String} search-result-callback is callback handler function to handle search results in UI.
 * @param {Object} ordermodel is return order model. This should have BillToID and is used in searching products.
 * @param {Object} config is model which indicates which lookup type (Order, Product or Customer) should be opened by default.
 * 
 */
(function(iscCore) {
	angular
			.module('isc.shared')
			.directive(
					'iscLookup',
					function() {
						return {
							restrict : 'E',
							scope : {
								postTranslation: '=searchResultCallback',
								ordermodel: '=',
								config: '=',
								mode: '@?'
							},
					        link: function (scope, element, $attr, ctrl, $transclude){
					            // link parent controller's function and invoke them accordingly.
					            scope.postCallbackData = function(returnData){
					               var callbackHandler = scope.postTranslation;
					               returnData.Mode = scope.mode;
					               callbackHandler(returnData);
					            };
					         },
							controller : [
									'$scope',
									'$document',
									'$filter',
									'iscMashup',
									'iscModal',
									'iscAppContext',
									'iscI18n',
									'$interval',
									'$rootScope',
									'$timeout',
									'iscResourcePermission',
									'iscState',
									'iscDomUtility',
									'iscShipmentStatus',
								    function($scope, $document, $filter,iscMashup,iscModal,iscAppContext,iscI18n,$interval,$rootScope,$timeout,iscResourcePermission,iscState,iscDomUtility,iscShipmentStatus) {
										$scope.ui = {
												selectedLookup : "ORDER",
												lookup : {},
												lookupTypeList : 
													[
														{
															name : iscI18n.translate('returnLookup.ACTION_Order'),
															type : 'ORDER',
															iconfont : 'app-glyphicons app-icon-order_30',
															advanceSearchTemplate : 'shared/lookup/advancesearch-order.tpl.html'
															
														},
														{
															name : iscI18n.translate('returnLookup.ACTION_Shipment'),
															type : 'SHIPMENT',
															iconfont : 'app-glyphicons app-icon-shipment_30',
															advanceSearchTemplate : 'shared/lookup/advancesearch-shipment.tpl.html'
														},
														{
															name : iscI18n.translate('returnLookup.ACTION_Product'),
															type : 'PRODUCT',
															iconfont : 'app-glyphicons app-icon-product_30',
															advanceSearchTemplate : ''
														},
														{
															name : iscI18n.translate('returnLookup.ACTION_CustLoyaltyCard'),
															type : 'CUSTOMER',
															iconfont : 'app-glyphicons app-icon-customer_30',
															advanceSearchTemplate : 'shared/lookup/advancesearch-customer.tpl.html'
														}
														
													],
											    modes :
											    	{
											    		"returns" : {
											    			
											    			"lookupMap": [
											    			           {type : "ORDER", resourceId: "WSC000033"},
											    			           {type : "PRODUCT", resourceId: "WSC000033"},
											    			           {type : "CUSTOMER", resourceId: "WSC000033"}
											    			           
											    			       ]
											    			
											    		},
											    		
											    		"global-search" : {
											    			"lookupMap": [
												    			           {type : "ORDER", resourceId: "WSC000036"},
																		   {type : "SHIPMENT", resourceId: "WSC000056"},
												    			           {type : "PRODUCT", resourceId: "WSC000031"},
												    			           {type : "CUSTOMER", resourceId: "WSC000037"}
												    			       ]
											    		}
											    	 
											    	},
												showCustomerAdvanceSearch:false,
												showAdvanceSearch : false,
												productTooltip:"globals.LABEL_ScanProduct",
												search : {},
												lookupRegion:"lookup.aria_lookupRegion",
												CustomerPaymentMethod : {},
												shipmentSearchCriteria: {},
												shipmentFilters: {},
												ShipmentStatus:{},
												ShipmentFulfillment: {}
										};
										
										 /**
									       *@scDoc ModelList
									       *@description Model that can used in template html to display data
									       * 
									       */
									     
										$scope.model = {
												lookupInput : {},
												blindReturnRule : {},
												paymentTypeList:{},
												selectedPaymentMethod:{},
												scacList:{}
										};
										
										$scope.init = function(){
											
											if(!iscCore.isVoid($scope.config)) {
												this.ui.lookup.selected = $scope.getLookupByType($scope.config.LookupType);		
											} else {
												this.ui.lookup.selected = $scope.getDefaultLookupTypeByMode();
											}
											
											$scope.uiSetLookupType();
											
											$scope.setLookupRegionByMode();
											
											iscMashup.callSimpleMashup($scope,"returnLookup_getRuleDetails",{},{}).then($scope.handleGetRuleDetails.bind($scope),angular.noop);
											
											iscMashup.callSimpleMashup($scope,"shared.lookup.getPaymentTypeList",{},{}).then(
													function(response) {
														var output = $scope.getOutputByMashupId(response,"shared.lookup.getPaymentTypeList");
												 		this.model.paymentTypeList = output;
												 		
												 		var emptyPaymentType = {"PaymentTypeDescription": iscI18n.translate('orderFilter.LABEL_All')};
												 		this.model.paymentTypeList.PaymentTypeList.PaymentType.splice(0, 0, emptyPaymentType);
												 		
													}.bind($scope),angular.noop);

											//initialize shipment search
											$scope.initShipmentSearch();
										};
										
										$scope.getDefaultLookupTypeByMode = function() {
											
											var lookupType = ""; 
											
											var supportedMode = $scope.ui.modes[$scope.mode];
											
											if(!iscCore.isVoid(supportedMode)) {
												
													for(var i = 0;i < supportedMode.lookupMap.length;i++) {
												
														if(!iscCore.isVoid(supportedMode.lookupMap[i].resourceId)) {
															if(iscResourcePermission.hasPermission(supportedMode.lookupMap[i].resourceId)) {
																lookupType = supportedMode.lookupMap[i].type;
																break;
															}
														} else {
															lookupType = supportedMode.lookupMap[i].type;
															break;
														}
																	
													}
											}
											
											return $scope.getLookupByType(lookupType);
											
										};
										
										$scope.setLookupRegionByMode = function() {
											if("returns" == $scope.mode)
												$scope.ui.lookupRegion = "lookup.aria_returnLookupRegion";
											else if ("global-search" == $scope.mode) 
												$scope.ui.lookupRegion = "lookup.aria_globalLookupRegion";
											else if ("instore-receiving" == $scope.mode) {
												$scope.ui.lookupRegion = "aria_inStoreReceivingLookupRegion";
												$scope.ui.productTooltip = "globals.LABEL_ScanProductCode";
											}
												
										};

										$scope.uiFilterLookupTypesByMode = function(lookupType) {
											
											var showLookup = false;
											
											var supportedMode = $scope.ui.modes[$scope.mode];
											
											if(!iscCore.isVoid(supportedMode)) {
												
												var lookupTypeForMode = $scope.getLookupByTypeForMode(supportedMode, lookupType);
												
												if(!iscCore.isVoid(lookupTypeForMode)) { 
														if(!iscCore.isVoid(lookupTypeForMode.resourceId)) {
															if(iscResourcePermission.hasPermission(lookupTypeForMode.resourceId)) {
																showLookup = true;
															}
															
														} else {
															showLookup = true;
														}
														
														if($scope.mode == 'returns' && lookupTypeForMode.type == "PRODUCT"  && !iscCore.isVoid($scope.model.blindReturnRule) && 
																!iscCore.isVoid($scope.model.blindReturnRule.Rules) && !iscCore.isVoid($scope.model.blindReturnRule.Rules.RuleSetValue)  && $scope.model.blindReturnRule.Rules.RuleSetValue != 'Y'){
															showLookup = false;
														}
															
												}
											}
											
											
											return showLookup;

										};
										
										$scope.uiGetAdvanceSearchTemplate = function() {
											
											var searchTemplate = "";
											
											for(var i = 0;i < this.ui.lookupTypeList.length;i++) {
												if(this.ui.lookupTypeList[i].type == this.ui.lookup.selected.type && !iscCore.isVoid(this.ui.lookupTypeList[i].advanceSearchTemplate)) {
													searchTemplate = "./"+this.ui.lookupTypeList[i].advanceSearchTemplate;
													break;
												}
											}
											
											return searchTemplate;
											
										};
										
										$scope.getLookupByTypeForMode = function(mode, lookupType) {
											
											var lookupObject = {};
											
											if(!iscCore.isVoid(lookupType) && !iscCore.isVoid(mode)) {
												for(var i = 0;i < mode.lookupMap.length;i++) {
													if(mode.lookupMap[i].type == lookupType.type) {
														lookupObject= mode.lookupMap[i];
														break;
													}
												}
											}
											
											if(iscCore.isVoid(lookupObject)) {
												//console.log("Unsupported lookup type : ",lookupType);
											}
											
											return lookupObject;
										};
										
										$scope.getLookupByType = function(lookupType) {
											
											var lookupObject = "";
											
											if(!iscCore.isVoid(lookupType)) {
												for(var i = 0;i < this.ui.lookupTypeList.length;i++) {
													if(this.ui.lookupTypeList[i].type == lookupType) {
														lookupObject= this.ui.lookupTypeList[i];
														break;
													}
												}
												//console.log("Unsupported lookup type : ",lookupType);
											} 
											
											return lookupObject;
											
										};
										
										 $scope.handleGetRuleDetails = function(response) {
										 		var output = $scope.getOutputByMashupId(response,"returnLookup_getRuleDetails");
										 		this.model.blindReturnRule = output;
										 		/*if(this.mode == 'returns' && this.model.blindReturnRule.Rules.RuleSetValue != 'Y'){
										 			this.ui.lookupTypeList.splice(1,1);
										 		}*/
										 };
										 
										$scope.getSearchConfigByType = function(searchType) {
											
											var searchConfig = this.ui.returnSearchCriteria[0];
											
											if(!iscCore.isVoid(searchType)) {
												for(var i=0;i<this.ui.returnSearchCriteria.length;i++) {
													if(this.ui.returnSearchCriteria[i].type == searchType) {
														searchConfig = this.ui.returnSearchCriteria[i];
														break;
													}
												}
											} 
											
											return searchConfig;
										};
										$scope.uiSetLookupType = function(selectedItem) {
								  			this.ui.selectedLookup = this.ui.lookup.selected.type;
											this.model.lookupInput.value = '';
											$timeout(function (){
												var widgetId = $scope.mode+'_'+$scope.ui.selectedLookup+'_scanField';
												iscDomUtility.setFocus(document.getElementById(widgetId));
											}, 0);
								  			
								  		},
										$scope.uiSetDefaultLookup = function() {
								  			this.ui.lookup.selected = this.ui.lookupTypeList[0];
								  		},
										$scope.uiIsLookupSelected = function(lookupType) {
											return lookupType == this.ui.selectedLookup;
										},
										
										$scope.uiSearchByType = function(lookupType) {
											if (!iscCore.isVoid(this.model.lookupInput.value)) {
												if(this.mode == 'global-search' && lookupType == 'PRODUCT') {
													iscState.goToState('ordercapture',{action:'SCAN',input:this.model.lookupInput.value},{});
													$scope.uiSearchClose();
												} else {
													$scope.searchByType(this.model.lookupInput.value,lookupType);
												}
											} else {
												$scope.showErrorMessageByType(lookupType);
											}
										};
										
										$scope.uiAdvanceSearchByType = function(lookupType){
											if(!iscCore.isVoid($scope.uiGetAdvanceSearchTemplate())) {
												this.ui.showAdvanceSearch = true;
												$scope.$emit('AdvanceSearchSelection',{'data':this.ui.selectedLookup});
											}
											
											if(this.ui.selectedLookup==='CUSTOMER') {
													this.ui.search = {};
												 	this.ui.CustomerPaymentMethod = {};
													this.ui.showCustomerAdvanceSearch=true;
													$scope.$emit('AdvanceCustomerSelection',{'data':this.ui.selectedLookup});
											}

											if(this.ui.selectedLookup==='SHIPMENT') {
												this.ui.shipmentSearchCriteria = {};
												iscDomUtility.setFocus(document.getElementById($scope.mode+'_'+$scope.ui.selectedLookup+'_shipment_orderNumber'));
											}else{
												iscDomUtility.setFocus(document.getElementById($scope.mode+'_'+$scope.ui.selectedLookup+'_customer_firstName'));
											}
										};
										
										$scope.uiIsAdvCustomerSelected = function(){
											if(this.ui.showCustomerAdvanceSearch===true)
												return true;
										};

										$scope.uiAdvanceClose = function(){
											this.ui.showCustomerAdvanceSearch=false;
											$scope.$emit('AdvanceCustomerSelectionhide',{'data':this.ui.selectedLookup});
											 $timeout(function ()
												    {
												        document.getElementById($scope.mode+'_'+$scope.ui.selectedLookup+'_advanceSearchLink').focus();
												    }, 500);
											 
											 /**
											  * 
											  */
											 this.ui.showAdvanceSearch = false;
											 $scope.$emit('AdvanceSearchSelectionhide',{'data':this.ui.selectedLookup});
											 /**
											  * 
											  */
										};
										
										$scope.uiSearchClose = function(){
											$scope.$emit('uiSearchClose',{'data':this.ui.selectedLookup});
										};
										
										$scope.uiAdvanceSearch = function(){
											
											if(!this.ui.search){
											   this.ui.search = {};
											}
											
											if(this.ui.selectedLookup==='CUSTOMER') {
												this.callSearchApi(this.ui.search, this.ui.CustomerPaymentMethod);
											} else if (this.ui.selectedLookup==='ORDER') {
												
												if(!iscCore.isVoid(this.model.selectedPaymentMethod) && !iscCore.isVoid(this.model.selectedPaymentMethod.PaymentType)) {
													this.ui.search.PaymentMethod = this.model.selectedPaymentMethod;
												}
												
												var getOrderListInputInput = {Order:this.ui.search};
												
												iscMashup.callSimpleMashup($scope,"shared.lookup.getOrderListBySearchCriteria",getOrderListInputInput,{}).then($scope.handleAdvanceOrderSearchResult.bind($scope),angular.noop);
											} else if (this.ui.selectedLookup==='SHIPMENT') {
												this.executeShipmentSearch();
											}
										};
										
										$scope.uiSearchOnEnter = function(){
										
										   this.uiAdvanceSearch();
										  
										};
			
										$scope.callSearchApi = function (resultdata, paymentMethodModel){
											
										   var getCustomerListInput = {Customer:{CustomerContactList:{CustomerContact:resultdata}}};
											   
										   if(paymentMethodModel){
										   	   getCustomerListInput.Customer.CustomerPaymentMethodList={};
											   getCustomerListInput.Customer.CustomerPaymentMethodList.CustomerPaymentMethod = {};
											   getCustomerListInput.Customer.CustomerPaymentMethodList.CustomerPaymentMethod = paymentMethodModel;
										   }
										    var paginationDataObj ={scPageSize:iscAppContext.getFromContext("listApiPageSize"),
														    		scPageNumber:1,
														    		scPaginationStrategy:'NEXTPAGE'};
										    
										   iscMashup.callSimplePaginatedMashup($scope,"returnLookup_getCustomerList",getCustomerListInput,paginationDataObj,"START",{}).then($scope.handleAdvanceSearchOutput.bind($scope),angular.noop);
									   		
									        
									   };

									   $scope.uiValidatorForEmail = function(validationResponseObj, angularErrorObj, modelValue, viewValue){
									   		if(angularErrorObj.pattern || angularErrorObj.email)
									   		{
									   			validationResponseObj.booleanResponse = false;
												validationResponseObj.errorMesssage = iscI18n.translate('datatype.EmailFormat');
									   		}
									   		return validationResponseObj;
									   };
									   
										$scope.handleAdvanceSearchOutput = function(response){
											
											 var returnModel = {};
									    	 returnModel.NextPage = {};
									    	 returnModel.NextPage.model = {};
							            	 
									    	 var output = $scope.getOutputByMashupId(response,"returnLookup_getCustomerList");
									    	 
									    	 if(output.Page.Output.CustomerList.TotalNumberOfRecords === '1'){
									    		 returnModel.NextPage.model.Customer = output.Page.Output.CustomerList.Customer[0];
									    		 returnModel.NextPage.action = 'customerDetails';
									    	 }else{
									    		// output.Page.Output.CustomerList.SearchText = this.model.lookupInput.value;
										    	 returnModel.NextPage.model = output;
									    		 returnModel.NextPage.action = 'customerList';
									    	 }
								    		 
									    	 $scope.postCallbackData(returnModel);
							            };
							            
							            $scope.handleAdvanceOrderSearchResult = function(response) {
							            	
							            	var returnModel = {NextPage:{model:{}}};
									    	var output = $scope.getOutputByMashupId(response,"shared.lookup.getOrderListBySearchCriteria");
									    	 
									    	var numOfOrders = $filter('number')(output.OrderList.TotalNumberOfRecords);
									 		if(isNaN(numOfOrders)) {
									 			numOfOrders = 0;
									 		}
									 		
									 		if(numOfOrders == 1) {
									 			returnModel.NextPage.model = $scope.getOrderModel(output.OrderList.Order[0], "DETAILS");
									 			returnModel.NextPage.action = 'orderDetails';
									 		} else if(numOfOrders > 1) {
									 			returnModel.NextPage.model = {Order:this.ui.search};
									 			returnModel.NextPage.action = 'orderList';
									 		} else {
									 			returnModel.NextPage.model = {Order:this.ui.search};
									 			returnModel.NextPage.action = 'orderList';
									 			
									 		}
									 		
									    	$scope.postCallbackData(returnModel);
							            	
							            };
																				
										$scope.showErrorMessageByType = function(lookupType) {
											if(lookupType === 'ORDER') {
												iscModal.showErrorMessage(iscI18n.translate('returnLookup.MSG_InvalidOrderSearchData'));
											} else if(lookupType === 'PRODUCT') {
												if("instore-receiving" == $scope.mode) {
													iscModal.showErrorMessage(iscI18n.translate('globals.LABEL_ScanProductCode'));
												} else {
													iscModal.showErrorMessage(iscI18n.translate('returnLookup.MSG_InvalidProductSearchData'));
												}
											} else if(lookupType === 'CUSTOMER') {
												iscModal.showErrorMessage(iscI18n.translate('returnLookup.MSG_InvalidCustomerSearchData'));
											} else if(lookupType === 'SHIPMENT') {
												iscModal.showErrorMessage(iscI18n.translate('returnLookup.MSG_InvalidShipmentSearchData'));
											} else if(lookupType === 'PACKAGE') {
												iscModal.showErrorMessage(iscI18n.translate('returnLookup.MSG_InvalidPackageSearchData'));
											} else if(lookupType === 'INBOUND_ORDER') {
												iscModal.showErrorMessage(iscI18n.translate('returnLookup.MSG_InvalidInboundOrderSearchData'));
											} else {
												iscModal.showErrorMessage(iscI18n.translate('returnLookup.MSG_InvalidSearchData'));
											}
										};
										
										$scope.translateBarCodeByType = function(data,type){
											   
										   var translateBarCodeApiInput = {};
										   translateBarCodeApiInput.BarCode = {};
									   		translateBarCodeApiInput.BarCode.BarCodeData = data;
									   		
									   		if(type === 'ORDER') {
									   			iscMashup.callSimpleMashup($scope,"returnLookup_translateBarCodeForOrderNo",translateBarCodeApiInput,{}).then($scope.handleOrderBarCodeTranslation.bind($scope),angular.noop);
									   		} else if(type === 'PRODUCT') {
									   			
									   			var getCompleteItemListApiInput = {Item:{BarCode:{BarCodeData:data}}};
									   			getCompleteItemListApiInput.Item.DefaultPageSize = iscAppContext.getFromContext("defaultPageSize");
									   			if(!iscCore.isVoid($scope.ordermodel)){
								            		var customerId = $scope.ordermodel.Order.BillToID;
								            		if(!iscCore.isVoid(customerId)){
								            			getCompleteItemListApiInput.Item.CustomerInformation = {
								            				CustomerID : customerId
								            			};
								            		}
								            	}
									   			iscMashup.callSimpleMashup($scope,"returnLookup_getCompleteItemList",getCompleteItemListApiInput,{}).then($scope.handleProductBarCodeTranslation.bind($scope),angular.noop);
									   		} else if(type === 'CUSTOMER') {
									   			iscMashup.callSimpleMashup($scope,"returnLookup_translateBarCodeForCustomer",translateBarCodeApiInput,{}).then($scope.handleCustomerBarCodeTranslation.bind($scope),angular.noop);
									   		}
											   
									     };
									     
									     $scope.searchByType = function(data,type){
											   
											   var apiInput = $scope.getSearchApiInputByType(data,type);
										   		
										   		if(type === 'ORDER') {
										   			iscMashup.callSimpleMashup($scope,"returnLookup_getOrderListByOrderNo",apiInput,{}).then($scope.handleOrderSearchResult.bind($scope),angular.noop);
										   		} else if(type === 'PRODUCT') {
									   			    iscMashup.callSimpleMashup($scope,"returnLookup_searchCatalogIndex",apiInput,{}).then($scope.handleProductSearch.bind($scope),angular.noop);
										   		} else if(type === 'CUSTOMER') {
										   			/*var getCustomerListPaginatedInput = {Page:{PageNumber:1, PageSize:iscAppContext.getFromContext("masterDataPageSize"), API:{Input:{Customer:{CustomerContactList:{CustomerContact:{ComplexQuery:{Or:
										   				{Exp:[{Name:'EmailID', QryType:'FLIKE', Value:data},{Name:'DayPhone', Value:data}]}
										   			}}}}}}}};*/
										   			
									   			var getCustomerListInput = {Customer:{CustomerContactList:{CustomerContact:{DayPhone:data}}}};
													
										   		 var paginationDataObj ={scPageSize:iscAppContext.getFromContext("listApiPageSize"),
												    		scPageNumber:1,
												    		scPaginationStrategy:'NEXTPAGE'};
										   		 
										   			iscMashup.callSimplePaginatedMashup($scope,"returnLookup_getCustomerList",getCustomerListInput,paginationDataObj,"START",{}).then($scope.handleCustomerSearch.bind($scope),angular.noop);
										   		}
												   
										 };
										 
										 
										 $scope.getSearchApiInputByType = function(data,type) {
											 
											 var apiInput = {};
											 
											 if(type === 'ORDER') {
												 apiInput.Order = {};
												 apiInput.Order.OrderNo = data;
												 
										   		} else if(type === 'PRODUCT') {
										   			apiInput = {CatalogSearch:{Terms:{Term:{Value:data}}}};
										   			apiInput.CatalogSearch.PageSize = iscAppContext.getFromContext("defaultPageSize");
										   			
										   			if(!iscCore.isVoid($scope.ordermodel)){
									            		var customerId = $scope.ordermodel.Order.BillToID;
									            		if(!iscCore.isVoid(customerId)){
									            			apiInput.CatalogSearch.Item = {};
									            			apiInput.CatalogSearch.Item.CustomerInformation = {
									            				CustomerID : customerId
									            			};
									            		}
									            	}
										   			
										   		} else if(type === 'CUSTOMER') {
										   		}
											 
											 return apiInput;
										 };
										 
										 $scope.handleOrderSearchResult = function(response) {
											 
											var returnModel = {};
									     	returnModel.Error = {};
									     	returnModel.NextPage = {};
									     	
									 		var output = $scope.getOutputByMashupId(response,"returnLookup_getOrderListByOrderNo");
									 		var numOfOrders = $filter('number')(output.OrderList.TotalNumberOfRecords);
									 		if(isNaN(numOfOrders)) {
									 			numOfOrders = 0;
									 		}
									 		
									 		var orderModel = {};
								        	orderModel.Order = {};
								        	orderModel.Order.OrderNo = this.model.lookupInput.value;	
									 		
									 		if(numOfOrders == 0 || isNaN(numOfOrders)) {
									 			returnModel.NextPage.model = orderModel;
									 			returnModel.NextPage.action = 'orderList';
									 		} else if(numOfOrders == 1) {
									 			returnModel.NextPage.model = $scope.getOrderModel(output.OrderList.Order[0], "DETAILS");
									 			returnModel.NextPage.action = 'orderDetails';
									 		} else if (numOfOrders > 1) {
									 			returnModel.NextPage.model = $scope.getOrderModel(output.OrderList.Order[0], "LIST");
									 			returnModel.NextPage.action = 'orderList';
									 		}
									 		
									 		if(!iscCore.isVoid(returnModel.Error) && !iscCore.isVoid(returnModel.Error.MsgKey)) {
												iscModal.showErrorMessage(iscI18n.translate(returnModel.Error.MsgKey));
											} else {
												$scope.postCallbackData(returnModel);
											}
									 		
											 
										 };
									     
									     $scope.getOutputByMashupId = function(response, requiredMashupId) {
									    	 
									    	 var output = "";
									    	 var mashupRefs = response.MashupRefs.MashupRef;
											 for(var i=0;mashupRefs[i];i++){
												 if(mashupRefs[i].mashupId){
													  var mashupId = mashupRefs[i].mashupId;
													   /*if("returnLookup_translateBarCodeForOrderNo" == mashupId || "returnLookup_translateBarCodeForProduct" == mashupId 
															   || "returnLookup_translateBarCodeForCustomer" == mashupId || "returnLookup_getOrderListByOrderNo" == mashupId){*/
														if(mashupId == requiredMashupId){
														   output =	mashupRefs[i].Output;
														   break;
													   }
												  }
											  }
												  
											return output;
									    	 
									     };
									     $scope.handleCustomerSearch = function(response){
									    	 var returnModel = {};
									    	 returnModel.NextPage = {};
									    	 returnModel.NextPage.model = {};
									    	 var output = $scope.getOutputByMashupId(response,"returnLookup_getCustomerList");
									    	 //var output = $scope.getOutputByMashupId(response,"returnLookup_getCustomerListPaginated");
									    	 if(output.Page.Output.CustomerList.TotalNumberOfRecords === '1'){
									    		 returnModel.NextPage.model.Customer = output.Page.Output.CustomerList.Customer[0];
									    		 returnModel.NextPage.action = 'customerDetails';
									    	 }else{
									    		 output.Page.Output.CustomerList.SearchText = this.model.lookupInput.value;
										    	 returnModel.NextPage.model = output;
									    		 returnModel.NextPage.action = 'customerList';
									    	 }
								    		 
									    	 $scope.postCallbackData(returnModel);
									     },
										$scope.handleProductSearch = function(response){
									    	 var returnModel = {};
									    	 returnModel.NextPage = {};
									    	 returnModel.NextPage.model = {};
									    	 returnModel.NextPage.callAPI = false;
									    	 var output = $scope.getOutputByMashupId(response,"returnLookup_searchCatalogIndex");
								    		 
									    	 if(output.CatalogSearch.TotalHits === '1'){
									    		 returnModel.NextPage.model = output.CatalogSearch.ItemList.Item[0].ItemID;
									    		 returnModel.NextPage.action = 'addReturnItem';
									    		 returnModel.NextPage.callAPI = true;
									    	 }else{
									    		 output.CatalogSearch.SearchText = this.model.lookupInput.value;
									    		 returnModel.NextPage.model = output;
									    		 returnModel.NextPage.action = 'itemList';
									    	 }
									    	 
									    	 $scope.postCallbackData(returnModel);
									     };
									     $scope.handleProductBarCodeTranslation = function(response){
									    	 var returnModel = {};
									    	 returnModel.NextPage = {};
									    	 returnModel.NextPage.model = {};
									    	 returnModel.NextPage.callAPI = false;
									    	 var output = $scope.getOutputByMashupId(response,"returnLookup_getCompleteItemList");
									    	 if(!iscCore.isVoid(output.ItemList.Item)){
									    		 returnModel.NextPage.model = output;
									    		 returnModel.NextPage.action = 'addReturnItem';
									    	 }else if(!iscCore.isVoid(output.ItemList.CatalogSearch)){
									    		 if(output.ItemList.CatalogSearch.TotalHits === '1'){
										    		 returnModel.NextPage.model = output.ItemList.CatalogSearch.ItemList.Item[0].ItemID;
										    		 returnModel.NextPage.action = 'addReturnItem';
										    		 returnModel.NextPage.callAPI = true;
										    	 }else{
										    		 returnModel.NextPage.model.CatalogSearch = output.ItemList.CatalogSearch;
										    		 returnModel.NextPage.model.CatalogSearch.SearchText = this.model.lookupInput.value;
										    		 returnModel.NextPage.action = 'itemList';
										    	 }
									    	 }
									    	 $scope.postCallbackData(returnModel);
									     };
									     
									     $scope.handleOrderBarCodeTranslation = function(response) {
									      	
									     	var returnModel = {};
									     	returnModel.Error = {};
									     	returnModel.NextPage = {};
									     	
									 		var output = $scope.getOutputByMashupId(response,"returnLookup_translateBarCodeForOrderNo");

									 		var numOfTranslations = $filter('number')(output.BarCode.Translations.TotalNumberOfRecords);
						     				
									 		if(isNaN(numOfTranslations)) {
									 			numOfTranslations = 0;
									 		}
									 		var orderModel = {};
								        	orderModel.Order = {};
								        	orderModel.Order.OrderNo = output.BarCode.BarCodeData;	
								        	
									 		if(numOfTranslations > 1) {
									 			returnModel.NextPage.model = orderModel;
									 			returnModel.NextPage.action = 'orderList';
									 			
									 		} else if(numOfTranslations == 0 || isNaN(numOfTranslations)) {
									 			//returnModel.Error.MsgKey = "returnLookup.MSG_NoTranslationFound";
									 			returnModel.NextPage.model = $scope.getOrderModel(orderModel.Order, "LIST");
									 			returnModel.NextPage.action = 'orderList';
									 		} else if(!iscCore.isVoid(output.BarCode.Translations.Translation) && !iscCore.isVoid(output.BarCode.Translations.Translation[0]) && !iscCore.isVoid(output.BarCode.Translations.Translation[0].OrderContextualInfo)) {
										 		var orderContextInfo = output.BarCode.Translations.Translation[0].OrderContextualInfo;
										 		var numOfOrders = parseInt(orderContextInfo.MatchingOrdersCount);
										 		if(numOfOrders == 0 || isNaN(numOfOrders)) {
										 			returnModel.NextPage.model = orderModel;
										 			returnModel.NextPage.action = 'orderList';
										 		} else if(numOfOrders == 1) {
										 			returnModel.NextPage.model = $scope.getOrderModel(orderContextInfo, "DETAILS");
										 			returnModel.NextPage.action = 'orderDetails';
										 		} else if (numOfOrders > 1) {
										 			returnModel.NextPage.model = $scope.getOrderModel(orderContextInfo, "LIST");
										 			returnModel.NextPage.action = 'orderList';
										 		}
										 		} else{
										 			returnModel.NextPage.model = orderModel;
										 			returnModel.NextPage.action = 'orderList';
									 		}
									 		
									 		if(!iscCore.isVoid(returnModel.Error) && !iscCore.isVoid(returnModel.Error.MsgKey)) {
												iscModal.showErrorMessage(iscI18n.translate(returnModel.Error.MsgKey));
											} else {
												$scope.postCallbackData(returnModel);
											}
									 		
									      	
									      };
									      
									      $scope.getOrderModel = function(model, type) {
									        	
									        	var orderModel = {};
									        	orderModel.Order = {};
									        	
									        	
									        	orderModel.Order.OrderNo = model.OrderNo;
									        	
									        	if(type === "DETAILS") {
									            	/*orderModel.Order.EnterpriseCode = model.EnterpriseCode;
									            	orderModel.Order.OrderHeaderKey = model.OrderHeaderKey;
									            	orderModel.Order.DraftOrderFlag = model.DraftOrderFlag;
									            	orderModel.Order.DocumentType = model.DocumentType;*/
									        		orderModel.Order = model;
									            	orderModel.Order.AppContextInfo = {};
									            	orderModel.Order.AppContextInfo.Channel = model.EntryType;
									        	}
									        	
									        	return orderModel;
									     };

										$scope.uiScanByType = function(lookupType) {
											if (!iscCore.isVoid(this.model.lookupInput.value)) {
												if(this.mode == 'global-search' && lookupType == 'PRODUCT') {
													iscState.goToState('ordercapture',{action:'SCAN',input:this.model.lookupInput.value},{});
													$scope.uiSearchClose();
												} else {
													$scope.translateBarCodeByType(this.model.lookupInput.value,lookupType);
												}
											} else {
												$scope.showErrorMessageByType(lookupType);
											}
										};
										
										$scope.postReceiveCallbackData = function(toBeReceivedShipment) {
											var returnData = {};
											returnData.model = {Shipment:{ShipmentKey:toBeReceivedShipment.ShipmentKey,ShipmentContainerizedFlag:toBeReceivedShipment.ShipmentContainerizedFlag}};
											returnData.action = "receiveShipment";
											$scope.postCallbackData(returnData);
										};

										$scope.$watch("ui.CustomerPaymentMethod.DisplayCreditCardNo",function(newValue, oldValue){
											
											var onlyDigitsRegEx = /^\d+$/;
											
											if(!iscCore.isVoid(newValue) && (newValue.length > 4 || !onlyDigitsRegEx.test(newValue))) {       
												$scope.ui.CustomerPaymentMethod.DisplayCreditCardNo = oldValue;
											}

										});

										$scope.initShipmentSearch = function(){
											//load carrier for shipment search
											iscMashup.callSimpleMashup($scope,"shared.lookup.getScacList",{},{}).then($scope.handleGetSCACList.bind($scope),angular.noop);

											//load fulfillment methods
											this.loadShipmentFulfillmentMethods();

											//load shipment statuses
											this.loadShipmentStatus();
										};

										$scope.handleGetSCACList = function(response){
											var output = $scope.getOutputByMashupId(response,"shared.lookup.getScacList");
										 	var allScacObj = {
												"Scac": "",
												"ScacDesc": iscI18n.translate("shipmentsearch.Option_All"),
												"ScacKey": "ALLScacKey"
											};
											if (output == null || output.ScacList.Scac == null || output.ScacList.Scac.length == 0) {
												output = {
													"ScacList": {
														"Scac": [allScacObj]
													}
												};
											} else {
												output.ScacList.Scac.splice(0, 0, allScacObj);
											}
											this.model.scacList = output;
											this.ui.shipmentFilters.SCACObj = this.model.scacList.ScacList.Scac[0];
										};

										$scope.loadShipmentFulfillmentMethods = function(){
											this.ui.ShipmentFulfillment = {
												"FulfillmentTypeList": {
													"FulfillmentType": [
															{
																"FulfillmentTypeCode": "",
																"FulfillmentTypeDesc": iscI18n.translate("shipmentsearch.Option_All"),
																"FulfillmentTypeKey": "ALL"
															},
															{
																"FulfillmentTypeCode": "PICK",
																"FulfillmentTypeDesc": iscI18n.translate("shipmentsearch.LABEL_Pickup_in_store"),
																"FulfillmentTypeKey": "PICK"
															},
															{
																"FulfillmentTypeCode": "SHP",
																"FulfillmentTypeDesc": iscI18n.translate("shipmentsearch.LABEL_Ship_from_store"),
																"FulfillmentTypeKey": "SHP"
															}
														]
												}
											};
											this.ui.shipmentFilters.DeliveryMethodObj = this.ui.ShipmentFulfillment.FulfillmentTypeList.FulfillmentType[0];
										};

										$scope.loadShipmentStatus = function(){
											//load status
											var allStatusObj = {
												"StatusCode": "All",
												"StatusDesc": iscI18n.translate("shipmentsearch.Option_All"),
											};
											angular.copy(iscShipmentStatus.getShipmentStatusConfig("All"), this.ui.ShipmentStatus);
											if (this.ui.ShipmentStatus != null && this.ui.ShipmentStatus.StatusList != null && this.ui.ShipmentStatus.StatusList.Status != null && this.ui.ShipmentStatus.StatusList.Status.length > 0) {
												for (var i = 0; i < this.ui.ShipmentStatus.StatusList.Status.length; i++) {
													this.ui.ShipmentStatus.StatusList.Status[i]["StatusDesc"] = iscI18n.translate(this.ui.ShipmentStatus.StatusList.Status[i]["StatusBundleKey"]);
												}
												this.ui.ShipmentStatus.StatusList.Status.splice(0, 0, allStatusObj);
											} else {
												this.ui.ShipmentStatus = {
													"StatusList": {
														"Status": [allStatusObj]
													}
												};
											}
											this.ui.shipmentFilters.StatusObj = this.ui.ShipmentStatus.StatusList.Status[0];
										};

										$scope.uiHandleShipmentBarcodeOrSearchOutput = function(translationOutput){
											$scope.$emit("uiSearchClose","close");
											var returnModel = {};
									     	returnModel.Error = {};
									     	returnModel.NextPage = {};
											returnModel.NextPage.action = 'shipmentList';
											returnModel.NextPage.type = 'basicSearch';
											returnModel.NextPage.model = translationOutput;
											$scope.postCallbackData(returnModel);
										};

										$scope.executeShipmentSearch = function(){
										    var searchCriteria = angular.copy(this.ui.shipmentSearchCriteria, {});
				
											if(!searchCriteria.Shipment)
												searchCriteria.Shipment = {}
											searchCriteria.Shipment.DeliveryMethod = this.ui.shipmentFilters.DeliveryMethodObj.FulfillmentTypeCode;
											searchCriteria.Shipment.Status = (this.ui.shipmentFilters.StatusObj.StatusCode == 'All')?"":this.ui.shipmentFilters.StatusObj.StatusCode;
											searchCriteria.Shipment.SCAC = this.ui.shipmentFilters.SCACObj.Scac;
											
											if(searchCriteria.IncludeOtherStore) {
												searchCriteria.Shipment.ShipNode = "";
											}else{
												searchCriteria.Shipment.ShipNode = iscCore.getFromContext("storeName");
											}
											delete searchCriteria.IncludeOtherStore;

											if(searchCriteria.address){
												if(searchCriteria.isPickupRecipient){
													var shipmentLine = iscCore.getValueFromJsonPath(searchCriteria,"Shipment.ShipmentLines.ShipmentLine.OrderLine",true);
													shipmentLine.PersonInfoMarkFor = angular.copy(searchCriteria.address, {});
												}else{
													searchCriteria.Shipment.BillToAddress = angular.copy(searchCriteria.address, {});
												}
												delete searchCriteria.address
											}

											$scope.$emit("uiSearchClose","close");
											var returnModel = {};
									     	returnModel.Error = {};
									     	returnModel.NextPage = {};
											returnModel.NextPage.action = 'shipmentList';
											returnModel.NextPage.type = 'advancedSearch';
											returnModel.NextPage.model = {"Shipment":searchCriteria.Shipment};
											returnModel.NextPage.ignoreDocumentType = (searchCriteria.ExcludeTransferOrders)?'0006':'';
											$scope.postCallbackData(returnModel);
											
										};

										$scope.init();

									} ],
							templateUrl : './shared/lookup/lookup.tpl.html'
						};
					});
})(window.iscCore);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp.  2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
/**
 * @ngdoc directive
 * @name iscNote
 * @restrict E
 *
 * @description
 * Captures note text for an entity (like Order or Customer) and displays the list of all notes available for the same.
 * Note text input is restricted to a maximum of 2000 characters and a note can be marked as important. 
 * Note list displays the note text, if the note is important, if the note is system generated or user entered and the time the note was logged.
 * If the note is user entered, the user's name is mentioned. Different icons are shown for system generated and user entered notes.
 * Once the note is added successfully to the database, the parent screen should broadcast 'clearNoteFields' event to clear the current note text input values. For example, $scope.$broadcast('clearNoteFields');
 *
 * @param {Object=} noteListModel - Model passed from parent screen to display notes.If 'getNoteList' API is called to get the list of all notes for the entity, pass the model data from the 'NoteList' attribute of the model data.
 * @param {String=} noteAdditionHandler - Callback function to be called when 'Add' button is clicked to add a note. 
 * The note text and priority (if it is important or not) is transformed into a JSON object with key as 'noteAPIInput' and sent to the parent screen.
 * The parent screen will receive this JSON object in the callback handler function as a parameter. This parameter can then be used to call the mashup to log the note in database.
 * The format of the JSON object is : { Note:[ {'NoteText': 'Sample Note Text', 'Priority':'1'} ] }
 * If the note is not marked important, the JSON object will not have 'Priority' in it.
 * @param {String=} mode - This attribute is left for future use. Current screen prototype for notes has similar fields to capture and list notes for all entitites. If in future the format for notes changes for different entitites like Customer and Order say, the mode can be passed from parent screen to hide/show some notes attributes.
 * @example
 *  The HTML will have the directive specified like below:
 *	<isc-note note-addition-handler='uiPostComment(noteAPIInput)' 
 *	note-list-model='model.noteList.NoteList'></isc-note>
 */

(function(iscCore){
angular.module('isc.shared').directive('iscNote', function() {
	return {
		restrict: 'E',
		scope: {
			noteAdditionHandler:'&',
			noteListModel: '=',
			mode:"@"
		},
		
		controller:['$scope','iscI18n',function($scope,iscI18n){
			$scope.ui = {};
			$scope.ui.systemGeneratedNote = iscI18n.translate("notes.LABEL_System_Generated_Note");
			
			$scope.uiPostComment = function() {
				if(!iscCore.isVoid($scope.ui.noteText)){
					var len = encodeURIComponent($scope.ui.noteText).replace(/%[A-F\d]{2}/g, 'U').length;
					if(len <= 2000){
						var noteToPost = {};
						noteToPost.Note = [];
						noteToPost.Note[0]={};
						noteToPost.Note[0].NoteText = $scope.ui.noteText;
							
						if($scope.ui.markImportant == 'Y'){
							noteToPost.Note[0].Priority='1';
						}
						
						$scope.noteAdditionHandler({'noteAPIInput':noteToPost});
						
					} else{
						$scope.ui.showError = true;
						$scope.ui.errorKey = "notes.maxlengthError";	
					}
					
				} else{
					$scope.ui.showError = true;
					$scope.ui.errorKey = "notes.noTextError";
				}
			};
			
			$scope.$on('clearNoteFields', function () {
				$scope.ui.noteText="";
				$scope.ui.showError = false;
				$scope.ui.markImportant = 'N';
			});
		}],
		templateUrl: './shared/notes/notes.tpl.html'
	};
});
})(window.iscCore);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp.  2015, 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
/**
 * @ngdoc directive
 * @name iscMiniCart
 * @restrict E
 *
 * @description
 * # Overview
 * Displays all the orderline information that are added to cart in a popover along with an option to delete an 
 * orderline. Onclick of delete icon,cofirmation message is shown and on confirmation the orderline is deleted from
 * from the order and number of items present in order is updated.
 * Directive template has only minicart icon and on click of the icon,opens the content template.
 * Any modifications performed in mini cart ui, corresponding actions are handled in the mini cart directive only.
 *
 * @scope
 * @param {Object=} Object containning order information, used to retrieve orderline data.
 * @param {String=} Contains the total number of products present in order.
 * @param {Object=} Object minicartparam having parameters wizardmodelname(Default ordermodel), 
 * checkoutpage (Default cartdetails), carticon(Default app-glyphicons app-icon-shoppingCart_30), cartbtnlabel(Default globals.LABEL_Order_Total)
 * @example
 *  The HTML will have the directive specified like below:
 *   <div>
 *       <isc-mini-cart orderdata="model.orderDetails" ordertotalqty="ui.orderTotalQty" minicartparam="minicartparam">
 *		  </isc-mini-cart>	
 *   </div>
 */

(function(iscCore){
angular.module('isc.shared').directive('iscMiniCart', function() {
	return {
		restrict: 'E',
		scope: {
			  orderdata: '=',
			  ordertotalqty: '=',
			  minicartparam: '=?',
			  itempreview: '=',
              onCheckout:'&'    
		    },
		    
		    controller:['$scope','$document','$attrs','$timeout','iscMashup','iscWizard','iscModal','iscAppContext','iscI18n',function($scope,$document,$attrs,$timeout,iscMashup,iscWizard,iscModal,iscAppContext,iscI18n){
				$scope.orderlines = {};
				$scope.popOverTemplate = 'shared/order/mini-cart-content.tpl.html';
				$scope.previewTemplate = 'shared/order/mini-cart-item-preview.tpl.html';
				$scope.lineShownCount = 5;
				
				$scope.ui = {};
				$scope.ui.showPopover = false;
				$scope.ui.showPreview = false;
				if($scope.minicartparam === null || $scope.minicartparam === undefined || $scope.minicartparam === ''){
					$scope.minicartparam = {};
				}
				if($scope.minicartparam.carticon == null){
					$scope.minicartparam.carticon = 'app-glyphicons app-icon-shoppingCart_30';
				}
				
				if($scope.minicartparam.cartbtnlabel == null){
					$scope.minicartparam.cartbtnlabel = 'addItems.ACTION_Checkout';
				}
				
				var escapeListener = null;
				
				
				var escapeBinderFn = function(event){
				  if(event.which === 27 && !event.defaultPrevented) {
            $scope.ui.showPopover = false;
            $document.off("keydown",escapeBinderFn);
            $scope.$apply();
            //event.preventDefault();
          }
				};
				
				$scope.$on("$destroy", function () {
            $document.off("keydown",escapeBinderFn);
        });
        
        		$scope.$on('itemPreviewSpanClicked',function(event,args){
			   
			       if (args){
					  $scope.uiShowPreview();
			    	}  
					   
				 });
				
				/**
				* @scDoc method
				* @method uiOpenMiniCartPopover
				* @description onclick handler function of minicart icon.
				*              calls api to fetch all orderlines of the order and displays them.
				*/
				$scope.uiOpenMiniCartPopover = function(){
					if(!iscCore.isVoid($scope.orderdata.Order.OrderHeaderKey) && !$scope.ui.showPopover){
						var orderHeaderKey = $scope.orderdata.Order.OrderHeaderKey;
		    		 	var mashupInput = $scope.getAllOrderLinesApiInput();
		    		 	iscMashup.callSimplePaginatedMashup($scope,"addItems_miniCart_getCompleteOrderLineListForStore",
		    				 mashupInput,null,"START",{}).then(function(response){
		    				 		$scope.orderlines = response.MashupRefs.MashupRef[0].Output;
		    				 		$scope.ui.showPopover = true;
		    				 		$document.on("keydown",escapeBinderFn);
		    				 }.bind($scope),$scope.failureHandler.bind($scope));
					}
					else if($scope.ui.showPopover){
					  $scope.ui.showPopover = false;
					  $document.off("keydown",escapeBinderFn);
					}
				};
				
				$scope.uiShowPreview = function() {
					if(!iscCore.isVoid($scope.itempreview)) {
						$scope.ui.showPreview = true;
						$timeout(function() {
							$scope.ui.showPreview = false;
							 $document.off("keydown",escapeBinderFn);
							 $scope.itempreview = {};
						}, 3000);
					} else {
						$scope.ui.showPreview = false;
					}
				};
				
		    	/**
				* @scDoc method
				* @method getAllOrderLinesApiInput
				* @description method used to form api input to fetch all orderlines of the order.
				*/
		    	$scope.getAllOrderLinesApiInput = function(){
		    		var apiInput = {
		    			OrderLine: {
		    				OrderHeaderKey: $scope.orderdata.Order.OrderHeaderKey
		    			}
		    		};
		         return apiInput;
		    	};
		    	/**
				* @scDoc method
				* @method showDeleteConfirmation
				* @description onclick handler function for x icon for each orderline.
				*/
				$scope.showDeleteConfirmation = function(orderLine){
					var deleteConfMsg = "miniCart.LABEL_Delete_line";
					if($scope.orderdata.Order.DocumentType == '0003'){
						deleteConfMsg = "returns.MSG_DeleteOrderLine";
					}
					iscModal.showConfirmationMessage(deleteConfMsg).then(function(action){
								$scope.removeLine(action,orderLine);
							});
				};
		   	/**
				* @scDoc method
				* @method removeLine
				* @description onclick handler function of x icon in minicart view. Delets
				*				the orderline from order.
				* @param orderLineKey orderLineKey of orderline to be deleted.
				*/
		   	$scope.removeLine = function(action,orderLine){
					if(iscCore.isBooleanTrue(action)){
						var updateOrderInput = $scope.getUpdateOrderInput(orderLine.OrderLineKey);
	            	if(!iscCore.isVoid(updateOrderInput)){
	            		var mashupId = "addItems_miniCart_modifyFulfillmentOptions";
	            		if($scope.orderdata.Order.DocumentType = '0003'){
	            			mashupId = "miniCart_changeOrder";
	            			if(!iscCore.isVoid(orderLine.DerivedFromOrderLineKey)){
	            				updateOrderInput.Order.OrderLines[0].OrderLine.DerivedFromOrderLineKey = orderLine.DerivedFromOrderLineKey;
	            			}
						}
	            		iscMashup.callSimpleMashup($scope,mashupId,
	            			updateOrderInput,{}).then(function(response){
	            				$scope.onSuccessOfRemoveLine(response,orderLine);
	            			},
	            			$scope.failureHandler.bind($scope));
	            	}
					}
		        };
		        /**
	             * @scDoc method
	             * @method getUpdateOrderInput
	             * @description method to get the update order input along with orderline key information to be removed.
	             * @param orderLineKey orderlineKey to delete from order.
	             */
		        $scope.getUpdateOrderInput = function(orderLineKeyToRemove){
	        		var orderData = {
		        			Order:{
		        				OrderHeaderKey: $scope.orderdata.Order.OrderHeaderKey,
		        				/*DocumentType:iscAppContext.getFromContext('salesOrderDocType'),*/
		        				OrderLines:[{
		        					OrderLine:{
		        						OrderLineKey: orderLineKeyToRemove
		        					}
		        				}]
		        			}
		        		};
		            return orderData;
	            };
	            /**
	             * @scDoc method
	             * @method onSuccessOfRemoveLine
	             * @description success callback handler function after removing line from order.
	             * @param response api repsonse.
	             */
	            $scope.onSuccessOfRemoveLine = function(response,deletedOrderLine){
            		var updateOrderOutput = response.MashupRefs.MashupRef[0].Output;
	            	var length = $scope.orderlines.OrderLineList.OrderLine.length;
	            	var orderlines = $scope.orderlines.OrderLineList.OrderLine;
	            	if($scope.orderdata.Order.DocumentType == '0003' && !iscCore.isVoid(updateOrderOutput.Order.OrderLines.SalesOrderLine)) {
	            		$scope.$emit("refreshSalesOrderLine",{'data':updateOrderOutput.Order.OrderLines.SalesOrderLine});
	            		delete updateOrderOutput.Order.OrderLines["SalesOrderLine"];
	            		$scope.orderdata.Order.OrderLines = updateOrderOutput.Order.OrderLines;
	            	}
	            	if(!iscCore.isVoid(updateOrderOutput)){
	            		$scope.ordertotalqty = updateOrderOutput.Order.OrderLines.TotalNumberOfRecords;
	            		$scope.updateOrderModelInWizard();
	            		for(var i = 0; i < orderlines.length; i++){
	            			var orderline = orderlines[i];
	            			if(!iscCore.isVoid(orderline) && orderline.OrderLineKey === deletedOrderLine.OrderLineKey){
	            				orderlines.splice(i,1);
	            				break;
	            			}
	            		}
	            	}
					var alertMessage = iscI18n.translate("additems.aria_cartDeletionSuccessMessage",{quantity:$scope.ordertotalqty});
					iscModal.showA11YAlertMessage(alertMessage);
					
	            };
	            /**
	             * @scDoc method
	             * @method updateOrderModelInWizard
	             * @description method to update the no of orderlines in order, so that data is consistent
	             *              when user navigates from one page to another in wizard.
	             */
	            $scope.updateOrderModelInWizard = function(){
	            	if($scope.minicartparam.wizardmodelname === null || $scope.minicartparam.wizardmodelname === undefined || $scope.minicartparam.wizardmodelname === ''){
	            		$scope.minicartparam.wizardmodelname = 'orderModel' ;
	            	 }
	            	var orderModel = iscWizard.getWizardModel($scope.minicartparam.wizardmodelname);
	            	if(!iscCore.isVoid(orderModel)){
	            		// update ordertotalqty after deleting line so that when user navigates
	            		// from page to page, number in minicart is shown accurately.
	            		orderModel.Order.OrderLines.TotalNumberOfRecords = $scope.ordertotalqty;
	            	}
	            };
	            /**
	             * @scDoc method
	             * @method handleCheckout
	             * @description onclick handler function of checkout button in minicart view.
	             */
	            $scope.handleCheckout = function(){
                    if(!iscCore.isVoid($attrs.onCheckout)){
                        $scope.onCheckout();
                    }
                    else{
                        if($scope.minicartparam.checkoutpage === null || $scope.minicartparam.checkoutpage === undefined || $scope.minicartparam.checkoutpage === ''){
	                       $scope.minicartparam.checkoutpage ='cartDetails';
	            	      }
	            	  iscWizard.gotoCustomPage($scope.minicartparam.checkoutpage,{},{});
                    }
	            	 
	            };

		   		/**
	             * @scDoc method
	             * @method failureHandler
	             * @description ajax call failure callbackhandler function.
	             * @param response api response
	             */
		   		$scope.failureHandler = function(response){
		   		  var errorMsg = response.Errors.Error[0].ErrorDescription;
			  			var errorCode = response.Errors.Error[0].ErrorCode;
			  			console.log(errorCode);
			  			if(iscI18n.hasKey("apierror."+errorCode)){
			  				errorMsg = iscI18n.translate("apierror."+errorCode);
			  				iscModal.showErrorMessage(errorMsg,null,null);				
			  			}
			  			else{
			  				iscModal.showErrorMessage(errorMsg,null,null);
			  			}
		   		};

		   		/**
	             * @scDoc method
	             * @method getNextRecords
	             * @description callback handler function of continuous scroll, used to fetch
	             *              next set of orderlines, if present in order.
	             */
		   		$scope.getNextRecords = function(){
		   			if($scope.lineShownCount < $scope.orderlines.OrderLineList.TotalLineList){
		    		 		$scope.lineShownCount += 5;
		    			}
		   		};
		   		$scope.nextPageActionValidator = function(){
		    			return true;
		    		};
		   		
			}],
		templateUrl: './shared/order/mini-cart.tpl.html'
	};
});
})(window.iscCore);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp.  2015, 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
/**
 * @ngdoc directive
 * @name iscOrderHistoryListFilter
 * @restrict E
 *
 * @description
 * Displays Order Total along with Line Total, Charges, Taxes and Discounts.
 *
 * @scope
 * @param {Object=} order - Order Model. This should have OrderTotals.
 * @param {String=} ordertotalbundle - Order Total BundleKey
 * @param {Number=} numorderlines - Number of order lines in the order. 
 * @param {Boolean=?} shownegative - Flag to show order total amount as negative. Passed as true when showing Return Order Total 
 * @example
 *  The HTML will have the directive specified like below:
 *   <div>
 *       <isc-order-total order="model.exchangeOrder" ordertotalbundle="'returns.LABEL_Exchange_Order_total'" 
		numorderlines="model.exchangeOrderLineList.OrderLineList.TotalNumberOfRecords" ></isc-order-total>
 *   </div>
 */

(function(iscCore){
angular.module('isc.shared').directive('iscOrderHistoryListFilter', ['$window',function($window) {
	return {
		restrict: 'E',
		scope: {
				orderSearchCriteria:'=',
				onApplyFilter : '=',
				getFilterFromContext:'=',
				contextKeyName:'=?'
		    },
		    
		    link: function (scope, element, $attr, ctrl, $transclude){
	            // link parent controller's function and invoke them accordingly
	            scope.postCallbackData = function(orderListInput,selectedProductPictures){
	               var callbackHandler = scope.onApplyFilter;
	               callbackHandler(orderListInput,selectedProductPictures);
	            };
	         },

		 controller:['$scope','$rootScope','$document','iscMashup','iscAppContext','iscI18n','amSubtractFilter','amDifferenceFilter','iscDateFilter','iscResourcePermission',function($scope,$rootScope,$document,iscMashup,iscAppContext,iscI18n,amSubtractFilter,amDifferenceFilter,iscDateFilter,iscResourcePermission){
		    	
				var dateFormatForLocale = iscDateFilter.getDateFormatForLocale(iscAppContext.getFromContext('localeCode'));
				if(!dateFormatForLocale) dateFormatForLocale = 'yyyy/MM/dd';
				//if(isNaN(new Date(amSubtractFilter(new Date(),0,'days').format(dateFormatForLocale.toUpperCase())).getTime())) dateFormatForLocale = 'yyyy/MM/dd';
				var dateFormatForMomentCalculations = dateFormatForLocale.toUpperCase();
				var dateFormatFromToDates = 'MMM dd,yyyy'.toUpperCase();
				
				$scope.uiForms = {};
		    	
		    	$scope.model = {
		    			entryTypeList : {},
		    			orderStatusList:angular.copy(iscAppContext.getFromContext("orderHistoryStatusList")),
						productPictures: [{"productPictures_key":"product_pictures_recommendations","productPictures_value":iscI18n.translate('orderFilter.LABEL_Recommendations'),"checked":true},{"productPictures_key":"product_pictures_purchased","productPictures_value":iscI18n.translate('orderFilter.LABEL_Purchased'),"checked":false}]
				};
		    	
		    	$scope.ui = {
		    			accordianConfig:{
		    				oneAtATime: false,
	                        showOrderDate : false,
	                        showOrderStatus : false,
	                        showOrderChannel : false,
	                        orderDateTooltip : iscI18n.translate('orderFilter.TITLE_Expand'),
	                        orderStatusTooltip : iscI18n.translate('orderFilter.TITLE_Expand'),
	                        orderChannelTooltip : iscI18n.translate('orderFilter.TITLE_Expand'),
							productPicturesTooltip: iscI18n.translate('orderFilter.TITLE_Expand')
		    			},
		    			filterCriteria:{
		    				selectedOrderStatus : {},
	                		serachWithinStore: "N",
	                		selectedOrderChannel:[],
							selectedFromOrderDate : "",
							selectedToOrderDate : "",
							selectedFromDate : "",
							selectedToDate : "",
							selectedProductPictures: ["product_pictures_recommendations"],
							//maxDate: amSubtractFilter(new Date()).format(dateFormatForMomentCalculations),
							maxDate: amSubtractFilter(new Date()).format(dateFormatFromToDates),
							dateDisplayFormat : dateFormatForLocale,
							placeholderFormat : iscI18n.translate('orderFilter.placeholderFormat'),
							fromDateReturnFormat: "YYYY-MM-DDT00:00:00",
							toDateReturnFormat: "YYYY-MM-DDT23:59:59",
							orderDateFilterSuffix: "orderHistoryListDateFilter",
							calleeId: "orderHistoryListDateFilter"
		    			},
		    			lastAppliedFilterCriteria : {},
		    			showFilter:false,
		    			currentStore : iscAppContext.getFromContext("storeName"),
						orderDateFilterInError: false,
						orderDateFilterErrorMessge: "",
						isFilterApplied : true,
						recommendationsResourceId : "WSC000048",
						selectedProductPictureKey:"product_pictures_recommendations"
		    	};
		    	
		    	$scope.popOverTemplate = 'shared/order/order-history-list-filter.tpl.html';
		    	
		    	var escapeBinderFn = function(event){
					  if(event.which === 27 && !event.defaultPrevented) {
			            $scope.ui.showFilter = false;
			            $document.off("keydown",escapeBinderFn);
			            $scope.$apply();
					  }
					};
					
					$scope.$on("$destroy", function () {
			            $document.off("keydown",escapeBinderFn);
			        });
					
					$rootScope.$on('closeOrderHistoryListFilter',function(event,args){
						 $scope.ui.showFilter = false;
		  			 });
					
				$scope.uiShowFilterOptions = function(){
					$scope.ui.showFilter = true;
			 		$document.on("keydown",escapeBinderFn);
				};
				
		    	$scope.init = function(){
		    		if(iscCore.isVoid($scope.contextKeyName)){
		    			$scope.contextKeyName = 'orderHistoryListFilter';
		    		}
		    		$scope.setOrderStatusList(false);
		    		
		    		if($scope.getFilterFromContext){
		    			this.ui.filterCriteria = iscAppContext.getFromContext($scope.contextKeyName).filterCriteria;
		    			this.ui.isFilterApplied = true;
		    		}
		    		
		    		this.ui.lastAppliedFilterCriteria = this.ui.filterCriteria;
		    		iscMashup.callSimpleMashup($scope,"shared.order.getSalesOrderEntryTypeList",{},{}).then($scope.handleEntryTypeOutput.bind($scope),angular.noop);
		    	};
		    	
		    	$scope.handleEntryTypeOutput = function(response){
		    		var output = iscMashup.getSimpleMashupOutput(response,"shared.order.getSalesOrderEntryTypeList");
		    		this.model.entryTypeList = output;
		    		$scope.setFilterToLastApplied();
		    	};
		    	
		    	$scope.setOrderStatusList = function(isReset) {
		        	
		    		if(!iscCore.isVoid(this.model.orderStatusList) && !iscCore.isVoid(this.model.orderStatusList.StatusList) && !iscCore.isVoid(this.model.orderStatusList.StatusList.Status)
		        			 && !iscCore.isVoid(this.model.orderStatusList.StatusList.Status.length > 0)) {
		        		
		        		if(!isReset) {
		        			
		        			 var allOrderStatus = {"StatusCode": "ALL", "StatusKey":"LABEL_All", "StatusValue":"" };
		        			 this.model.orderStatusList.StatusList.Status.splice(0, 0, allOrderStatus);
		        			 
		        			 for(var i = 0;i < this.model.orderStatusList.StatusList.Status.length; i++) {
		            			var orderStatus = this.model.orderStatusList.StatusList.Status[i];
		            			orderStatus.StatusDescription = iscI18n.translate('orderFilter.'+orderStatus.StatusKey);
		            		}
		        		}
		        		
		        		this.ui.filterCriteria.selectedOrderStatus =  this.model.orderStatusList.StatusList.Status[0].StatusCode;
		        		
		         	}
		        	
		        };
		        
		        $scope.uiToggleOrderChannelSelection=function(commonCode) {
		        	
		        	if(commonCode.checked) {
		        		this.ui.filterCriteria.selectedOrderChannel.push(commonCode.CodeValue);
		        	} else if(this.ui.filterCriteria.selectedOrderChannel.indexOf(commonCode.CodeValue) > -1) {
		        		this.ui.filterCriteria.selectedOrderChannel.splice(this.ui.filterCriteria.selectedOrderChannel.indexOf(commonCode.CodeValue), 1);
		        	}
		        	
		        };
				
				$scope.uiToggleProductPicturesSelection=function(productPicturesSelection) {
					/*if(productPicturesSelection.checked) {
							
		        	} else if(this.ui.filterCriteria.selectedProductPictures.indexOf(productPicturesSelection.productPictures_key) > -1) {
		        		this.ui.filterCriteria.selectedProductPictures.splice(this.ui.filterCriteria.selectedProductPictures.indexOf(productPicturesSelection.productPictures_key), 1);
		        	}*/
					
					this.ui.filterCriteria.selectedProductPictures = [];
					this.ui.filterCriteria.selectedProductPictures.push(productPicturesSelection.productPictures_key);
				};
		        
		        /**
				* @scDoc method
				* @method uiOpenFilterPopover
				* @description onclick handler function of filter icon.
				*             
				*/
				$scope.uiOpenFilterPopover = function(){
					if(!$scope.ui.showFilter){
						$scope.ui.showFilter = true;
				 		$document.on("keydown",escapeBinderFn);
					}
					else if($scope.ui.showFilter){
					  $scope.ui.showFilter = false;
					  $document.off("keydown",escapeBinderFn);
					}
				};
		        
		        $scope.uiApplyFilter=function() {
					var isDateFilterInError = this.checkDateFilterForErrors(this.ui.filterCriteria);
					if(!isDateFilterInError) {
						this.ui.orderDateFilterInError = false;
						this.ui.showFilter = false;
						this.ui.lastAppliedFilterCriteria = angular.copy(this.ui.filterCriteria);
						var orderListInput = this.getOrderFilter();
						
						if(this.ui.isFilterApplied){
							iscAppContext.addToContext($scope.contextKeyName,{input: orderListInput, filterCriteria:this.ui.filterCriteria});
						}else{
							iscAppContext.removeFromContext($scope.contextKeyName);
						}
						
						$scope.postCallbackData(orderListInput,this.ui.filterCriteria.selectedProductPictures);
					} else {
						this.ui.orderDateFilterInError = true;
					}
		        };
				
				$scope.checkDateFilterForErrors = function(filterCriteria) {
					var isError = false;
					if($scope.uiForms.orderDateFilter.$invalid) {
						this.ui.orderDateFilterErrorMessge = iscI18n.translate('datefilter.ERROR_invalid_format');
						isError = true;
					} else {
						var fromDate = filterCriteria.selectedFromDate;
						var toDate = filterCriteria.selectedToDate;
					
						if((fromDate && !toDate) || (!fromDate && toDate)) {
							this.ui.orderDateFilterErrorMessge = iscI18n.translate('datefilter.ERROR_date_missing');
							isError = true;
						}
					
						if(fromDate && toDate) {
							if(amDifferenceFilter(toDate,fromDate) < 0) {
								this.ui.orderDateFilterErrorMessge = iscI18n.translate('datefilter.ERROR_toDate_lesser');
								isError = true;
							}
							
							if(this.ui.filterCriteria.maxDate && ((amDifferenceFilter(fromDate,this.ui.filterCriteria.maxDate) > 0) || (amDifferenceFilter(toDate,this.ui.filterCriteria.maxDate) > 0))) {
								this.ui.orderDateFilterErrorMessge = iscI18n.translate('datefilter.ERROR_date_greater_than_range');
								isError = true;
							}
							
							if(this.ui.filterCriteria.minDate && ((amDifferenceFilter(fromDate,this.ui.filterCriteria.minDate) < 0) || (amDifferenceFilter(toDate,this.ui.filterCriteria.minDate) < 0))) {
								this.ui.orderDateFilterErrorMessge = iscI18n.translate('datefilter.ERROR_date_greater_than_range');
								isError = true;
							}
						}
					}
					return isError;
				}
		        
		        $scope.getOrderFilter = function() {
		        	var orderListInput = {Order:{}};
		        	//var orderListInput = angular.copy($scope.orderSearchCriteria);
		        	//var isFilterApplied = false; //reset before calculating again
					var isFilterApplied = true;
		        	////Order Date
		        	if(!iscCore.isVoid(this.ui.filterCriteria.selectedFromOrderDate) && (!iscCore.isVoid(this.ui.filterCriteria.selectedToOrderDate))) {
		        		orderListInput.Order.FromOrderDate = this.ui.filterCriteria.selectedFromOrderDate;
		        		orderListInput.Order.ToOrderDate = this.ui.filterCriteria.selectedToOrderDate;
		        		orderListInput.Order.OrderDateQryType = "BETWEEN";
		        		isFilterApplied = true;
		        	}
		        	
		        	//Order Status
		        	if(!iscCore.isVoid(this.model.orderStatusList) && !iscCore.isVoid(this.model.orderStatusList.StatusList) && !iscCore.isVoid(this.model.orderStatusList.StatusList.Status)
		       			 && !iscCore.isVoid(this.model.orderStatusList.StatusList.Status.length > 0)) {
		       			for(var i = 0;i < this.model.orderStatusList.StatusList.Status.length; i++) {
		           			var orderStatus = this.model.orderStatusList.StatusList.Status[i];
		           			if(this.ui.filterCriteria.selectedOrderStatus == orderStatus.StatusCode) {
		           				
		           				if(!iscCore.isVoid(orderStatus.FromStatus) && !iscCore.isVoid(orderStatus.ToStatus)) {
		           					orderListInput.Order.StatusQryType="BETWEEN";
		           					orderListInput.Order.FromStatus=orderStatus.FromStatus;
		           					orderListInput.Order.ToStatus=orderStatus.ToStatus;
		           					isFilterApplied = true;
		           				} else if(!iscCore.isVoid(orderStatus.StatusValue)) {
		           					orderListInput.Order.Status = orderStatus.StatusValue;
		           					orderListInput.Order.StatusQryType="FLIKE";
		           					isFilterApplied = true;
		           				} 
		           				
		           				break;
		           			}
		           		}
		       			
		       			if(orderListInput.Order.Status && (orderListInput.Order.Status.indexOf("1000") == 0)) {
		       				orderListInput.Order.DraftOrderFlag = "Y";
		       			}
		       		
		        	} 
		        	
		        	//Entry Type
		        	if(!iscCore.isVoid(this.ui.filterCriteria.selectedOrderChannel) && !iscCore.isVoid(this.ui.filterCriteria.selectedOrderChannel.length > 0)) {
		           		
		           		for(var i = 0;i< this.ui.filterCriteria.selectedOrderChannel.length; i++) {
		           			
		           			var orderChannelCodeValue = this.ui.filterCriteria.selectedOrderChannel[i];
		           			if(!iscCore.isVoid(orderChannelCodeValue)) {
		           				
		           				if(iscCore.isVoid(orderListInput.Order.ComplexQuery)) {
		           					orderListInput.Order.ComplexQuery = {};
		           					orderListInput.Order.ComplexQuery.Or = {};
		           					orderListInput.Order.ComplexQuery.Or.Exp = [];
		           				}
		           				
		           				var exp = {};
		           				exp.Name = "EntryType";
		           				exp.QryType = "EQ";
		           				exp.Value = orderChannelCodeValue;
		           				orderListInput.Order.ComplexQuery.Or.Exp.push(exp);
		           				isFilterApplied = true;
		           			}
		           			
		           		}
		           		
		           	}
		        	
		        	//Store
		        	if("Y" == this.ui.filterCriteria.serachWithinStore) {
		        		orderListInput.Order.SellerOrganizationCode = this.ui.currentStore;
		        		isFilterApplied = true;
		        	}
		        	
		        	this.ui.isFilterApplied = isFilterApplied;
		        	return orderListInput;
		        	
		        };
		        
		        $scope.uiClearAll = function() {
		        	
		        	this.setOrderStatusList(true);
		        	this.resetEntryTypeSelection();
					this.resetProductPictureSelection();
					this.ui.filterCriteria.selectedProductPictures = [];
					this.ui.selectedProductPictureKey = "product_pictures_recommendations";
					this.ui.filterCriteria.selectedProductPictures.push(this.ui.selectedProductPictureKey);
					this.ui.filterCriteria.selectedFromDate = '';
		        	this.ui.filterCriteria.selectedToDate = '';
		        	this.ui.filterCriteria.serachWithinStore = "N";
		        	this.ui.lastAppliedFilterCriteria = this.ui.filterCriteria;
					this.ui.orderDateFilterInError = false;
		        };
		        
		        $scope.resetEntryTypeSelection= function() {
		        	
		        	if(!iscCore.isVoid(this.model.entryTypeList) && !iscCore.isVoid(this.model.entryTypeList.CommonCodeList)  && !iscCore.isVoid(this.model.entryTypeList.CommonCodeList.CommonCode)
		       			 && !iscCore.isVoid(this.model.entryTypeList.CommonCodeList.CommonCode.length > 0)) {
		        		
		        		for(var i = 0;i< this.model.entryTypeList.CommonCodeList.CommonCode.length; i++) {
		        			
		        			var entryTypeCode = this.model.entryTypeList.CommonCodeList.CommonCode[i];
		        			if(entryTypeCode.checked) {
		        				entryTypeCode.checked = false;
		        			}
		        			
		        		}
		        		
		        	}
		        	
		        	this.ui.filterCriteria.selectedOrderChannel = [];
		        };
				
				$scope.resetProductPictureSelection = function() {
					for(var i = 0;i< this.model.productPictures.length; i++) {
						var currentItem = this.model.productPictures[i];
						if(currentItem.checked) {
							currentItem.checked = false;
						}
					}
				};
		        
		        $scope.setFilterToLastApplied = function(){
		        	for(var j = 0;j< this.model.entryTypeList.CommonCodeList.CommonCode.length; j++) {
	        			var entryTypeCode = this.model.entryTypeList.CommonCodeList.CommonCode[j];
	        			entryTypeCode.checked = false;
	        			if(!iscCore.isVoid(this.ui.filterCriteria.selectedOrderChannel) && this.ui.filterCriteria.selectedOrderChannel.indexOf(entryTypeCode.CodeValue) > -1) {
	        				entryTypeCode.checked = true;
	        			}
		        	}	
				};
				
		        $scope.uiCloseFilter = function(){
		        	$scope.$emit('closeOrderHistoryListFilter',{});
		        };
				
				/*$scope.uiResourcePermissionCheck = function(productPictureSelection) {
					if(iscCore.isVoid(productPictureSelection.resourceId)) {
						return true;
					} else {
						if(iscResourcePermission.hasPermission(productPictureSelection.resourceId)) {
							return true;
						} else {
							return false;
						}
					}
					
				};*/
				
				$scope.uiResourcePermissionCheck = function() {
					if(iscResourcePermission.hasPermission($scope.ui.recommendationsResourceId)) {
						return true;
					} else {
						return false;
					}
				};
		        
		        $scope.$watch('ui.showFilter', function(){
		        	if($scope.ui.showFilter){
		        		$scope.ui.filterCriteria = angular.copy($scope.ui.lastAppliedFilterCriteria);
		        		$scope.setFilterToLastApplied();
		        	}
		        });
		        
		        $scope.$watch('ui.accordianConfig.showOrderDate', function(){
		        	if($scope.ui.accordianConfig.showOrderDate){
		        		$scope.ui.accordianConfig.orderDateTooltip = iscI18n.translate('orderFilter.TITLE_Collapse');
		        	}else{
		        		$scope.ui.accordianConfig.orderDateTooltip = iscI18n.translate('orderFilter.TITLE_Expand');
		        	}
		        });
		        
		        $scope.$watch('ui.accordianConfig.showOrderStatus', function(){
		        	if($scope.ui.accordianConfig.showOrderStatus){
		        		$scope.ui.accordianConfig.orderStatusTooltip = iscI18n.translate('orderFilter.TITLE_Collapse');
		        	}else{
		        		$scope.ui.accordianConfig.orderStatusTooltip = iscI18n.translate('orderFilter.TITLE_Expand');
		        	}
		        });
		        
		        $scope.$watch('ui.accordianConfig.showOrderChannel', function(){
		        	if($scope.ui.accordianConfig.showOrderChannel){
		        		$scope.ui.accordianConfig.orderChannelTooltip = iscI18n.translate('orderFilter.TITLE_Collapse');
		        	}else{
		        		$scope.ui.accordianConfig.orderChannelTooltip = iscI18n.translate('orderFilter.TITLE_Expand');
		        	}
		        });
		        
		    	$scope.init();
		    }],
		templateUrl: './shared/order/order-list-filter-popover.tpl.html'
	};
}]);
})(window.iscCore);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp.  2015, 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
/**
 * @ngdoc directive
 * @name iscOrderListFilter
 * @restrict E
 *
 * @description
 * Displays Order Total along with Line Total, Charges, Taxes and Discounts.
 *
 * @scope
 * @param {Object=} order - Order Model. This should have OrderTotals.
 * @param {String=} ordertotalbundle - Order Total BundleKey
 * @param {Number=} numorderlines - Number of order lines in the order. 
 * @param {Boolean=?} shownegative - Flag to show order total amount as negative. Passed as true when showing Return Order Total 
 * @example
 *  The HTML will have the directive specified like below:
 *   <div>
 *       <isc-order-total order="model.exchangeOrder" ordertotalbundle="'returns.LABEL_Exchange_Order_total'" 
		numorderlines="model.exchangeOrderLineList.OrderLineList.TotalNumberOfRecords" ></isc-order-total>
 *   </div>
 */

(function(iscCore){
angular.module('isc.shared').directive('iscOrderListFilter', ['$window',function($window) {
	return {
		restrict: 'E',
		scope: {
			 orderSearchCriteria:'=',
			  onApplyFilter : '=',
			  getFilterFromContext:'=',
			  contextKeyName:'=?'
		    },
		    
		    link: function (scope, element, $attr, ctrl, $transclude){
	            // link parent controller's function and invoke them accordingly
	            scope.postCallbackData = function(orderListInput){
	               var callbackHandler = scope.onApplyFilter;
	               callbackHandler(orderListInput);
	            };
	         },

		 controller:['$scope','$rootScope','$document','iscMashup','iscAppContext','iscI18n','amSubtractFilter','amDifferenceFilter','iscDateFilter',function($scope,$rootScope,$document,iscMashup,iscAppContext,iscI18n,amSubtractFilter,amDifferenceFilter,iscDateFilter){
		    	//console.log("isc-order-list-filter directive loaded");
				var dateFormatForLocale = iscDateFilter.getDateFormatForLocale(iscAppContext.getFromContext('localeCode'));
				if(!dateFormatForLocale) dateFormatForLocale = 'yyyy/MM/dd';
				//if(isNaN(new Date(amSubtractFilter(new Date(),0,'days').format(dateFormatForLocale.toUpperCase())).getTime())) dateFormatForLocale = 'yyyy/MM/dd';
				var dateFormatForMomentCalculations = dateFormatForLocale.toUpperCase();
				var dateFormatFromToDates = 'MMM dd,yyyy'.toUpperCase();
				
				$scope.uiForms = {};
		    	
		    	$scope.model = {
		    			entryTypeList : {},
		    			orderStatusList:angular.copy(iscAppContext.getFromContext("orderStatusList"))
				};
		    	
		    	$scope.ui = {
		    			accordianConfig:{
		    				oneAtATime: false,
	                        showOrderDate : false,
	                        showOrderStatus : false,
	                        showOrderChannel : false,
	                        orderDateTooltip : iscI18n.translate('orderFilter.TITLE_Expand'),
	                        orderStatusTooltip : iscI18n.translate('orderFilter.TITLE_Expand'),
	                        orderChannelTooltip : iscI18n.translate('orderFilter.TITLE_Expand'),
		    			},
		    			filterCriteria:{
		    				selectedOrderStatus : {},
	                		serachWithinStore: "N",
	                		selectedOrderChannel:[],
							selectedFromOrderDate : "",
							selectedToOrderDate : "",
							selectedFromDate : "",
							selectedToDate : "",
							//maxDate: amSubtractFilter(new Date()).format(dateFormatForMomentCalculations),
							maxDate: amSubtractFilter(new Date()).format(dateFormatFromToDates),
							dateDisplayFormat : dateFormatForLocale,
							placeholderFormat : iscI18n.translate('orderFilter.placeholderFormat'),
							fromDateReturnFormat: "YYYY-MM-DDT00:00:00",
							toDateReturnFormat: "YYYY-MM-DDT23:59:59",
							orderDateFilterSuffix: "orderListDateFilter",
							calleeId: "orderListDateFilter"
		    			},
		    			lastAppliedFilterCriteria : {},
		    			showFilter:false,
		    			currentStore : iscAppContext.getFromContext("storeName"),
						orderDateFilterInError: false,
						orderDateFilterErrorMessge: "",
						isFilterApplied : false
		    	};
		    	
		    	$scope.popOverTemplate = 'shared/order/order-list-filter.tpl.html';
		    	
		    	var escapeBinderFn = function(event){
					  if(event.which === 27 && !event.defaultPrevented) {
			            $scope.ui.showFilter = false;
			            $document.off("keydown",escapeBinderFn);
			            $scope.$apply();
			            //event.preventDefault();
					  }
					};
					
					$scope.$on("$destroy", function () {
			            $document.off("keydown",escapeBinderFn);
			        });
					
					$rootScope.$on('closeOrderListFilter',function(event,args){
						 $scope.ui.showFilter = false;
						 //$scope.setFilterToLastApplied();
		  			 });
					
				$scope.uiShowFilterOptions = function(){
					$scope.ui.showFilter = true;
			 		$document.on("keydown",escapeBinderFn);
				};
				
		    	$scope.init = function(){
		    		if(iscCore.isVoid($scope.contextKeyName)){
		    			$scope.contextKeyName = 'orderListFilter';
		    		}
		    		$scope.setOrderStatusList(false);
		    		
		    		if($scope.getFilterFromContext){
		    			this.ui.filterCriteria = iscAppContext.getFromContext($scope.contextKeyName).filterCriteria;
		    			this.ui.isFilterApplied = true;
		    		}
		    		
		    		this.ui.lastAppliedFilterCriteria = this.ui.filterCriteria;
		    		iscMashup.callSimpleMashup($scope,"shared.order.getSalesOrderEntryTypeList",{},{}).then($scope.handleEntryTypeOutput.bind($scope),angular.noop);
		    	};
		    	
		    	$scope.handleEntryTypeOutput = function(response){
		    		var output = iscMashup.getSimpleMashupOutput(response,"shared.order.getSalesOrderEntryTypeList");
		    		this.model.entryTypeList = output;
		    		$scope.setFilterToLastApplied();
		    	};
		    	
		    	$scope.setOrderStatusList = function(isReset) {
		        	
		    		if(!iscCore.isVoid(this.model.orderStatusList) && !iscCore.isVoid(this.model.orderStatusList.StatusList) && !iscCore.isVoid(this.model.orderStatusList.StatusList.Status)
		        			 && !iscCore.isVoid(this.model.orderStatusList.StatusList.Status.length > 0)) {
		        		
		        		if(!isReset) {
		        			
		        			 var allOrderStatus = {"StatusCode": "ALL", "StatusKey":"LABEL_All", "StatusValue":"" };
		        			 this.model.orderStatusList.StatusList.Status.splice(0, 0, allOrderStatus);
		        			 
		        			 for(var i = 0;i < this.model.orderStatusList.StatusList.Status.length; i++) {
		            			var orderStatus = this.model.orderStatusList.StatusList.Status[i];
		            			orderStatus.StatusDescription = iscI18n.translate('orderFilter.'+orderStatus.StatusKey);
		            		}
		        		}
		        		
		        		this.ui.filterCriteria.selectedOrderStatus =  this.model.orderStatusList.StatusList.Status[0].StatusCode;
		        		
		         	}
		        	
		        };
		        
		        $scope.uiToggleOrderChannelSelection=function(commonCode) {
		        	
		        	if(commonCode.checked) {
		        		this.ui.filterCriteria.selectedOrderChannel.push(commonCode.CodeValue);
		        	} else if(this.ui.filterCriteria.selectedOrderChannel.indexOf(commonCode.CodeValue) > -1) {
		        		this.ui.filterCriteria.selectedOrderChannel.splice(this.ui.filterCriteria.selectedOrderChannel.indexOf(commonCode.CodeValue), 1);
		        	}
		        	
		        };
		        
		        /**
				* @scDoc method
				* @method uiOpenFilterPopover
				* @description onclick handler function of filter icon.
				*             
				*/
				$scope.uiOpenFilterPopover = function(){
					if(!$scope.ui.showFilter){
						$scope.ui.showFilter = true;
				 		$document.on("keydown",escapeBinderFn);
					}
					else if($scope.ui.showFilter){
					  $scope.ui.showFilter = false;
					  $document.off("keydown",escapeBinderFn);
					}
				};
		        
		        $scope.uiApplyFilter=function() {
					var isDateFilterInError = this.checkDateFilterForErrors(this.ui.filterCriteria);
					if(!isDateFilterInError) {
						this.ui.orderDateFilterInError = false;
						this.ui.showFilter = false;
						this.ui.lastAppliedFilterCriteria = angular.copy(this.ui.filterCriteria);
						var orderListInput = this.getOrderFilter();
						
						if(this.ui.isFilterApplied){
							iscAppContext.addToContext($scope.contextKeyName,{input: orderListInput, filterCriteria:this.ui.filterCriteria});
						}else{
							iscAppContext.removeFromContext($scope.contextKeyName);
						}
						
						$scope.postCallbackData(orderListInput);
					} else {
						this.ui.orderDateFilterInError = true;
					}
		        };
				
				$scope.checkDateFilterForErrors = function(filterCriteria) {
					var isError = false;
					if($scope.uiForms.orderDateFilter.$invalid) {
						this.ui.orderDateFilterErrorMessge = iscI18n.translate('datefilter.ERROR_invalid_format');
						isError = true;
					} else {
						var fromDate = filterCriteria.selectedFromDate;
						var toDate = filterCriteria.selectedToDate;
					
						if((fromDate && !toDate) || (!fromDate && toDate)) {
							this.ui.orderDateFilterErrorMessge = iscI18n.translate('datefilter.ERROR_date_missing');
							isError = true;
						}
					
						if(fromDate && toDate) {
							if(amDifferenceFilter(toDate,fromDate) < 0) {
								this.ui.orderDateFilterErrorMessge = iscI18n.translate('datefilter.ERROR_toDate_lesser');
								isError = true;
							}
							
							if(this.ui.filterCriteria.maxDate && ((amDifferenceFilter(fromDate,this.ui.filterCriteria.maxDate) > 0) || (amDifferenceFilter(toDate,this.ui.filterCriteria.maxDate) > 0))) {
								this.ui.orderDateFilterErrorMessge = iscI18n.translate('datefilter.ERROR_date_greater_than_range');
								isError = true;
							}
							
							if(this.ui.filterCriteria.minDate && ((amDifferenceFilter(fromDate,this.ui.filterCriteria.minDate) < 0) || (amDifferenceFilter(toDate,this.ui.filterCriteria.minDate) < 0))) {
								this.ui.orderDateFilterErrorMessge = iscI18n.translate('datefilter.ERROR_date_greater_than_range');
								isError = true;
							}
						}
					}
					return isError;
				}
		        
		        /*getOrdersByFilterCriteria : function() {
		        	iscMashup.callMashup(this,'getOrderListByFilterCriteria',this.getOrderSearchCriteria(),{}).then(this.handleOrderFilterResult.bind(this),angular.noop);
		        },*/
		        
		        $scope.getOrderFilter = function() {
		        	//var orderListInput = {Order:{}};
		        	var orderListInput = angular.copy($scope.orderSearchCriteria);
		        	var isFilterApplied = false; //reset before calculating again
		        	////Order Date
		        	if(!iscCore.isVoid(this.ui.filterCriteria.selectedFromOrderDate) && (!iscCore.isVoid(this.ui.filterCriteria.selectedToOrderDate))) {
		        		orderListInput.Order.FromCreatets = this.ui.filterCriteria.selectedFromOrderDate;
		        		orderListInput.Order.ToCreatets = this.ui.filterCriteria.selectedToOrderDate;
		        		orderListInput.Order.CreatetsQryType = "DATERANGE";
		        		isFilterApplied = true;
		        	}
		        	
		        	//Order Status
		        	if(!iscCore.isVoid(this.model.orderStatusList) && !iscCore.isVoid(this.model.orderStatusList.StatusList) && !iscCore.isVoid(this.model.orderStatusList.StatusList.Status)
		       			 && !iscCore.isVoid(this.model.orderStatusList.StatusList.Status.length > 0)) {
		       			for(var i = 0;i < this.model.orderStatusList.StatusList.Status.length; i++) {
		           			var orderStatus = this.model.orderStatusList.StatusList.Status[i];
		           			if(this.ui.filterCriteria.selectedOrderStatus == orderStatus.StatusCode) {
		           				
		           				if(!iscCore.isVoid(orderStatus.FromStatus) && !iscCore.isVoid(orderStatus.ToStatus)) {
		           					orderListInput.Order.StatusQryType="BETWEEN";
		           					orderListInput.Order.FromStatus=orderStatus.FromStatus;
		           					orderListInput.Order.ToStatus=orderStatus.ToStatus;
		           					isFilterApplied = true;
		           				} else if(!iscCore.isVoid(orderStatus.StatusValue)) {
		           					orderListInput.Order.Status = orderStatus.StatusValue;
		           					orderListInput.Order.StatusQryType="FLIKE";
		           					isFilterApplied = true;
		           				} 
		           				
		           				break;
		           			}
		           		}
		       			
		       			if(orderListInput.Order.Status && (orderListInput.Order.Status.indexOf("1000") == 0)) {
		       				orderListInput.Order.DraftOrderFlag = "Y";
		       			}
		       		
		        	} 
		        	
		        	//Entry Type
		        	if(!iscCore.isVoid(this.ui.filterCriteria.selectedOrderChannel) && !iscCore.isVoid(this.ui.filterCriteria.selectedOrderChannel.length > 0)) {
		           		
		           		for(var i = 0;i< this.ui.filterCriteria.selectedOrderChannel.length; i++) {
		           			
		           			var orderChannelCodeValue = this.ui.filterCriteria.selectedOrderChannel[i];
		           			if(!iscCore.isVoid(orderChannelCodeValue)) {
		           				
		           				if(iscCore.isVoid(orderListInput.Order.ComplexQuery)) {
		           					orderListInput.Order.ComplexQuery = {};
		           					orderListInput.Order.ComplexQuery.Or = {};
		           					orderListInput.Order.ComplexQuery.Or.Exp = [];
		           				}
		           				
		           				var exp = {};
		           				exp.Name = "EntryType";
		           				exp.QryType = "EQ";
		           				exp.Value = orderChannelCodeValue;
		           				orderListInput.Order.ComplexQuery.Or.Exp.push(exp);
		           				isFilterApplied = true;
		           			}
		           			
		           		}
		           		
		           	}
		        	
		        	//Store
		        	if("Y" == this.ui.filterCriteria.serachWithinStore) {
		        		orderListInput.Order.SellerOrganizationCode = this.ui.currentStore;
		        		isFilterApplied = true;
		        	}
		        	
		        	this.ui.isFilterApplied = isFilterApplied;
		        	return orderListInput;
		        	
		        };
		        
		        $scope.uiClearAll = function() {
		        	
		        	this.setOrderStatusList(true);
		        	this.resetEntryTypeSelection();
					this.ui.filterCriteria.selectedFromDate = '';
		        	this.ui.filterCriteria.selectedToDate = '';
		        	this.ui.filterCriteria.serachWithinStore = "N";
		        	this.ui.lastAppliedFilterCriteria = this.ui.filterCriteria;
					this.ui.orderDateFilterInError = false;
		        };
		        
		        $scope.resetEntryTypeSelection= function() {
		        	
		        	if(!iscCore.isVoid(this.model.entryTypeList) && !iscCore.isVoid(this.model.entryTypeList.CommonCodeList)  && !iscCore.isVoid(this.model.entryTypeList.CommonCodeList.CommonCode)
		       			 && !iscCore.isVoid(this.model.entryTypeList.CommonCodeList.CommonCode.length > 0)) {
		        		
		        		for(var i = 0;i< this.model.entryTypeList.CommonCodeList.CommonCode.length; i++) {
		        			
		        			var entryTypeCode = this.model.entryTypeList.CommonCodeList.CommonCode[i];
		        			if(entryTypeCode.checked) {
		        				entryTypeCode.checked = false;
		        			}
		        			
		        		}
		        		
		        	}
		        	
		        	this.ui.filterCriteria.selectedOrderChannel = [];
		        };
		        
		        $scope.setFilterToLastApplied = function(){
		        	for(var j = 0;j< this.model.entryTypeList.CommonCodeList.CommonCode.length; j++) {
	        			var entryTypeCode = this.model.entryTypeList.CommonCodeList.CommonCode[j];
	        			entryTypeCode.checked = false;
	        			if(!iscCore.isVoid(this.ui.filterCriteria.selectedOrderChannel) && this.ui.filterCriteria.selectedOrderChannel.indexOf(entryTypeCode.CodeValue) > -1) {
	        				entryTypeCode.checked = true;
	        			}
		        	}	
				};
				
		        $scope.uiCloseFilter = function(){
		        	$scope.$emit('closeOrderListFilter',{});
		        };
		        
		        $scope.$watch('ui.showFilter', function(){
		        	if($scope.ui.showFilter){
		        		$scope.ui.filterCriteria = angular.copy($scope.ui.lastAppliedFilterCriteria);
		        		$scope.setFilterToLastApplied();
		        	}
		        });
		        
		        $scope.$watch('ui.accordianConfig.showOrderDate', function(){
		        	if($scope.ui.accordianConfig.showOrderDate){
		        		$scope.ui.accordianConfig.orderDateTooltip = iscI18n.translate('orderFilter.TITLE_Collapse');
		        	}else{
		        		$scope.ui.accordianConfig.orderDateTooltip = iscI18n.translate('orderFilter.TITLE_Expand');
		        	}
		        });
		        
		        $scope.$watch('ui.accordianConfig.showOrderStatus', function(){
		        	if($scope.ui.accordianConfig.showOrderStatus){
		        		$scope.ui.accordianConfig.orderStatusTooltip = iscI18n.translate('orderFilter.TITLE_Collapse');
		        	}else{
		        		$scope.ui.accordianConfig.orderStatusTooltip = iscI18n.translate('orderFilter.TITLE_Expand');
		        	}
		        });
		        
		        $scope.$watch('ui.accordianConfig.showOrderChannel', function(){
		        	if($scope.ui.accordianConfig.showOrderChannel){
		        		$scope.ui.accordianConfig.orderChannelTooltip = iscI18n.translate('orderFilter.TITLE_Collapse');
		        	}else{
		        		$scope.ui.accordianConfig.orderChannelTooltip = iscI18n.translate('orderFilter.TITLE_Expand');
		        	}
		        });
		        
		    	$scope.init();
		    }],
		templateUrl: './shared/order/order-list-filter-popover.tpl.html'
	};
}]);
})(window.iscCore);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
/**
 * @ngdoc directive
 * @name iscOrderTotal
 * @restrict E
 *
 * @description
 * Displays Order Total along with Line Total, Charges, Taxes and Discounts.
 *
 * @scope
 * @param {Object=} order - Order Model. This should have OrderTotals.
 * @param {String=} ordertotalbundle - Order Total BundleKey
 * @param {Number=} numorderlines - Number of order lines in the order. 
 * @param {Boolean=?} shownegative - Flag to show order total amount as negative. Passed as true when showing Return Order Total 
 * @example
 *  The HTML will have the directive specified like below:
 *   <div>
 *       <isc-order-total order="model.exchangeOrder" ordertotalbundle="'returns.LABEL_Exchange_Order_total'" 
		numorderlines="model.exchangeOrderLineList.OrderLineList.TotalNumberOfRecords" ></isc-order-total>
 *   </div>
 */

(function(iscCore){
angular.module('isc.shared').directive('iscOrderTotal', function() {
	return {
		scope: {
			  order: '=',
			  numorderlines: '=',
			  ordertotalbundle: '=',
			  shownegative:'=?'
		    },
		    controller:['$scope',function($scope){
		    	if(iscCore.isVoid($scope.shownegative)){
		    		$scope.shownegative = false;
		    	}
		    }],
		templateUrl: './shared/order/order-total.tpl.html'
	};
});
})(window.iscCore);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp. 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/




(function(iscCore){
    
    /**
     * @ngdoc directive
     * @name iscPackOrderListFilter
     * @restrict E
     *
     * @description
     * Displays pack order list filter options as a popover
     *
     * @scope
     * @param {Object=} filterOptions - Filter Options.
     * @param {String=} onApply - Callback handler function to be executed on applying the filter.
     * @example
     *  The HTML will have the directive specified like below:
     *   <div>
     *       <isc-pack-order-list-filter class="pull-right filter-icon filter-padding" filter-data="" filter-options="model.filterOptions"  on-apply="uiOnApplyFilter(filterData)"></isc-pack-order-list-filter>
     *   </div>
     */
    
    angular.module("isc.shared").directive("iscPackOrderListFilter",[function(){
        
        return {
            restrict: 'E',
            templateUrl:'./shared/pack-order-list-filter/pack-order-list-filter-popover.tpl.html',
            scope:{
                filterOptions:"=",
                filterData:"=",
                onApply:"&"
            },
            link:function($scope, $element, $attr, ctrl, $transclude){
                
            },
            controller:["$scope",'$rootScope','$document','iscI18n','iscMashup','amSubtractFilter','amDifferenceFilter','iscDateFilter','iscAppContext',function($scope,$rootScope,$document,iscI18n,iscMashup,amSubtractFilter,amDifferenceFilter,iscDateFilter,iscAppContext){
				var dateFormatForLocale = iscDateFilter.getDateFormatForLocale(iscAppContext.getFromContext('localeCode'));
				if(!dateFormatForLocale) dateFormatForLocale = 'yyyy/MM/dd';
				var dateFormatForMomentCalculations = dateFormatForLocale.toUpperCase();
                // NOTE: Unlike the order-list-filter, we do not persist the filter seletion in context here. That is to be managed by the controller that contains this. Reason for the difference is the usecase.
                $scope.model ={
                    scacList : {}
                    
                    
                        
                };
                
                $scope.ui = {
                    accordianConfig:{
                        oneAtATime: false,
                        showShipmentStatus : false,
                        showShipmentCarrier : false,
                        shipmentDateLabel : iscI18n.translate("shipmentFilter.LABEL_Shipment_date")
                    },
                    filterCriteria:{
                        selectedShipmentCarrier:"",
                        readyForPackingFlag:"",
                        inProgressFlag:""
                    },
                    isFilterApplied: false,
                    initialInput:{}
                    
                };
                
                /**
    			 * @ngdoc method
    			 * @name iscPackOrderListFilter#uiOpenFilterPopover
    			 * @description Opens the Pack Order filter in Pop-over
    			 * 
    			 */
                
                $scope.uiOpenFilterPopover = function(){
                	if ($scope.filterData != null) {
                		for (var p in $scope.filterData) {
                			$scope.ui.filterCriteria[p] = $scope.filterData[p];
                		}
                	}else {
                		$scope.uiResetToLastAppliedFilter();
                	}
					if(!$scope.ui.showFilter){
						$scope.ui.showFilter = true;
				 		$document.on("keydown",escapeBinderFn);
					}
					else if($scope.ui.showFilter){
					  $scope.ui.showFilter = false;
					  $document.off("keydown",escapeBinderFn);
					}
				};
                
                var escapeBinderFn = function(event){
                    if(event.which === 27 && !event.defaultPrevented) {
                        $scope.ui.showFilter = false;
                        $document.off("keydown",escapeBinderFn);
                        $scope.$apply();
                        //event.preventDefault();
                    }
                };
					
                $scope.$on("$destroy", function () {
                    $document.off("keydown",escapeBinderFn);
                });
				
                /**
    			 * @ngdoc method
    			 * @name iscPackOrderListFilter#uiResetToLastAppliedFilter
    			 * @description Resets the Filter with last applied filter options.
    			 */
                
                $scope.uiResetToLastAppliedFilter = function() {
		        	
                	$scope.ui.filterCriteria.readyForPackingFlag=$scope.ui.filterOptions.readyForPackingFlag;;
                	$scope.ui.filterCriteria.inProgressFlag=$scope.ui.filterOptions.inProgressFlag;
                	if(!iscCore.isVoid($scope.ui.filterOptions.selectedShipmentCarrier)){
                		$scope.ui.filterCriteria.selectedShipmentCarrier = $scope.ui.filterOptions.selectedShipmentCarrier;
                	}else{
                		$scope.ui.filterCriteria.selectedShipmentCarrier = $scope.model.scacList.ScacList.Scac[0].Scac;
                	}
                	
                	
		        };
                
		        /**
    			 * @ngdoc method
    			 * @name iscPackOrderListFilter#uiReset
    			 * @description Resets the filter options with the initial filter options when parent screen was loaded.
    			 */
		        
                $scope.uiReset = function() {
		        	
                	var tmpFilterOptions = $scope.ui.initialInput; 
                	
                	$scope.ui.filterCriteria.readyForPackingFlag=tmpFilterOptions.readyForPackingFlag;;
                	$scope.ui.filterCriteria.inProgressFlag=tmpFilterOptions.inProgressFlag;
                    $scope.ui.filterCriteria.selectedShipmentCarrier = $scope.model.scacList.ScacList.Scac[0].Scac;
                	
                	
		        };
		        
				$scope.uiShowFilterOptions = function(){
					$scope.ui.showFilter = true;
			 		$document.on("keydown",escapeBinderFn);
				};
                
                
				/**
    			 * @ngdoc method
    			 * @name iscPickOrderListFilter#uiApplyFilter
    			 * @description Invoked when Apply button is clicked in the filter pop-over
    			 * 
    			 */
				
                $scope.uiApplyFilter = function(){
                    
                        var filterData = {};
                        filterData.selectedShipmentCarrier = $scope.ui.filterCriteria.selectedShipmentCarrier;
                        filterData.readyForPackingFlag=$scope.ui.filterCriteria.readyForPackingFlag;
                        filterData.inProgressFlag=$scope.ui.filterCriteria.inProgressFlag;
                        $scope.validateIfFilterIsApplied(filterData);
                     
                };
                
                /**
    			 * @ngdoc method
    			 * @name iscPickOrderListFilter#validateIfFilterIsApplied
    			 * @description Validates if the Filter is changed and api needs to be called to refresh the list.
    			 * 
    			 */
                
                $scope.validateIfFilterIsApplied = function(filterData) {
                	     var isFilterApplied = false;
                          if(filterData.readyForPackingFlag == 'Y' || filterData.inProgressFlag =='Y'){
                       	   $scope.ui.isFilterApplied = true;
                       	   $scope.ui.showFilter = false;
                       	   $scope.ui.filterOptions = filterData;  
                       	   $scope.onApply({filterData:filterData});
                          }else{
                          	$scope.ui.isFilterApplied = false;
                          }
                };
                
                var init = function(){
                    iscMashup.callSimpleMashup($scope,"shared.shipment.shipment-list-filter.getScacList",{},{}).then(initMashupHandler,angular.noop);
                }
                
                var initMashupHandler = function(controllerData){
                    var output = iscMashup.getSimpleMashupOutput(controllerData,"shared.shipment.shipment-list-filter.getScacList");
                	// We could have more attributes, but we are catering only to 3 attributes now.
                    var anyCarrierRecord = {
                		"Scac": "",
        	            "ScacDesc": iscI18n.translate("shipmentFilter.LABEL_AnyCarrier"),
        	            "ScacKey": ""
                    };
                    if (output.ScacList != null && output.ScacList.Scac != null) {
	                    output.ScacList.Scac.splice(0, 0, anyCarrierRecord);
                    } else {
                    	console.warn("'shipment-list-filter.directive' unexpected scenario: output does not contain scanList. Defaulting to blank.");
                    	output = {
                    		"ScacList": {
                    			"Scac": [anyCarrierRecord]
                    		}
                    	};
                    }
                    $scope.model.scacList = output;
                    $scope.ui.filterCriteria.selectedShipmentCarrier = output.ScacList.Scac[0].Scac;
                    
                    initializeWithFilterData();
                    
                    if (!iscCore.isVoid($scope.shipmentDateLabel)) {
                    	$scope.ui.accordianConfig.shipmentDateLabel = $scope.shipmentDateLabel;
                    }
                }
                
                init();
                
                var initializeWithFilterData = function(){
                	
                	$scope.ui.initialInput = angular.copy($scope.filterOptions); 
                	$scope.ui.filterOptions = angular.copy($scope.filterOptions); 
                	$scope.ui.filterCriteria.readyForPackingFlag=$scope.ui.filterOptions.readyForPackingFlag;
                	$scope.ui.filterCriteria.inProgressFlag=$scope.ui.filterOptions.inProgressFlag;
                	
                   if($scope.filterData){
                       
                       
                       if(!iscCore.isVoid($scope.filterData.selectedShipmentCarrier)){
                           $scope.ui.filterCriteria.selectedShipmentCarrier = $scope.filterData.selectedShipmentCarrier;
                           
                       }
                       
                   }
                   $scope.ui.isFilterApplied = true;
                }
                
               
            }]
        }
 
    }]);
    
})(window.iscCore);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp. 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/


/**
 * @ngdoc directive
 * @name iscBarcodeScanner
 * @restrict A
 * 
 * @description Registers to the input field for listening to barcode scan evet 
 *
 * Note : This directive will not add a watcher
 * 
 * @priority 100
 * @param {string} iscBarcodeScanner Scanner type. Values PRIMARY|DEFAULT
 * 
 * 
 * @example
    <!-- to register the input field for listen to barcode scanning event
    <input isc-barcode-scanner="DEFAULT">
 */

angular.module("isc.shared").directive("iscBarcodeScanner",["iscBarcodeScanner",function(iscBarcodeSanner){
    
    var _iscBarcodeCounter = 0;
    
    return {
        priority:100,
        restrict: "A",
        require:'ngModel',
        link:function (scope, element, attrs,ngModel) {
            var barcodeId = _iscBarcodeCounter++;
            element.on('focus',function(){
                iscBarcodeSanner._onScanElementFocussed(barcodeId);
            });
            element.on('blur',function(){
                
                iscBarcodeSanner._onScanElementBlurred(barcodeId);
            });
            var type = attrs.iscBarcodeScanner;
            
            iscBarcodeSanner._addElement(barcodeId,
                {
                    type:type,
                    callFn:function(barcodeData){
                        ngModel.$setViewValue(barcodeData);
                        ngModel.$render();
                        element.triggerHandler({ type: 'keydown', which: 13 });
                        //scope.$eval(attrs.iscEnter, {$event:{}});
                    },
                    element : element
                }
                
            );
            scope.$on('$destroy', function() {
                iscBarcodeSanner._removeElement(barcodeId);
            });
            
          }
       
        
        
        
    }
}]);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp. 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/




(function(iscCore){
    
    /**
     * @ngdoc directive
     * @name iscPickOrderListFilter
     * @restrict E
     *
     * @description
     * Displays Pick Order List filter options as a popover
     *
     * @scope
     * @param {Object=} filterOptions - Filter Options.
     * @param {String=} onApply - Callback handler function to be executed on applying the filter.
     * @example
     *  The HTML will have the directive specified like below:
     *   <div>
     *     <isc-pick-order-list-filter filter-options="model.filterOptions" on-apply="uiOnApplyFilter(filterData)"></isc-pick-order-list-filter>
     *   </div>
     */
    
    angular.module("isc.shared").directive("iscPickOrderListFilter",[function(){
        
        return {
            restrict: 'E',
            templateUrl:'./shared/pick-order-list-filter/pick-order-list-filter-popover.tpl.html',
            scope:{
                filterOptions:"=",
                filterData:"=",
                onApply:"&"
            },
            link:function($scope, $element, $attr, ctrl, $transclude){
                
            },
            controller:["$scope",'$rootScope','$document','iscI18n','iscAppContext',function($scope,$rootScope,$document,iscI18n,iscAppContext){
               
                $scope.ui = {
                   
                    filterCriteria:{
                        readyForPickingFlag:'',
                        inProgressFlag:""
                    },
                    isFilterApplied: true,
                    
                    filterOptions : ''
                };
                
                /**
    			 * @ngdoc method
    			 * @name iscPickOrderListFilter#uiOpenFilterPopover
    			 * @description Opens the Pick Order filter in Pop-over
    			 * 
    			 */
                
                $scope.uiOpenFilterPopover = function(){
                	if ($scope.filterData != null) {
                		for (var p in $scope.ui.filterOptions) {
                			$scope.ui.filterCriteria[p] = $scope.ui.filterOptions[p];
                		}
                	}else {
                		$scope.uiReset();
                	}
					if(!$scope.ui.showFilter){
						$scope.ui.showFilter = true;
				 		$document.on("keydown",escapeBinderFn);
					}
					else if($scope.ui.showFilter){
					  $scope.ui.showFilter = false;
					  $document.off("keydown",escapeBinderFn);
					}
				};
                
                var escapeBinderFn = function(event){
                    if(event.which === 27 && !event.defaultPrevented) {
                        $scope.ui.showFilter = false;
                        $document.off("keydown",escapeBinderFn);
                        $scope.$apply();
                    }
                };
					
                $scope.$on("$destroy", function () {
                    $document.off("keydown",escapeBinderFn);
                });
				
                /**
    			 * @ngdoc method
    			 * @name iscPickOrderListFilter#uiReset
    			 * @description Resets the filter options with the initial filters used when the parent screen is loaded
    			 * 
    			 */
                $scope.uiReset = function() {
		        	
                	$scope.ui.filterCriteria.readyForPickingFlag=$scope.ui.filterOptions.readyForPickingFlag;;
                	$scope.ui.filterCriteria.inProgressFlag=$scope.ui.filterOptions.inProgressFlag;
                  
		        };
                
				$scope.uiShowFilterOptions = function(){
					$scope.ui.showFilter = true;
			 		$document.on("keydown",escapeBinderFn);
				};
                
				/**
    			 * @ngdoc method
    			 * @name iscPickOrderListFilter#uiApplyFilter
    			 * @description Invoked when Apply button is clicked in the filter pop-over
    			 * 
    			 */
                $scope.uiApplyFilter = function(){
                    
                        var filterData = {};
                        filterData.readyForPickingFlag=$scope.ui.filterCriteria.readyForPickingFlag;
                        filterData.inProgressFlag=$scope.ui.filterCriteria.inProgressFlag;
                        $scope.ui.filterOptions = filterData;  
                            if($scope.ui.filterCriteria.readyForPickingFlag == 'Y' || $scope.ui.filterCriteria.inProgressFlag =='Y'){
                         	   $scope.ui.isFilterApplied = true;
                         	   $scope.ui.showFilter = false;
                         	   
                         	  $scope.onApply({filterData:filterData});
                            }else{
                            	$scope.ui.isFilterApplied = false;
                            }
                };
                
                
                var init = function(){
                	
                	$scope.ui.filterOptions = angular.copy($scope.filterOptions); 
                	$scope.ui.filterCriteria.readyForPickingFlag=$scope.ui.filterOptions.readyForPickingFlag;
                	$scope.ui.filterCriteria.inProgressFlag=$scope.ui.filterOptions.inProgressFlag;
                }
                
                
                init();
            }]
        }
 
    }]);
    
})(window.iscCore);

/******************************************************************************* 
* IBM Confidential 
* OCO Source Materials 
* IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58) 
* (C) Copyright IBM Corp. 2016, 2017 All Rights Reserved. 
* The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has beendeposited with the U.S. Copyright Office. 
******************************************************************************/



/**
	 * @ngdoc directive
	 * @name iscPortletSet
	 * @restrict E
	 * 
	 * @description This directive will create portlet set and registers the portlets for the portlet set
	 * 
     * @param {number} active Portlet slide to be selected by default
	 * @priority 400
	 * 
	 * @example
    <!-- To define portlet set template html
    <isc-portlet-set active="ui.activePortlet">
      <isc-portlet template-url="myportlet1.html" controller="myportlet1controller" resource-id="myportletresource1" persona-config="{}" portlet-name="myportlet1"></isc-portlet>
      <isc-portlet template-url="myportlet2.html" controller="myportlet2controller" resource-id="myportletresource2" persona-config="{}" portlet-name="myportlet2"></isc-portlet>
    </isc-portlet-set>
		
	 */

  angular.module('isc.shared').directive('iscPortletSet', ['$rootScope', '$templateRequest', '$sce', '$interval', 'iscI18n', function($rootScope, $templateRequest, $sce, $interval, iscI18n){
  	return {
      restrict: 'E',
      transclude: true,
      priority: 400,
      scope: {
        active:"=?"
      },
      _intervalInstance: null,
      templateUrl: './shared/portlet/portlet-set.tpl.html',
  
      replace: true,
			link: function($scope){
    	  	/*
    	  		$interval is required because we are using ng-repeat to paint portlets. It will not be required if we do not use
    	  		ng-repeat, but we need it for our home page extensibility.
    	  		Due to use of ng-repeat the isc-portlet directive will actually appear in the DOM after link() is executed in a single
    	  		digest cycle after accounting for priority of directives.
    	  		Thus, we are adding $interval and delaying what we do in link(). If we revert the ng-repeat logic, we can retain or
    	  		remove the $interval as it doesn't make any difference to home page.
    	  	*/
    	  		$scope._intervalInstance = $interval((function() {
    	  			$scope.portlets = $scope.portletsConfig;
    				$scope.initialize();
                    //$scope.removeTransclude = true;
                    document.getElementById('portlet_transclude').innerHTML = "";
    	  		}).bind(this), 2, 1);
			},
			controller: ['$scope','$rootScope','iscResourcePermission','$window', 'iscPortletPvdr', 'iscAppContext', function($scope,$rootScope,iscResourcePermission,$window,iscPortletPvdr,iscAppContext){
				$scope.removeTransclude = false;
				var breakpointMobileWidth = 479,
  			breakpointTabletWidth = 1023,
					numberOfPortletsInDesktop = 3,
  				numberOfPortletsInTablet = 1,
  				numberOfPortletsInMobile = 1;
				
				$scope.portletsConfig = [];
				this.registerPortlet = function(portletConfig){
					$scope.portletsConfig.push(portletConfig);					
				}
				
				$scope.initialize = function(){
					$scope.currentWidth = 0;
  				$scope.resize(false);
  				var windowElem = angular.element($window);
  				windowElem.on("resize", $scope.resizeListener);
  				$scope.$on("$destroy", $scope.cleanupHandlers);
                $scope.$watch("active",function(newValue,oldValue){
                    console.log(newValue);
                    
                });
                //$scope.active=0
  			},
  		
  			$scope.resizeListener = function(event){
  				// On resize we want to reset the new portlet spec persona portlet info: HOME_PAGE_ACTIVE_PORTLET_PERSONA_SCOPE, HOME_PAGE_MINIPORTLET_INDEX_PERSONA_SCOPE.
  				iscAppContext.addToContext("HOME_PAGE_ACTIVE_PORTLET_PERSONA_SCOPE", 0);
  				iscAppContext.addToContext("HOME_PAGE_MINIPORTLET_INDEX_PERSONA_SCOPE", -1);
  				$scope.resize(true);
  			},
  		
  		$scope.cleanupHandlers = function(){
  			var windowElem = angular.element($window);
  			windowElem.off("resize", $scope.resizeListener);
  			if ($scope._intervalInstance != null) {
				$interval.cancel($scope._intervalInstance);
			}
  		},
  				
  				$scope.checkForPermissionsAndReturnValidPortletArray = function(maxPortletsNeeded, considerOldSpec, indexesToSkipForMoreTasksObj) {
  					// maxPortletsNeeded null means, unlimited.
  					// portlets must not be old spec (personaConfig == null) by default unless flag is passed.
  					var portlets = [];
  					var indexesToSkip = indexesToSkipForMoreTasksObj;
  					var i = 1;
  					while (i < $scope.portlets.length) {
  						if (maxPortletsNeeded != null && portlets.length >= maxPortletsNeeded) {
  							break;
  						}
  						if (indexesToSkip[i] === true) {
  							i++;
  							continue;
  						}
  						var currentPortlet = $scope.portlets[i];
  						if ((currentPortlet.personaConfig == null || currentPortlet.personaConfig === "null" || currentPortlet.personaConfig === "") && considerOldSpec === false) {
  							// we have portlets grouped. oldSpec will be always after newspec.
  							break;
  						}
  						if (iscResourcePermission.hasPermissionToOneOfTheResources(currentPortlet.resourceId)) {
  							portlets[portlets.length] = currentPortlet;
							indexesToSkip[i] = true;
						}
						i++;
					}
  					return {
  						"portlets": portlets,
  						"indexesToSkipForMoreTasksObj": indexesToSkip
  					};
  				}
				
				$scope.prepareCarouselData = function(portletsToShowInOneSlide){
						var portlets = [];
						var moretasksPortlet = $scope.portlets[0];
						// means we are in persona mode. No need to check as caller has checked.
						if (moretasksPortlet != null && moretasksPortlet.portletName === "moretasksportlet") {
							var maxLegalPortletCount = 2;//mobile we keep 2.
							if (portletsToShowInOneSlide === numberOfPortletsInDesktop) {
								maxLegalPortletCount = numberOfPortletsInDesktop;
							}
							// getting portlets to show before 'moretasksportlet'.
							var indexesToSkipForMoreTasksObj = {};
							var retObj = $scope.checkForPermissionsAndReturnValidPortletArray((maxLegalPortletCount - 1), false, indexesToSkipForMoreTasksObj);
							portlets = retObj.portlets;
							// TODO: What if portlets.length == 1 or 0? What will you do? ALso, is this scenario even valid?
							indexesToSkipForMoreTasksObj = retObj.indexesToSkipForMoreTasksObj;
							// getting portlets to show in 'moretasksportlet'.
							retObj = $scope.checkForPermissionsAndReturnValidPortletArray(null, false, indexesToSkipForMoreTasksObj);
							var childPortlets = retObj.portlets;
							indexesToSkipForMoreTasksObj = retObj.indexesToSkipForMoreTasksObj;
							if (childPortlets.length === 1) {
								portlets = portlets.concat(childPortlets);
							} else if (childPortlets.length > 1) {
								moretasksPortlet.childPortletsArray = childPortlets;
								portlets.push(moretasksPortlet);
								iscPortletPvdr.setConfigForMoreTasksPortlet(moretasksPortlet);
							}
							// getting portlets to show after 'moretasksportlet'.
							retObj = $scope.checkForPermissionsAndReturnValidPortletArray(null, true, indexesToSkipForMoreTasksObj);
							if (retObj.portlets.length > 0) {
								console.error(iscI18n.translate("portlet.MESSAGE_OldSpecPortlets"));
								portlets = portlets.concat(retObj.portlets);
							}
						} else {
							var i = 0;
							var len = $scope.portlets.length;
							while (i < len) {
								if (iscResourcePermission.hasPermissionToOneOfTheResources($scope.portlets[i].resourceId)) {
									portlets[portlets.length] = $scope.portlets[i];
								}
								i++;
							}
						}
						var finalLength = portlets.length;
						$scope.carousel = {};
						$scope.carousel.data = [];
						$scope.carousel.dataToSlide = 0;
						var lastSlidePortletCount = finalLength % portletsToShowInOneSlide;
						$scope.carousel.hasSlides = (finalLength / portletsToShowInOneSlide) > 1;
						var j=0;
						while(j < finalLength){
							$scope.carousel.data[$scope.carousel.dataToSlide] = {}
							$scope.carousel.data[$scope.carousel.dataToSlide].portlet = [];
							var sliceInitPosition = j;
							if(j>0 && j + portletsToShowInOneSlide > finalLength){
								sliceInitPosition -= (portletsToShowInOneSlide-lastSlidePortletCount);
							}
							$scope.carousel.data[$scope.carousel.dataToSlide].portlet =
								portlets.slice(sliceInitPosition, sliceInitPosition + portletsToShowInOneSlide);
							//var portletCount = 12 / $scope.carousel.data[$scope.carousel.dataToSlide].portlet.length;
							var portletCount = $scope.carousel.data[$scope.carousel.dataToSlide].portlet.length;
							$scope.carousel.data[$scope.carousel.dataToSlide].cssClass = "portlet-tile-" + portletCount;
                            $scope.carousel.data[$scope.carousel.dataToSlide].id = $scope.carousel.dataToSlide;
							$scope.carousel.dataToSlide++;
							j += portletsToShowInOneSlide;
						}
				};
		
				$scope.resize=function(needDigest) {
					var width = $window.innerWidth || $window.outerWidth;
				if(width!==$scope.currentWidth){
					$scope.currentWidth = width;
					if(width > breakpointTabletWidth) {
						 // desktop
						 this.prepareCarouselData(numberOfPortletsInDesktop);
					} else if(width <= breakpointTabletWidth && width > breakpointMobileWidth) {
						 // tablet
						 this.prepareCarouselData(numberOfPortletsInTablet);
					} else {
						 // mobile
						 this.prepareCarouselData(numberOfPortletsInMobile);
					}
					if(needDigest){
						$scope.$digest();
					}
				}
			}
				
				
			}]		
		
		}
	}]);
/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp.  2015, 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/


/**
 * @ngdoc directive
 * @name iscPortlet
 * @restrict E
 * 
 * @description This directive will create portlet pages and registers the portlets for the portlet set
 * This directive should be used only inside iscPortletSet directive
 * 
 * 
 * @priority 600 
 * @param {string} templateUrl Template url of the page view
 * @param {string} controller Controller name of the page view
 * @param {string} resourceId Resource Id of the portlet
 * @param {object} personaConfig persona config json for the portlet
 * @param {string} portletName attribute that corresponds to the name with which portlet is registered
 * 
 * @example
    <!-- To define portlet template html
    <isc-portlet-set>
      <isc-portlet template-url="myportlet1.html" controller="myportlet1controller" resource-id="myportletresource1" persona-config="{}" portlet-name="myportlet1"></isc-portlet>
      <isc-portlet template-url="myportlet2.html" controller="myportlet2controller" resource-id="myportletresource2" persona-config="{}" portlet-name="myportlet2"></isc-portlet>
    </isc-portlet-set>
    
 */




angular.module('isc.shared').directive('iscPortlet', function(){

  return {
    require: "^iscPortletSet",
    restrict: 'E',
    priority: 600,
    scope: {      
	    templateUrl:'@',
	    controller:'@',
		resourceId:'@',
		personaConfig:'@',
		portletName:'@'
    },
    replace: false,
    link: {
        pre : function(scope, element, attrs, portletSetController){

          var porlet = {        
            templateUrl:scope.templateUrl,
            controller:scope.controller,
            resourceId:scope.resourceId,
            personaConfig:scope.personaConfig,
            portletName:scope.portletName
            
          };
          portletSetController.registerPortlet(porlet);
        }
    }
  };

});

/******************************************************************************* 
 * IBM Confidential 
 * OCO Source Materials 
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp. 2017 All Rights Reserved. 
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has beendeposited with the U.S. Copyright Office. 
 ******************************************************************************/



/**
 * @ngdoc directive
 * @name iscProductListCarousel
 * @restrict E
 * 
 * @description This directive will display product list as carousel 
 * 
 * @priority 600
 * @param {object} productListData Object containing list of products to show in carousel
 * @param {function} onProductSelection Method/expression to be executed on click on product list item
 * @param {Boolean} showItemDescriptionLink Flag to indicate whether to show product description as link or label
 * @param {String} displayType Display type can be CAROUSEL or LIST
 * 
 * @example
<!-- To define portlet set template html
<isc-product-list-carousel product-list-data="model.itemList" on-product-selection="uiShowProductDetails(itemDetailsInput)" display-type="CAROUSEL">
</isc-product-list-carousel>

 */

angular.module('isc.shared').directive('iscProductListCarousel', ['$rootScope', '$templateRequest', '$sce', function ($rootScope, $templateRequest, $sce) {
    return {
        restrict: 'E', 
        transclude: false,
        scope: {
            productListData:"=",
            onProductSelection:"&", 
            showItemDescriptionLink : "=?",
            displayType:"@",
            onPaginationSelection:"&",
            plineshownCount:"=",
            noOflinestoDecrement:"=",
            elementWithScrollbar:"@",
            carouselContext:"@"
            	
        },
        
        templateUrl: './shared/product/product-list-carousel.tpl.html',

        replace: true,
        link: function ($scope) {
            $scope.initialize();
        }
        , controller: ['$scope', '$rootScope', 'iscResourcePermission', '$window','$element','$timeout', function ($scope, $rootScope, iscResourcePermission, $window,$element,$timeout) {
            $scope.removeTransclude = false;
            var breakpointMobileWidth = 479
                , breakpointTabletWidth = 768
                , breakpointDesktopWidth = 1023
                , numberOfProductsInDesktop = 3
                , numberOfProductsInTablet = 2
                , numberOfProductsInMobile = 1;

           
			
            if($scope.showItemDescriptionLink == undefined){
     			$scope.showItemDescriptionLink = true;
     		}else if($scope.showItemDescriptionLink === false){
     			$scope.showItemDescriptionLink = false;
     		}
            
            $scope.initialize = function () {
                    $scope.currentWidth = 0;
                    $scope.ui ={};
                    $scope.ui.productsToShowInOneSlide = 0;
                    $scope.ui.elementWithScrollbar='';
                    if(iscCore.isVoid($scope.elementWithScrollbar)){
                    	   $scope.ui.elementWithScrollbar = 'parent';
                    }else{
                    	 $scope.ui.elementWithScrollbar = $scope.elementWithScrollbar;
                    }
                    
                    $timeout(function(){
                    	$scope.resize(false);
                    },10);
                    
                    var windowElem = angular.element($window);
                    windowElem.on("resize", $scope.resizeListener);
                    $scope.$on("$destroy", $scope.cleanupHandlers);
                    $scope.$watch("active", function (newValue, oldValue) {
                        console.log(newValue);

                    });
                    
                     
                    $scope.active = 0
                    
                    /*if($scope.showItemDescriptionLink){
                    	$scope.showItemDescriptionLink = true;
                    }else{
                    	$scope.showItemDescriptionLink = false;
                    }*/
                   
                },

                $scope.resizeListener = function (event) {
                    $scope.resize(true);
                },

                $scope.cleanupHandlers = function () {
                    var windowElem = angular.element($window);
                    windowElem.off("resize", $scope.resizeListener);
                },

                $scope.$watch('ui.active', function(newValue, oldValue){
                	var paginationInput ={
                            Page:{
                            	   'displayType':$scope.displayType,
                            	   'newValue':newValue,
                            	   'oldValue':oldValue
                            }
                            
                        }
                	$scope.onPaginationSelection({paginationInput:paginationInput});
		        });
                
                
                $scope.$watch('productListData.ItemList.Item', function(){
                	  if(!iscCore.isVoid($scope.carousel)){
                		  if($scope.displayType=='CAROUSEL'){
                			  $scope.updateCarouselData($scope.ui.productsToShowInOneSlide);
                		  }
                	  }
		           },true);
                
                $scope.uiGetProductListNext = function(){
                	var paginationInput ={
                			Page:{
                				   'displayType':$scope.displayType,
                         	   'noOfProductsShown':$scope.plineshownCount
                         	   
                         }
                	};
                	
                	$scope.onPaginationSelection({paginationInput:paginationInput});
                	
                };
                
                $scope.uiPLineScrollActionValidator = function(){
                  return true;
	            },
	            
                $scope.updateCarouselData = function (productsToShowInOneSlide) {
                  	
                	    var carouselDataindex = $scope.ui.active;
                    var pageNoToShow = $scope.ui.active + 1 ;
                    var initindex = (pageNoToShow * productsToShowInOneSlide) - (productsToShowInOneSlide) ;
                    var endindex = (pageNoToShow * productsToShowInOneSlide) - 1 ;
                    var len = $scope.productListData.ItemList.TotalItemList;
                    
                    if((len-1) < endindex){
                      	endindex = len - 1;
                    }
                    $scope.carousel.data[carouselDataindex].Item = $scope.productListData.ItemList.Item.slice(initindex, initindex + productsToShowInOneSlide);
                };
                
                $scope.prepareCarouselData = function (productsToShowInOneSlide) {
                    
                    if(!iscCore.isVoid($scope.productListData)){
                        var i = 0;
                        var portlets = [];
                        var len = $scope.productListData.ItemList.TotalItemList;
                        var finalLength = len;
                        $scope.carousel = {};
                        $scope.carousel.data = [];
                        $scope.carousel.dataToSlide = 0;
                        var lastSlideProductCount = finalLength % productsToShowInOneSlide;
                        $scope.carousel.hasSlides = (finalLength / productsToShowInOneSlide) > 1;
                        var j = 0;
                        while (j < finalLength) {
                            $scope.carousel.data[$scope.carousel.dataToSlide] = {}
                            $scope.carousel.data[$scope.carousel.dataToSlide].Item = [];
                            var sliceInitPosition = j;
                            //if (j > 0 && j + productsToShowInOneSlide > finalLength) {
                            //    sliceInitPosition -= (productsToShowInOneSlide - lastSlideProductCount);
                            //}
                            $scope.carousel.data[$scope.carousel.dataToSlide].Item =
                                $scope.productListData.ItemList.Item.slice(sliceInitPosition, sliceInitPosition + productsToShowInOneSlide);
                            var itemCount = $scope.carousel.data[$scope.carousel.dataToSlide].Item.length;
                            $scope.carousel.data[$scope.carousel.dataToSlide].cssClass = "product-tile-" + itemCount;
                            $scope.carousel.data[$scope.carousel.dataToSlide].id = $scope.carousel.dataToSlide;
                            $scope.carousel.dataToSlide++;
                            j += productsToShowInOneSlide;
                        }
                    }
                };

            $scope.resize = function (needDigest) {
                var width = $element[0].clientWidth;//$window.innerWidth || $window.outerWidth;
                if (width !== $scope.currentWidth ) {
                    $scope.currentWidth = width;
                    /*if (width > breakpointTabletWidth) {
                        // desktop
                        this.prepareCarouselData(numberOfProductsInDesktop);
                    } else if (width <= breakpointTabletWidth && width > breakpointMobileWidth) {
                        // tablet
                        this.prepareCarouselData(numberOfProductsInTablet);
                    } else {
                        // mobile
                        this.prepareCarouselData(numberOfProductsInMobile);
                    }*/
                    var noOfProductsToShow = width/280;
                    
                    if(noOfProductsToShow < 1){
                    	noOfProductsToShow = 1;
                    }
                    
                    //noOfProductsToShow = 2;
                    
                    $scope.ui.productsToShowInOneSlide = noOfProductsToShow>3?3:noOfProductsToShow;
                    
                    if(!iscCore.isVoid($scope.noOflinestoDecrement) && $scope.noOflinestoDecrement > 0 && noOfProductsToShow > 1){
                    	 $scope.ui.productsToShowInOneSlide = $scope.ui.productsToShowInOneSlide - $scope.noOflinestoDecrement;
                    }
                    
                    
                    $scope.ui.productsToShowInOneSlide = Math.floor($scope.ui.productsToShowInOneSlide);
                    this.prepareCarouselData($scope.ui.productsToShowInOneSlide);
                    if (needDigest) {
                        $scope.$digest();
                    }
                }
            }

            $scope.uiOpenItemDetails = function(item){
                var itemDetailsInput ={
                    Item:{
                        ItemID:item.ItemID,
                        UnitOfMeasure:item.UnitOfMeasure,
                        ItemKey:item.ItemKey,
                    }
                    
                }
                if($scope.carouselContext){
                	itemDetailsInput.Item.CarouselContext = $scope.carouselContext;
                	
                /*if($scope.carouselContext == 'OpenCarts'){
                		
                		itemDetailsInput.Item.CartDeiveryMethod=item.CartDeiveryMethod;
                		itemDetailsInput.Item.OrderedQuantity=item.OrderedQuantity;
                		itemDetailsInput.Item.ProductClass=item.ProductClass;
                		itemDetailsInput.Item.ShipNode=item.ShipNode;
                		
                	}*/
                	
                }
                $scope.onProductSelection({itemDetailsInput:itemDetailsInput});
            }

			}]

    }
	}]);
/******************************************************************************* 
* IBM Confidential 
* OCO Source Materials 
* IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58) 
* (C) Copyright IBM Corp. 2016, 2017 All Rights Reserved. 
* The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has beendeposited with the U.S. Copyright Office. 
******************************************************************************/


/**
	 * @ngdoc directive
	 * @name iscQuantityEdit
	 * @restrict E
	 * 
	 * @description This directive will create quantity edit options
	 * 
     * @param {number|string} originalQuantity Original quantity
     * @param {boolean} showUOM Flag to indicate whether to show UOM or not
     * @param {string} displayUom UOM value
     * @param {Function} onUpdate Function to be called on update
     * @param {number|string} minQuantity Minimum quantity to be validated for. Default is 0
     * @param {number|string} maxQuantity Maximum quantity to be validated for.
     * @param {model} ngModel Model to be used to get|set value
	 * 
	 * 
	 * @example
    <!-- To define quantity edit
        <isc-quantity-edit original-quantity="shipmentLine.CustomerPickedQuantity" 
            ng-model="shipmentLine.EditableCustomerPickedQuantity" 
            min-quantity="0" max-quantity="shipmentLine.Quantity" 
            display-uom="shipmentLine.OrderLine.ItemDetails | iscUOM" 
            on-update="uiUpdateShipmentLineQuantity(shipmentLine,shipmentLine.EditableCustomerPickedQuantity)">
        </isc-quantity-edit>
                    
	 */
angular.module('isc.shared').directive('iscQuantityEdit', ['$timeout','$filter',function($timeout,$filter) {
  return {
    restrict: 'E',
    replace:true,
    require:'^ngModel',
    scope: {
		//quantity: '=quantity',
        originalQuantity : '=originalQuantity',
		showUOM:'=showUOM',
        displayUom:'=displayUom',
		onUpdate:'&onUpdate',
		minQuantity:'=minQuantity',
		maxQuantity:'=maxQuantity',
    },
	
	controller:["$scope","$locale","iscI18n",function($scope,$locale,iscI18n){	
		
        $scope.ui={};
        $scope.ui.showQtyUpdate = false;
		
		
		$scope.formatQty = function(){
			$scope.ui.quantity = $filter('number')($scope.ui.quantity, 2);
		}
		
        $scope.uiDecreaseQty = function() {
            
            if(($scope.ui.quantityNumber - 1 ) >= ($scope.minQuantity===undefined?0:$scope.minQuantity)){
				$scope.ui.quantityNumber--;
				updateQuantity();
			}
            else if(!iscCore.isVoid($scope.minQuantity) && $scope.minQuantity>0 && ($scope.ui.quantityNumber - 1 ) < $scope.minQuantity){
                iscModal.showErrorMessage(iscI18n.translate('quantity.MESSAGE_MinQuantityError'));
            }
            else if(($scope.ui.quantity - 1 ) < 0){
                iscModal.showErrorMessage(iscI18n.translate('quantity.MESSAGE_NegativeQuantityError'));
            }
        };

        $scope.uiIncreaseQty=function() {

            if(($scope.maxQuantity===undefined) || ($scope.ui.quantityNumber + 1 ) <= $scope.maxQuantity){
				$scope.ui.quantityNumber++;
				updateQuantity();
			}
            else if(!iscCore.isVoid($scope.maxQuantity) && $scope.maxQuantity>0 && ($scope.ui.quantityNumber + 1 ) > $scope.manQuantity){
                iscModal.showErrorMessage(iscI18n.translate('quantity.MESSAGE_MaxQuantityError'));
            }
            
        };
                
        var updateQuantity = function(){
            $scope.ui.quantity = "" + $scope.ui.quantityNumber;
            
            $timeout(function(){

                if($scope.onUpdate){
                    $scope.onUpdate();	
                }					
            },5);
        };        
        
        $scope.uiOnQuantityFieldFocus  =function (qtyField) {
								
            var formats = "";

            if($scope.quantityForm.$valid)
                formats = $locale.NUMBER_FORMATS;

            var oldQuantity = $scope.ui.quantity;
            if(oldQuantity){
                oldQuantity=oldQuantity.replace(formats.GROUP_SEP, '');		
            }
            if($scope.ui.showQtyUpdate !== true){
                qtyField.oldQty = oldQuantity;
            }

        },
            
        /**
             *@description This is a custom validator method for received quantity field
             *@param {Object} validationResponseObj - default data type validation response JSON object
             *@param {Object} angularErrorObject - datatype validation error JSON object
             *@param {Object} modelValue - quantity field value
             *@param {Object} viewValue - quantity value inputted in textfield
             */
            $scope.uiValidateQuantity = function(validationResponseObj, angularErrorObject, modelValue, viewValue){

                /* check if the DataType Validation is successful */

                if(!iscCore.isVoid(angularErrorObject) && angularErrorObject.iscDatatypeValidator)
                    return validationResponseObj;
                else
                var isQty_a_Number = !isNaN(viewValue);
                if(!iscCore.isBooleanTrue(isQty_a_Number) || iscCore.isVoid(viewValue)){
                    validationResponseObj.booleanResponse = !isNaN(viewValue) && !iscCore.isVoid(viewValue);
                        validationResponseObj.errorMesssage = iscI18n.translate("globals.ERROR_invalid_input");
                } else{

                    var maxQuantity = Number($scope.maxQuantity);
                    if(Number(modelValue) > maxQuantity) {
                        validationResponseObj.booleanResponse = false;
                        validationResponseObj.errorMesssage = iscI18n.translate("quantity.MESSAGE_MaxQuantityError");
                    }
                }
                return validationResponseObj;
            },

           /**
             *@description Shows/hides Update button for quantity field based on the validity of the edited quantity.
             *@param {Object} qtyField - quantity field as JSON object. 
             */

            $scope.uiShowUpdateButton = function(qtyField){

                var formats = $locale.NUMBER_FORMATS;
                var newQuantity = $scope.ui.quantity;
                if(newQuantity)
                    newQuantity=newQuantity.replace(formats.GROUP_SEP, '');
                if((!iscCore.isVoid(newQuantity)) && qtyField.oldQty !== newQuantity && Number($scope.originalQuantity) != Number($scope.ui.quantity))
                    $scope.ui.showQtyUpdate =true;
                else
                    $scope.ui.showQtyUpdate =false;

            },


            $scope.uiHideUpdateButton = function(){
                $scope.ui.showQtyUpdate =false;
            },


            $scope.uiValidateQuantityAndUpdate = function(qtyField){


                var that = this;
                var formats = $locale.NUMBER_FORMATS;
                var newQuantity = $scope.ui.quantity;
                if(newQuantity) {
                    newQuantity=newQuantity.replace(formats.GROUP_SEP, '');
                }
                if(!iscCore.isVoid(newQuantity) && qtyField.oldQty !== newQuantity && Number($scope.ui.quantity) != Number($scope.originalQuantity)){

                    qtyField.oldQty = newQuantity ;

                    if (typeof newQuantity == "string") {
                        newQuantity = parseInt(newQuantity,10);
                    }
                    updateQuantity();
                    
                }

            },

        
		init= function(){
			/*if(!$scope.quantity || $scope.quantity===undefined){
				$scope.quantity=0;
			}
			
			$scope.ui.quantity = $scope.quantity;
			
			*/
		}
		
		init();
	}],
	
	link:function($scope, $element, $attrs,ngModelCtrl){		
		/*$scope.$watch('quantity', function (val){
			$scope.ui.quantity = $scope.quantity?$scope.quantity:"0.00";
			$scope.ui.quantity = parseInt($scope.quantity);			
			$scope.formatQty();
		});*/
		$scope.$watch('ui.quantity',function(val){
			//$scope.ui.quantity = $filter('number')($scope.ui.quantity, 2);
            ngModelCtrl.$setViewValue(Number(val));
            
            $scope.ui.quantityNumber = Number(val);
		});
		$scope.$watch('minQuantity', function (val){			
			$scope.minQuantity = parseInt($scope.minQuantity);
		});
		$scope.$watch('maxQuantity', function (val){
			$scope.maxQuantity = parseInt($scope.maxQuantity);
		});
        $scope.$watch('originalQuantity', function (val){
            if(val === $scope.ui.quantity){
                $scope.ui.showQtyUpdate = false;
            }
            
        });
        
        ngModelCtrl.$render = function(){
            $scope.ui.quantity = ngModelCtrl.$viewValue?ngModelCtrl.$viewValue:"0";
        };
        
        
	},
    templateUrl: './shared/quantity/quantity-edit.tpl.html'
  };
}]);
/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
angular.module('isc.shared').directive('iscRelatedTask',['iscTask','iscState', function(iscRelatedTask,iscState){
	
	return {
		restrict: 'E',
		transclude: true,
		replace:true,
		scope: {
		  entityModel : '=',
		  entity:"@",
		  mode:"@",
		  successHandler:'&',
		  errorHandler:'&',
		  preTasksHandler:'&'
		},
		templateUrl: function($element,$attr){
			var templateUrl = "./shared/related-task/related-task.tpl.html";
			if(!iscCore.isVoid($attr.mode)){
				templateUrl = "./shared/related-task/related-task-"+$attr.mode+".tpl.html";
			}
			return templateUrl;
		},
		controller: ["$scope",function($scope){
			
			$scope.$watch("entityModel",function(newValue,oldValue){ 
			if($scope.mode==="ALL"){
				$scope.relatedTasks = iscRelatedTask.getAllTasks($scope.entity,$scope.entityModel);
			}
			else if($scope.mode==="ALL_MENU"){
				$scope.relatedTasks = iscRelatedTask.getAllTasks($scope.entity,$scope.entityModel);
			}			
			else if($scope.mode==="NEXT"){
				$scope.relatedTasks = iscRelatedTask.getNextTasks($scope.entity,$scope.entityModel);
			}
			else if($scope.mode==="NEXT_MENU"){
				$scope.relatedTasks = iscRelatedTask.getNextTasks($scope.entity,$scope.entityModel);
			}			
			else if($scope.mode==="PRIMARY"){
				$scope.relatedTasks = iscRelatedTask.getPrimaryTasks($scope.entity,$scope.entityModel);
			}
			else{
				$scope.relatedTasks = [];
			}
			
			});
			
			$scope.getTaskURL = function(task){
				if(task.isDisabled){
					return "";
				}
				else{
					return task.actionUrl;
				}
				
			}
			
			$scope.uiDoTask = function(task){
					if(task.isDisabled){
						return;
					}
					else{
						
						var proceed = $scope.preTasksHandler({'taskId':task.taskId});
						
						if(proceed) {
							proceed.then(function(flag) {
								angular.element(document).injector().invoke(task.action,null,null).then(
									function(taskSuccessData){
										$scope.successHandler({'taskOutput':taskSuccessData});
									},
									function(taskErrorData){
										$scope.errorHandler({'taskOutput':taskErrorData});
									});
							}); 
						} else {
							angular.element(document).injector().invoke(task.action,null,null).then(
								function(taskSuccessData){
									$scope.successHandler({'taskOutput':taskSuccessData});
								},
								function(taskErrorData){
									$scope.errorHandler({'taskOutput':taskErrorData});
								});
						}
												
						return;
					}
			}
		}]
	}
}]);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
/**
 * @ngdoc directive
 * @name iscResourceId
 * @restrict A
 * 
 * @description Hides or shows DOM content if the logged in user has permission for the resource id
 * 
 * Note : This directive will not add a watcher
 * 
 * @priority 600
 * @param {string} iscResourceId The resource id to be checked
 * 
 * 
 * @example
    <!-- to show content only if user has permission to resource WSCSYS00001 or WSC00001
    <div isc-resource-id="WSCSYS00001|WSC00001">
      Content goes here
    </div>
 */



angular.module('isc.shared').directive('iscResourceId',['iscResourcePermission',function(iscResourcePermission){
	return{
		restrict: 'A',
		link: function ($scope, $element, $attr, ctrl, $transclude){			
			var resources = $attr.iscResourceId.split('|');
			var hasPermission = false;
			for(var i =0;i<resources.length;i++){
				if(iscResourcePermission.hasPermission(resources[i])){
					hasPermission=true;
					break;
				}				
			}
			if(!hasPermission){
				$element.addClass("permission-denied");
			}			
		}	
	}	
}]);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
angular.module('isc.shared').directive('iscUiState',iscUiStateFactory);
iscUiStateFactory.$inject = ['iscState'];

/**
 * @ngdoc directive
 * @name iscUiState
 *
 * @requires iscState
 *
 * @restrict A
 *
 * @description
 * Binds an HTML element to a state. If the state has a path configured,
 * sets the HTML element ready for the transition to that path. 
 * Clicking the element will prevent the default click behaviour and trigger a state transition with optional parameters. 
 *
 * User can specify parameters and options in this directive to pass to the iscState.goToState method
 * using the 'isc-ui-state-params' and 'isc-ui-state-options' attributes. These two attributes accept JSON objects.
 * goToState method in the iscState service is what completes the state transition.
 *
 * @example
 * <a href="#" isc-ui-state="ordersummary" isc-ui-state-params="{Key1: 'Value1',Key2: 'Value2'}" 
 *
 *	isc-ui-state-options="{'reload':true}">Order Summary</a>
 *
 * @param {Object} isc-ui-state-params Parameters to pass to iscState.goToState method
 * @param {Object} isc-ui-state-options Options to pass to iscState.goToState method
 */

function iscUiStateFactory(iscState) {
	return {
		restrict: 'A',
        scope:{
            iscUiStateParams :'=',
            iscUiStateOptions : '='
        },
		link: function(scope,element,attrs) {
			
			/* Prevent the default click of a link and call updateState method */
			element.bind("click", function(e) {
				var button = e.which || e.button;
				if ( !(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || element.attr('target')) ) {
					/* Check to see if the current state is same as the state that the user is trying to change. 
					Example: Same link is clicked again. In this scenario, do not call the goToState method*/
					if(iscState.currentStateInfo && iscState.currentStateInfo.state !== attrs.iscUiState) {
						iscState.goToState(attrs.iscUiState, scope.iscUiStateParams, scope.iscUiStateOptions);
					} else {
						//TO DO: Currently logging into console. Need to change	
						console.warn("Already in : "+ attrs.iscUiState+"! No need to change state!");
					}
					e.preventDefault();
				}
			});
		}
	};
}
	

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
angular.module('isc.shared').directive('iscView',iscViewFactory);
angular.module('isc.shared').directive('iscView',iscViewFillContentFactory);

/**
 * @ngdoc directive
 * @name iscView
 * @restrict EA
 *
 * @description
 * # Overview
 * Complements the iscState service by
 * including the rendered template of the current state into the main layout file.
 * Every time the current state changes, the included template changes with it according to the
 * configuration of the iscState service.
 *
 * @requires iscState
 * @requires $anchorScroll
 * @requires $animate
 *
 * @animations
 * enter - animation is used to bring new content into the browser.
 * leave - animation is used to animate existing content away.
 *
 * The enter and leave animation occur concurrently.
 *
 * @scope
 * @priority 400
 * @param {String=} onload Expression to evaluate whenever the view updates.
 *
 * @param {String=} autoscroll Whether 'iscView' should call $anchorScroll
 *                  to scroll the viewport after the view is updated.
 *
 *                  - If the attribute is not set, disable scrolling.
 *                  - If the attribute is set without value, enable scrolling.
 *                  - Otherwise enable scrolling only if the 'autoscroll' attribute value evaluated
 *                    as an expression yields a truthy value.
 * @example
 *	<div isc-view class="view-animate"></div>
 *
 *	<!-- The controller configures the states to display for the 'isc-view' directive -->
 *	angular.module('store')
	.config(['iscStateProvider',function(iscStateProvider) {
    iscStateProvider
      .state('ordersummary', {
        templateUrl: './store/views/order/order-summary/order-summary.tpl.html',
        controller: 'store.views.order.order-summary.order-summary',
        controllerAs: 'OrderSummaryCtrl'
      })
	  .otherwise('/home');
	}]);
 *	
 */


/**
 * @ngdoc event
 * @name iscView#$viewContentLoaded
 * @eventType Emit on the current iscView scope
 * @description
 * Emitted every time the iscView content is reloaded.
 */

iscViewFactory.$inject = ['iscState','$anchorScroll', '$animate'];
function iscViewFactory(iscState, $anchorScroll, $animate) {
	return {
		restrict: 'EA',
		priority: 400,
		terminal: true,
		transclude: 'element',
		link: function(scope, $element, attr, ctrl, $transclude) {
			var currentScope,currentElement,autoScrollExp = attr.autoscroll,previousLeaveAnimation;
			var onloadExp = attr.onload || '';
			scope.$on('$stateChangeSuccess', update);
			update();
			
			/**
			 * @ngdoc method
			 * @name iscView#update
			 *
			 * @description
			 * Triggered when the page loads for the first time or when '$stateChangeSuccess' event is triggered 
			 * on the $rootScope. Creates a new scope for the template to be loaded, associates a controller to the view and loads it.
			 */
			function update() {
				var currentState = iscState.currentState;
				if(currentState) {
					var currentTemplate = currentState.template;
					var newController = iscState.currentState.stateInfo.controller;
					
					if (angular.isDefined(currentTemplate)){
						var newScope = scope.$new();
						var clone = $transclude(newScope, function(clone) {
							$animate.enter(clone, null, currentElement || $element).then(function onNgViewEnter() {
								if (angular.isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
								  $anchorScroll();
								}
							});
							cleanupLastView();
						});
						currentElement = clone;
						currentScope = newScope;
						currentScope.$emit('$viewContentLoaded');
						currentScope.$eval(onloadExp);
					} else {
						cleanupLastView();
					}
				}
			}
			
			/**
			 * @ngdoc method
			 * @name iscView#cleanupLastView
			 *
			 * @description
			 * Destroys the previously loaded view along with any animation present. The current scope object is
			 * also destroyed so that the new view can have its own scope. 
			 */
			function cleanupLastView() {
			  if (previousLeaveAnimation) {
				$animate.cancel(previousLeaveAnimation);
				previousLeaveAnimation = null;
			  }

			  if (currentScope) {
				currentScope.$destroy();
				currentScope = null;
			  }
			  if (currentElement) {
				previousLeaveAnimation = $animate.leave(currentElement);
				previousLeaveAnimation.then(function() {
				  previousLeaveAnimation = null;
				});
				currentElement = null;
			  }
			}
		}
	};
}

/** This directive is called during the $transclude call of the first 'iscView' directive.
 *	It will replace and compile the content of the HTML element with the current loaded template.
 *	We need this directive so that the element content is already filled when
 *	the link function of another directive on the same element as iscView
 *	is called.
 */
iscViewFillContentFactory.$inject = ['$compile', '$controller', 'iscState'];
function iscViewFillContentFactory($compile, $controller,iscState) {
  return {
	restrict: 'EA',
    priority: -400,
	link: function(scope, $element) {
		var currentState = iscState.currentState;
		var currentTemplate = currentState.template;
        var newController = currentState.stateInfo.controller;
		var newControllerAs = currentState.stateInfo.controllerAs;
		var locals = {};
		
		$element.html(currentTemplate);

		var link = $compile($element.contents());

		if (newController) {
			locals.$scope = scope;
			locals.$template = currentTemplate;
			var templateController = $controller(newController, locals);
			if(newControllerAs) {
				scope[newControllerAs] = templateController;
			}
			$element.data('$ngControllerController', templateController);
			$element.children().data('$ngControllerController', templateController);
		}
		link(scope);
    }
  };
}

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/


/**
 * @ngdoc directive
 * @name iscRule
 * @restrict A
 * 
 * @description Hides or shows DOM content if the rule is enabled or disabled
 * 
 * Note : This directive will not add a watcher
 * 
 * @priority 600
 * @param {string} iscRule The rule id to be checked
 * 
 * 
 * @example
    <!-- to show content only if user has permission to resource WSCSYS00001
    <div isc-rule="WCC_SHOW_IMAGES">
      Content goes here
    </div>
 */
angular.module('isc.shared').directive('iscRule',['iscRule',function(iscRule){
	return{
		restrict: 'A',
		link: function ($scope, $element, $attr, ctrl, $transclude){			
			var rules = $attr.iscRule.split('|');
			var ruleCustomClass = $attr.iscRuleCustomClass;
			var isRuleEnabled = false;
			for(var i =0;i<rules.length;i++){
				if(iscRule.isRuleEnabled(rules[i])){
					isRuleEnabled=true;
					break;
				}				
			}
			if(!isRuleEnabled){
				$element.addClass("noitem-image-rule");
				if(ruleCustomClass) {
					$element.addClass(ruleCustomClass);
				}
			}
			
		}	
	}
}]);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/

 /**
 * @ngdoc directive
 * @name iscDynamicHeight
 * @restrict A
 * @element ANY
 * @scope
 * @requires $window
 *
 * @description
 * 	'iscDynamicHeight' is a directive that provides dynamic height to an element depnding on height of some other element (dependent element).
 * 	It is expected that this directive will be applied to a child component and the dependent element will be a sibling of this element.
 * 
 * @param {Object} iscDynamicHeight A configuration object that accepts the following properties. 
 * 		- **dependentElementId** - '{string}' - id of dependent element
 * 		- **isDependentDynamic** - '{boolean}' - whether height of dependent element changes dynamically 
 *      - **fullHeight** - '{string}' - full height of the continer with which dependent element's height will be subtracted to get current element's height
 * 		
 * 
 * @example
 * 	The HTML will have the directive specified like below:
 * 		<div ng-controller="MainCtrl as mainCtrl">
 *			<div ng-if="mainCtrl.showData" class="elementWithScrollBar">
 *				<div class="repeating-panel-holder" id="changeStore_currentStore">
 *				<div isc-dynamic-height="{'dependentElementId': 'changeStore_currentStore', 'isDependentDynamic':true, 'fullHeight':'100%'}"></div>
 *			</div>
 *		</div>
 */


(function(sharedModule){
	'use strict';
	
	sharedModule.directive("iscDynamicHeight", ["$window","$timeout",function ($window, $timeout) {
		
		return {
			restrict: "A",
			scope: {},
			link: function($scope, $element, $attr) {

				var _DynamicHeightConfigObj = null,
					_DynamicHeightDependentElement = null,
					_DynamicHeightAnchorElement = null,
					_angularWindowElement = null,
					_isDependentDynamic = false,
					_fullHeight,
					_maxHeight,
					timer;

				var _computeDynamicHeight = function(event, handleResize){
					if(timer)
						$timeout.cancel(timer);
					timer = $timeout(_setHeightAsync, 0);
				};
				var _setHeightAsync = function(){
					if(_fullHeight)
						_DynamicHeightAnchorElement[0].style.height = "calc("+_fullHeight+" - "+ _DynamicHeightDependentElement[0].offsetHeight + "px)";
					else if(_maxHeight)
						_DynamicHeightAnchorElement[0].style.maxHeight = "calc("+_maxHeight+" - "+ _DynamicHeightDependentElement[0].offsetHeight + "px)";
				};
				var _handleDynamicHeightWindowResize = function(event) {
					_computeDynamicHeight(event, true);
				};
				var _handleDynamicHeightOrientationChange = function(event) {
					_computeDynamicHeight(event);
				};
				var _addRequiredDynamicHeightListners = function($scope) {
					_angularWindowElement.on("resize", _handleDynamicHeightWindowResize);
					_angularWindowElement.on("orientationchange", _handleDynamicHeightOrientationChange);
					_DynamicHeightDependentElement.ready(function(){_setHeightAsync();});
					if(_isDependentDynamic){
						$scope.$watch(
							function() { 
								return _DynamicHeightDependentElement[0].offsetHeight; 
							},
							function(newValue, oldValue) {
								if (newValue !== oldValue) {
									_computeDynamicHeight();
								}
							}
						);
					}
				};
				var _cleanupHandlers = function() {
					_angularWindowElement.off("resize", _handleDynamicHeightWindowResize);
					_angularWindowElement.off("orientationchange", _handleDynamicHeightOrientationChange);
				};
				
				_DynamicHeightConfigObj = $scope.$eval($attr.iscDynamicHeight) || {};
				_isDependentDynamic = _DynamicHeightConfigObj.isDependentDynamic;
				if(_DynamicHeightConfigObj.fullHeight)_fullHeight=_DynamicHeightConfigObj.fullHeight;
				if(_DynamicHeightConfigObj.maxHeight)_maxHeight=_DynamicHeightConfigObj.maxHeight;

				_DynamicHeightAnchorElement = $element;
				var _dependentElementId = _DynamicHeightConfigObj.dependentElementId;
				
				if(_dependentElementId){
					_DynamicHeightDependentElement = angular.element(document.getElementById(_dependentElementId));
					
					_angularWindowElement = angular.element($window);

					if(_DynamicHeightAnchorElement && _DynamicHeightDependentElement){
						_addRequiredDynamicHeightListners($scope);
						$scope.$on("$destroy", _cleanupHandlers);
					}
				}
			}
		}
	}]);
})(angular.module("isc.shared"));

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/

 /**
 * @ngdoc directive
 * @name iscStickyScroll
 * @restrict A
 * @element ANY
 * @scope
 * @requires $window
 *
 * @description
 * 	'iscStickyScroll' is a directive that provides sticky scrolling feature wherein a section withing a scrolling container gets stuck at top while scrolling down.
 * 	It is expected that this directive will be applied to a child component inside scrolling container and the child component (sticking anchor element) will have 
 *  a single child (sticking element) having same height as the parent anchor component. Also it is expected that the scroll is not on window but on some child
 *  element inside DOM.
 * 
 * @param {Object} iscStickyScroll A configuration object that accepts the following properties. 
 * 		- **elementWithScrollbar** - '{string}' - Allowed values are 'parent', 'parent.parent' and
 * 			further chain of 'parent' elements. It should always correspond to the element on which 
 *          we will have the scroll bar because we will listen to scroll on it.
 * 		
 * 
 * @example
 * 	The HTML will have the directive specified like below:
 * 		<div ng-controller="MainCtrl as mainCtrl">
 *			<div ng-if="mainCtrl.showData" class="elementWithScrollBar">
 *				<div class="sticky-container-panel" isc-sticky-scroll="{'elementWithScrollbar': 'parent'}>
 *					<div class="element-which-will-stick-at-top">
 *					</div>
 *				</div>
 *			</div>
 *		</div>
 */


(function(sharedModule){
	'use strict';
	
	sharedModule.directive("iscStickyScroll", ["$window",iscStickyScrollFn]);
	
	function iscStickyScrollFn($window) {
		var _handelScroll = function(event, handleResize){
			var stickyAnchorBoundingRect = _stickyAnchorElement[0].getBoundingClientRect(),
				scrollElemBoundingRect = _scrollingElement[0].getBoundingClientRect();
			if (stickyAnchorBoundingRect.top <= scrollElemBoundingRect.top) {
				if(!_stickyElement.hasClass('sticky-panel')){
					_stickyAnchorElement[0].style.height = _stickyAnchorElement[0].offsetHeight+"px";
					_stickyElement[0].style.width = _stickyAnchorElement[0].offsetWidth+"px";
					_stickyElement.addClass('sticky-panel');
					_stickyElement[0].style.top = scrollElemBoundingRect.top+"px";
				}else if(handleResize){
					_stickyElement[0].style.width = _stickyAnchorElement[0].offsetWidth+"px";
					_stickyElement[0].style.top = _scrollingElement[0].getBoundingClientRect().top+"px";
				}
			} else {
				if(_stickyElement.hasClass('sticky-panel')){
					_stickyAnchorElement[0].style.height = "auto";
					_stickyElement[0].style.width = "auto";
					_stickyElement.removeClass('sticky-panel');
					_stickyElement[0].style.top = 0+"px";
				}
			}
		};
		var _handleStickyScroll = function(event){
			_handelScroll(event);
		};
		var _handleStickyWindowResize = function(event) {
			_handelScroll(event, true);
		};
		var _handleStickyOrientationChange = function(event) {
			_handelScroll(event);
		};
		var _addRequiredStickyListners = function() {
			_scrollingElement.on("scroll", _handleStickyScroll);
			_angularWindowElement.on("resize", _handleStickyWindowResize);
			_angularWindowElement.on("orientationchange", _handleStickyOrientationChange);
		};
		var _cleanupHandlers = function() {
			_scrollingElement.off("scroll", _handleStickyScroll);
			_angularWindowElement.off("resize", _handleStickyWindowResize);
			_angularWindowElement.off("orientationchange", _handleStickyOrientationChange);
		};
		var _stickyConfigObj = null,
			_stickyElement = null,
			_stickyAnchorElement = null,
			_scrollingElement = null,
			_angularWindowElement = null;
		
		return {
			restrict: "A",
			scope: true,
			link: function($scope, $element, $attr) {
				_stickyConfigObj = $scope.$eval($attr.iscStickyScroll) || {};
				_stickyAnchorElement = $element;
				_stickyElement = angular.element($element.children()[0]);
				//_stickyAnchorElement[0].style.height = _stickyElement.offsetHeight+"px";
				
				_scrollingElement = $element;
				_angularWindowElement = angular.element($window);

				if(_stickyAnchorElement && _stickyElement){
					if (_stickyConfigObj.elementWithScrollbar && _stickyConfigObj.elementWithScrollbar.indexOf("parent") !== -1) {
						var pathArray = _stickyConfigObj.elementWithScrollbar.split(".");
						for (var i = 0; i < pathArray.length; i++) {
							_scrollingElement = _scrollingElement.parent();
						}
					}
					_addRequiredStickyListners();
					$scope.$on("$destroy", _cleanupHandlers);
				}
			}
		}
	}
})(angular.module("isc.shared"));

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp. 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/

angular.module("isc.shared").directive("iscSemicircleChartD3", iscSemicircleChartD3Fn);

iscSemicircleChartD3Fn.$inject = ["$window", "iscMedia"];

function iscSemicircleChartD3Fn($window, iscMedia) {

	return {
		restrict: 'E',
		replace: true,
		require: '^ngModel',
		scope: {
			"id": "@",
			"iconClass": "@",
			"chartTheme": "@",
			"chartThickness": "@",
			"chartNoDataThickness": "@",
			//"currentValue": "=",	//we get this from ng-model. Just take that ant update the ui.currentValue
			"maxValue": "="
			//"chartData": "=",// not designed for right now. May be future.
			//"innerRadius": "@",
			//"outerRadius": "@",
			//"textAreaText": "@",
			//"regionPadding": "@",
			//"ignoreResizeAndOrientationchange": "@"
		},
		controller: ["$scope", "iscMedia", function($scope, iscMedia) {
			// When we have polling on home page, we will need to add watch for maxValue as well. For now, it is easy with one watch.
			$scope.$watch("ui.currentValue", function(newCurrentValue) {
				if (newCurrentValue != null && newCurrentValue != "") {
					$scope.ui.isCurrentValSet = true;
					initSetup();
				}
			}.bind(this));
			
			$scope.$watch("maxValue", function(newMaxValue) {
				if (newMaxValue != null && newMaxValue != "") {
					$scope.ui.isMaxValSet = true;
					initSetup();
				}
			}.bind(this));
			
			$scope.ui = {
				"currentValue": null,
				"isCurrentValSet": false,
				"isMaxValSet": false,
				"svgElemId": $scope.id + "_svgElem"
			};
			
			var initSetup = function() {
				if ($scope.ui.isCurrentValSet && $scope.ui.isMaxValSet) {
					init();
				}
			};
			
			var init = function() {
				var thickness = isNaN(parseFloat($scope.chartThickness)) ? 8 : parseFloat($scope.chartThickness);
				var CONST_chartNoDataThickness = isNaN(parseFloat($scope.chartNoDataThickness)) ? 2 : parseFloat($scope.chartNoDataThickness);
				// In case of mobile, we will make chart thickness less - 75% of original.
				if (iscMedia.isMediaEnabled("lte-480")) {
					thickness = (0.75 * thickness);
				}
				
				var singleSide_chartOverhangDueToThickness = (thickness - CONST_chartNoDataThickness)/2;
				var currElem = $("#" + $scope.id);
				var currentValue = parseFloat($scope.ui.currentValue);
				var maxValue = parseFloat($scope.maxValue);
				if (currElem != null && currElem.length > 0) {
					var width = currElem.outerWidth();
					var height = currElem.outerHeight();
					//Firefox has a bug when you use auto margin the way we used: "50px auto" and do "currElem.outerWidth(true);". It only computes leftMargin and adds it. Using leftMargin directly resolve it. Might not have worked had we given "left-margin: auto".
					//var widthWithMargin = currElem.outerWidth(true);
					var leftMargin = isNaN(parseFloat(currElem.css("marginLeft"))) ? 0 : parseFloat(currElem.css("marginLeft"));
					
					var marginHor = leftMargin - singleSide_chartOverhangDueToThickness;
					var marginVert = -(thickness - singleSide_chartOverhangDueToThickness);
					
					var or = width/2 + singleSide_chartOverhangDueToThickness,
						ir = width/2 - (CONST_chartNoDataThickness + singleSide_chartOverhangDueToThickness),
						oneDegreeInRad = Math.PI/180;
						
					var generatedArc = d3.arc()
						.innerRadius(ir)
						.outerRadius(or)
						.startAngle(function(d){return (-90*oneDegreeInRad);})
						.endAngle(function(d){return ((-90 + 180*(d.value/maxValue))*oneDegreeInRad);});
					
					var svgElem_selector = "#" + $scope.ui.svgElemId,
						svgElem_styleStr = "position: absolute; left: 0px; margin: " + marginVert + "px " + marginHor + "px;",
						svgElem = d3.select(svgElem_selector),
						svgElem_g = d3.select(svgElem_selector + " " + "g");
					
					svgElem.attr("width", (2*or)).attr("height", (or));
					svgElem.attr("style", svgElem_styleStr);
					if (svgElem_g._groups[0][0] == null) {
						svgElem_g = svgElem.append("g");
					}
					svgElem_g = svgElem_g.attr("transform", "translate(" + or + "," + or + ")");
		
					var path = svgElem_g.selectAll("path")
						.data([{
							"value": currentValue,
							"clazz": $scope.chartTheme
						}])
						.enter().append("path")
						.attr("class", function (d, i) {
							var clazz = d["clazz"] + " semicircle-chart";
							return clazz;
						})
						//.attr("fill", function(d) {return d.color;})
						.transition()
						.duration(1000)
						.attr("d", generatedArc);
						
				}
			}
		}],
		templateUrl: "./shared/semicircle-chart-d3/semicircle-chart-d3.tpl.html",
		link: function($scope, $element, $attrs, ngModelCtrl) {
			/*
			var id = scope["id"];
				//chartData = scope["chartData"],
			_fn_prepareAndUpdateConfigJson(id, element, scope);
			
			scope.$on("event_createChart", _fn_handleChartCreation);
			
			if (scope["ignoreResizeAndOrientationchange"] !== "true") {
				var _angularWindowElement = angular.element($window);
				// TODO: How to trigger only once? - some browsers will trigger both events according to docs. Need to verify.
				_angularWindowElement.on("resize", function() {_fn_handleChartCreation(null, {"id": id, "isDomEventHandler": true})});
				_angularWindowElement.on("orientationchange", function() {_fn_handleChartCreation(null, {"id": id, "isDomEventHandler": true})});
			}
			*/
			if (ngModelCtrl != null) {
				$scope.$watch("ui.currentValue", function(val) {
					ngModelCtrl.$setViewValue(val);
				});
				ngModelCtrl.$render = function() {
					if (!iscCore.isVoid(ngModelCtrl.$viewValue)) {
						$scope.ui.currentValue = ngModelCtrl.$viewValue;
					}
				}
			}
		}
	};

}
/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp. 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/




(function(iscCore){
    
    /**
     * @ngdoc directive
     * @name iscShipmentListFilter
     * @restrict E
     *
     * @description
     * Displays Shipment filter options as a popover
     *
     * @scope
     * @param {Object=} filterOptions - Filter Options.
     * @param {Object=} filterData - Filter data used for pre selection.
     * @param {String=} shipmentDateLabel - Label for Shipment Date. 
     * @param {String=} onApply - Callback handler function to be executed on applying the filter.
     * @example
     *  The HTML will have the directive specified like below:
     *   <div>
     *       <isc-shipment-list-filter filter-options="ui.filterOptions" filter-data="ui.filterData" shipment-date-label="ui.shipmentLabelValue" 
                on-apply="ui.applyShipmentFilter(filterData);" ></isc-shipment-list-filter>
     *   </div>
     */
    
    angular.module("isc.shared").directive("iscShipmentListFilter",[function(){
        
        return {
            restrict: 'E',
            templateUrl:'./shared/shipment/shipment-list-filter-popover.tpl.html',
            scope:{
                filterOptions:"=",
                filterData:"=",
                shipmentDateLabel:"=",
                onApply:"&"
            },
            link:function($scope, $element, $attr, ctrl, $transclude){
                
            },
            controller:["$scope",'$rootScope','$document','iscI18n','iscMashup','amSubtractFilter','amDifferenceFilter','iscDateFilter','iscAppContext',function($scope,$rootScope,$document,iscI18n,iscMashup,amSubtractFilter,amDifferenceFilter,iscDateFilter,iscAppContext){
				var dateFormatForLocale = iscDateFilter.getDateFormatForLocale(iscAppContext.getFromContext('localeCode'));
				if(!dateFormatForLocale) dateFormatForLocale = 'yyyy/MM/dd';
				//if(isNaN(new Date(amSubtractFilter(new Date(),0,'days').format(dateFormatForLocale.toUpperCase())).getTime())) dateFormatForLocale = 'yyyy/MM/dd';
				var dateFormatForMomentCalculations = dateFormatForLocale.toUpperCase();
				var dateFormatFromToDates = 'MMM dd,yyyy'.toUpperCase();
                // NOTE: Unlike the order-list-filter, we do not persist the filter seletion in context here. That is to be managed by the controller that contains this. Reason for the difference is the usecase.
                $scope.model ={
                    scacList : {},
                    sourceList : {
                        Source:[
                            {
                                code : "ALL",
                                desc : iscI18n.translate("shipmentFilter.source.LABEL_All")
                            },
                            {
                                code : "VENDOR",
                                desc : iscI18n.translate("shipmentFilter.source.LABEL_Vendor")
                            },
                            {
                                code : "STORE",
                                desc : iscI18n.translate("shipmentFilter.source.LABEL_Store")
                            },
                            {
                                code : "WAREHOUSE",
                                desc : iscI18n.translate("shipmentFilter.source.LABEL_Warehouse")
                            }
                        ]
                    },
                    shipmentTypeList:{
                        ShipmentType:[
                            {
                                code : "ALL",
                                desc : iscI18n.translate("shipmentFilter.type.LABEL_All")
                            },
                            {
                                code : "SPECIAL_ORDER",
                                desc : iscI18n.translate("shipmentFilter.type.LABEL_Special_order")
                            },
                            {
                                code : "INVENTORY",
                                desc : iscI18n.translate("shipmentFilter.type.LABEL_Inventory")
                            }
                        ]
                    }
                        
                };
                
                $scope.ui = {
                    accordianConfig:{
                        oneAtATime: false,
                        showShipmentDate : false,
                        showShipmentType : false,
                        showShipmentStatus : false,
                        showShipmentCarrier : false,
                        showShipmentSource : false,
                        shipmentDateLabel : iscI18n.translate("shipmentFilter.LABEL_Shipment_date")
                    },
                    filterCriteria:{
                        selectedShipmentType:"ALL",
                        selectedShipmentSource:"ALL",
                        selectedShipmentCarrier:"",
                        selectedFromShipmentDate : "",
                        selectedToShipmentDate : "",
                        selectedFromDate : "",
                        selectedToDate : "",
                        maxDate: null,
                        minDate: null,
                        dateDisplayFormat : dateFormatForLocale,
                        placeholderFormat : iscI18n.translate('shipmentFilter.placeholderFormat'),
                        fromDateReturnFormat: "YYYY-MM-DDT00:00:00",
                        toDateReturnFormat: "YYYY-MM-DDT23:59:59",
                        shipmentDateFilterSuffix: "shipmentDateFilter",
                        calleeId: "shipmentDateFilter" //"shipmentDateFilter_incoming" - other option.
                    },
                    isFilterApplied: false
                };
                
                //$scope.popOverTemplate = './shared/shipment/shipment-list-filter.tpl.html';
                
                $scope.uiOpenFilterPopover = function(){
                	if ($scope.filterData != null) {
                		for (var p in $scope.filterData) {
                			$scope.ui.filterCriteria[p] = $scope.filterData[p];
                		}
                	}
					if(!$scope.ui.showFilter){
						$scope.ui.showFilter = true;
				 		$document.on("keydown",escapeBinderFn);
					}
					else if($scope.ui.showFilter){
					  $scope.ui.showFilter = false;
					  $document.off("keydown",escapeBinderFn);
					}
				};
                
                var escapeBinderFn = function(event){
                    if(event.which === 27 && !event.defaultPrevented) {
                        $scope.ui.showFilter = false;
                        $document.off("keydown",escapeBinderFn);
                        $scope.$apply();
                        //event.preventDefault();
                    }
                };
					
                $scope.$on("$destroy", function () {
                    $document.off("keydown",escapeBinderFn);
                });
					
                $scope.uiClearAll = function() {
		        	
					$scope.ui.filterCriteria.selectedFromDate = '';
		        	$scope.ui.filterCriteria.selectedToDate = '';
                    $scope.ui.filterCriteria.selectedShipmentType = "ALL";
                    $scope.ui.filterCriteria.selectedShipmentCarrier = $scope.model.scacList.ScacList.Scac[0].Scac;
                    $scope.ui.filterCriteria.selectedShipmentSource = "ALL";
		        };
                /*$rootScope.$on('closeShipmentFilter',function(event,args){
                     $scope.ui.showFilter = false;
                     //$scope.setFilterToLastApplied();
                 });
				$scope.uiCloseFilter = function(){
		        	$scope.$emit('closeShipmentFilter',{});
		        };*/
				$scope.uiShowFilterOptions = function(){
					$scope.ui.showFilter = true;
			 		$document.on("keydown",escapeBinderFn);
				};
                
                
                $scope.uiApplyFilter = function(){
                    
                    var isDateFilterInError = checkDateFilterForErrors();
                    this.ui.shipmentDateFilterInError = isDateFilterInError;
					if(!isDateFilterInError) {
                        var filterData = {};
                        /*filterData.shipmentDate = {
                        	selectedFromDate :  $scope.ui.filterCriteria.selectedFromDate,
                        	selectedToDate : $scope.ui.filterCriteria.selectedToDate,
                        	selectedFromShipmentDate :  $scope.ui.filterCriteria.selectedFromShipmentDate,
                        	selectedToShipmentDate : $scope.ui.filterCriteria.selectedToShipmentDate
                        }*/
                        filterData.selectedFromDate = $scope.ui.filterCriteria.selectedFromDate;
                        filterData.selectedToDate = $scope.ui.filterCriteria.selectedToDate;
                        filterData.selectedFromShipmentDate =  $scope.ui.filterCriteria.selectedFromShipmentDate;
                        filterData.selectedToShipmentDate = $scope.ui.filterCriteria.selectedToShipmentDate;
                        filterData.selectedShipmentType = $scope.ui.filterCriteria.selectedShipmentType;
                        filterData.selectedShipmentCarrier = $scope.ui.filterCriteria.selectedShipmentCarrier;
                        filterData.selectedShipmentSource = $scope.ui.filterCriteria.selectedShipmentSource;
                        
                        $scope.validateIfFilterIsApplied(filterData);
                        //console.log(filterData);
                        $scope.onApply({filterData:filterData});
                        $scope.ui.showFilter = false;
                    }
                };
                
                $scope.validateIfFilterIsApplied = function(filterData) {
                	var isFilterApplied = false;
                	// Need if else here. At least one condition true is ok to deduce filter applied.
                	if(!iscCore.isVoid(filterData.selectedFromShipmentDate) || !iscCore.isVoid(filterData.selectedToShipmentDate)){
                		isFilterApplied = true;
                    } else if(!iscCore.isVoid(filterData.selectedShipmentType) && filterData.selectedShipmentType !== "ALL"){
                    	isFilterApplied = true;
                    } else if(!iscCore.isVoid(filterData.selectedShipmentCarrier)){
                    	isFilterApplied = true;
                    } else if(!iscCore.isVoid(filterData.selectedShipmentSource) && filterData.selectedShipmentSource !== "ALL"){
                    	isFilterApplied = true;
                    }
                	$scope.ui.isFilterApplied = isFilterApplied;
                };
                
                var init = function(){
                    iscMashup.callSimpleMashup($scope,"shared.shipment.shipment-list-filter.getScacList",{},{}).then(initMashupHandler,angular.noop);
                }
                
                var initMashupHandler = function(controllerData){
                    var output = iscMashup.getSimpleMashupOutput(controllerData,"shared.shipment.shipment-list-filter.getScacList");
                	// We could have more attributes, but we are catering only to 3 attributes now.
                    var anyCarrierRecord = {
                		"Scac": "",
        	            "ScacDesc": iscI18n.translate("shipmentFilter.LABEL_AnyCarrier"),
        	            "ScacKey": ""
                    };
                    if (output.ScacList != null && output.ScacList.Scac != null) {
	                    output.ScacList.Scac.splice(0, 0, anyCarrierRecord);
                    } else {
                    	console.warn("'shipment-list-filter.directive' unexpected scenario: output does not contain scanList. Defaulting to blank.");
                    	output = {
                    		"ScacList": {
                    			"Scac": [anyCarrierRecord]
                    		}
                    	};
                    }
                    $scope.model.scacList = output;
                    $scope.ui.filterCriteria.selectedShipmentCarrier = output.ScacList.Scac[0].Scac;
                    
                    initializeWithFilterData();
                    
                    if (!iscCore.isVoid($scope.shipmentDateLabel)) {
                    	$scope.ui.accordianConfig.shipmentDateLabel = $scope.shipmentDateLabel;
                    }
                }
                
                init();
                
                var initializeWithFilterData = function(){
                   if($scope.filterData){
                       
                       if(!iscCore.isVoid($scope.filterData.selectedFromShipmentDate)){
                           $scope.ui.filterCriteria.selectedFromShipmentDate = $scope.filterData.selectedFromShipmentDate;
                           $scope.ui.filterCriteria.selectedToShipmentDate = $scope.filterData.selectedToShipmentDate;
                           $scope.ui.filterCriteria.selectedFromDate = $scope.filterData.selectedFromDate;
                           $scope.ui.filterCriteria.selectedToDate = $scope.filterData.selectedToDate;
                           $scope.ui.isFilterApplied = true;
                       }
                       if(!iscCore.isVoid($scope.filterData.selectedShipmentType)){
                           $scope.ui.filterCriteria.selectedShipmentType = $scope.filterData.selectedShipmentType;
                           $scope.ui.isFilterApplied = true;
                       }
                       if(!iscCore.isVoid($scope.filterData.selectedShipmentCarrier)){
                           $scope.ui.filterCriteria.selectedShipmentCarrier = $scope.filterData.selectedShipmentCarrier;
                           $scope.ui.isFilterApplied = true;
                       }
                       if(!iscCore.isVoid($scope.filterData.selectedShipmentSource)){
                           $scope.ui.filterCriteria.selectedShipmentSource = $scope.filterData.selectedShipmentSource;
                           $scope.ui.isFilterApplied = true;
                       }
                       if(!iscCore.isVoid($scope.filterData.calleeId)){
                           $scope.ui.filterCriteria.calleeId = $scope.filterData.calleeId;
                           // As of today, when passed, it only comes from incoming tab.
                           $scope.ui.filterCriteria.minDate = amSubtractFilter(new Date()).format(dateFormatFromToDates);
                       } else {
                    	   $scope.ui.filterCriteria.maxDate = amSubtractFilter(new Date()).format(dateFormatFromToDates);
                       }
                       
                       $scope.validateIfFilterIsApplied($scope.ui.filterCriteria);
                   }
                }
                
                var checkDateFilterForErrors = function() {
					var isError = false;
					if($scope.ui.forms.shipmentDateFilter.$invalid) {
						$scope.ui.shipmentDateFilterErrorMessge = iscI18n.translate('datefilter.ERROR_invalid_format');
						isError = true;
					} else {
						var error = iscDateFilter.validateDateRange($scope.ui.filterCriteria.selectedFromDate,$scope.ui.filterCriteria.selectedToDate,$scope.ui.filterCriteria.maxDate,$scope.ui.filterCriteria.minDate);
					   if(error.isError){
                           $scope.ui.shipmentDateFilterErrorMessge = error.errorMesssage;
                           isError = error.isError;
                       }
                    }
					return isError;
				}
            }]
        }
 
    }]);
    
})(window.iscCore);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp. 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/


(function(iscCore){
    
    /**
     * @ngdoc directive
     * @name iscShipmentListSort
     * @restrict E
     *
     * @description
     * Displays Shipment sort options as a pop-over
     *
     * @scope
     * @param {String=} sortcontext - Sets the context of sorting based on type of Order.
     * @param {String=} filterAppliedCallback - Callback handler function to be executed on applying the filter.
     * @example
     *  The HTML will have the directive specified like below:
     *   <div>
     *       <isc-shipment-list-sort  sortcontext="SFS" filter-applied-callback="uiApplySortOptions" ng-if="ui.showSFSView"></isc-shipment-list-sort> 
     *   </div>
     */
    
    angular.module("isc.shared").directive("iscShipmentListSort",[function(){
        
        return {
            restrict: 'E',
            templateUrl:'./shared/shipment-list-sort/shipment-list-sort-popover.tpl.html',
            scope:{
            	
            	sortOption: '=',
                filterAppliedCallback:'=',
                sortcontext: '@'
                
                
            },
            link:function(scope, $element, $attr, ctrl, $transclude){
            	// link parent controller's function and invoke them accordingly.
            	scope.postCallbackData = function(filterDetails){
 	               var callbackHandler = scope.filterAppliedCallback;
 	               callbackHandler(filterDetails);
 	            };
            },
            controller:["$scope",'$rootScope','$document','iscI18n','iscMashup','iscAppContext',function($scope,$rootScope,$document,iscI18n,iscMashup,iscAppContext){
				
               
                $scope.ui = {
                		
                		sortOption:'OLD_TO_NEW',
                		lastAppliedSortOption:'',
                		oldToNewLabelBundleKey : 'shipmentListSort.LABEL_oldToNew',
                		newToOldLabelBundleKey : 'shipmentListSort.LABEL_newToOld',
                		expectedDateBundleKey :  'shipmentListSort.LABEL_expectedShipDate'
                   
                };
            
                /**
    			 * @ngdoc method
    			 * @name iscPickOrderListFilter#uiOpenFilterPopover
    			 * @description Opens the Pick Order filter in Pop-over
    			 * 
    			 */ 
                
                $scope.uiOpenFilterPopover = function(){
                	if ($scope.filterData != null) {
                		for (var p in $scope.filterData) {
                			$scope.ui.filterCriteria[p] = $scope.filterData[p];
                		}
                	}
					if(!$scope.ui.showFilter){
						$scope.ui.showFilter = true;
				 		$document.on("keydown",escapeBinderFn);
					}
					else if($scope.ui.showFilter){
					  $scope.ui.showFilter = false;
					  $document.off("keydown",escapeBinderFn);
					}
				};
                
				$rootScope.$on('closeBatchLineFilter',function(event,args){
					 $scope.ui.showFilter = false;
	  			 });
				
                var escapeBinderFn = function(event){
                    if(event.which === 27 && !event.defaultPrevented) {
                        $scope.ui.showFilter = false;
                        $document.off("keydown",escapeBinderFn);
                        $scope.$apply();
                    }
                };
					
                $scope.$on("$destroy", function () {
                    $document.off("keydown",escapeBinderFn);
                });
					
                $scope.$watch('ui.showFilter', function(){
		        	if($scope.ui.showFilter){
		        		$scope.ui.sortOption = angular.copy($scope.ui.lastAppliedSortOption);
		        	}
		        });
		        
				$scope.uiShowFilterOptions = function(){
					$scope.ui.showFilter = true;
			 		$document.on("keydown",escapeBinderFn);
				};
                
				/**
    			 * @ngdoc method
    			 * @name iscPickOrderListFilter#uiApplyFilter
    			 * @description Invoked when Apply button is clicked in the filter pop-over
    			 * 
    			 */
                $scope.uiApplyFilter = function(){
                    
                	var data = {};
                	data.sortOption = $scope.ui.sortOption;
                	$scope.ui.lastAppliedSortOption = angular.copy($scope.ui.sortOption);
                	$scope.ui.showFilter = false;
                    $scope.postCallbackData(data);
                };
                
                /**
    			 * @ngdoc method
    			 * @name iscPickOrderListFilter#uiCancel
    			 * @description Invoked on Cancel 
    			 * 
    			 */
                $scope.uiCancel = function() {
                	$scope.$emit('closeBatchLineFilter',{});
                };
                
                var init = function(){
                	
                	if ($scope.sortOption != null) {
                		$scope.ui.sortOption = ($scope.sortOption == 'N')?'OLD_TO_NEW':'NEW_TO_OLD';	
                	}
                	
                	$scope.ui.lastAppliedSortOption = $scope.ui.sortOption;
    				
    				if($scope.sortcontext == "Pickup"){
    					$scope.ui.expectedDateBundleKey = 'shipmentListSort.LABEL_expectedPickDate';
    				}
    				
    				if($scope.sortcontext == "All"){
    					$scope.ui.expectedDateBundleKey = 'shipmentListSort.LABEL_expectedShipOrPickDate';
    				}
    					 
                }
                
                
                init();
                
               
            }]
        }
 
    }]);
    
})(window.iscCore);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp. 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/




(function(iscCore){
    
    /**
     * @ngdoc directive
     * @name iscShipmentSearchFilter
     * @restrict E
     *
     * @description
     * Displays Shipment filter options as a pop-over
     *
     * @scope
     * @param {Object=} filterOptions - Filter Options.
     * @param {String=} onApply - Callback handler function to be executed on applying the filter.
     * @example
     *  The HTML will have the directive specified like below:
     *   <div>
     *      <isc-shipment-search-filter  filter-options="model.filterOptions" on-apply="uiOnApplyFilter(filterData)"></isc-shipment-search-filter> 
     *   </div>
     */
    
    angular.module("isc.shared").directive("iscShipmentSearchFilter",[function(){
        
        return {
            restrict: 'E',
            templateUrl:'./shared/shipment-search-filter/shipment-search-filter-popover.tpl.html',
            scope:{
            	filterOptions:"=",
                onApply:"&"
            },
            link:function($scope, $element, $attr, ctrl, $transclude){
                
            },
            controller:["$scope",'$rootScope','$document','iscI18n','iscAppContext','iscShipmentStatus',function($scope,$rootScope,$document,iscI18n,iscAppContext,iscShipmentStatus){
               
                $scope.ui = {
                   
                    filterCriteria:{},
                    isFilterApplied: true,
                    filterData:{},
                    filterOptions : {}
                };
                
                
                /**
    			 * @ngdoc method
    			 * @name iscShipmentSearchFilter#uiOpenFilterPopover
    			 * @description Opens the Shipment Status filter in Pop-over
    			 * 
    			 */
                
                $scope.uiOpenFilterPopover = function(){
                	if ($scope.ui.filterData != null) {
                		for (var p in $scope.ui.filterOptions) {
                			$scope.ui.filterCriteria[p] = $scope.ui.filterOptions[p];
                		}
                	}else {
                		$scope.uiReset();
                	}
					if(!$scope.ui.showFilter){
						$scope.ui.showFilter = true;
				 		$document.on("keydown",escapeBinderFn);
					}
					else if($scope.ui.showFilter){
					  $scope.ui.showFilter = false;
					  $document.off("keydown",escapeBinderFn);
					}
				};
                
                var escapeBinderFn = function(event){
                    if(event.which === 27 && !event.defaultPrevented) {
                        $scope.ui.showFilter = false;
                        $document.off("keydown",escapeBinderFn);
                        $scope.$apply();
                    }
                };
					
                $scope.$on("$destroy", function () {
                    $document.off("keydown",escapeBinderFn);
                });
				
                /**
    			 * @ngdoc method
    			 * @name iscShipmentSearchFilter#uiReset
    			 * @description Reset button handler
    			 * 
    			 */
                
                $scope.uiReset = function() {
                	$scope.ui.filterCriteria = angular.copy($scope.ui.filterOptions);
		        };
                
				$scope.uiShowFilterOptions = function(){
					$scope.ui.showFilter = true;
			 		$document.on("keydown",escapeBinderFn);
				};
                
                
				$scope.validateFilterOptions = function(filterData){
					
					var statusArray = filterData.StatusList.Status;
					for(var j=0; j<statusArray.length; j++){
						if(statusArray[j].Checked=='Y'){
							return true;
						}
					}
					
					return false;
				};
				
				/**
    			 * @ngdoc method
    			 * @name iscShipmentSearchFilter#uiApplyFilter
    			 * @description Invoked when Apply button is clicked in the filter pop-over
    			 * 
    			 */
                $scope.uiApplyFilter = function(){
                    
					var filterData = {};
					filterData = $scope.ui.filterCriteria;
					
                        
                	var isFilterValid = $scope.validateFilterOptions($scope.ui.filterCriteria);
                	if(isFilterValid){
						$scope.ui.filterData = filterData
                		$scope.ui.isFilterApplied = true;
                		$scope.ui.showFilter = false;
                		$scope.onApply({filterData:filterData});
                	}
                	else{
                		$scope.ui.isFilterApplied = false;
                	}
                           
                };
                
                
                var init = function(){
                	
                	
                	$scope.ui.filterOptions = angular.copy($scope.filterOptions); 
                	$scope.ui.filterCriteria = angular.copy($scope.ui.filterOptions);  
                	
                }
                
                
                init();
            }]
        }
 
    }]);
    
})(window.iscCore);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp. 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/

(function(iscCore){
    
    /**
     * @ngdoc directive
     * @name iscStagingLocation
     * @restrict E
     *
     * @description
     * This directive is used to add staging location and display list of staging location.
     *
     * @scope
     * @param {Object=} stagingLocation - Staging location model used for displaying the list
     * @param {Object=} stagingLocationErrors - Validation errors to be shown below the staging location textfield. These errors are thrown while adding staging location.
     * @param {String=} stagingLocationCallback - Callback handler function to be executed on adding/deleting the staging location
     * @param {String=} stagingLocationTranslationRequired - Boolean value to indicate if staging location translation is required.
     * @example
     *  The HTML will have the directive specified like below:
     *   <div>
     *       <isc-staging-location staging-location="model.shipmentDetails.Shipment.HoldLocation"  staging-location-errors="ui.stagingLocationErrors" 
     *       	staging-location-callback="uiManageStagingLocation" staging-location-translation-required="ui.isStagingLocationTranlationRequired" ></isc-staging-location>
     *   </div>
     */
    
    angular.module('isc.shared').directive("iscStagingLocation",[function(){
        
        return {
            restrict: 'E',
            templateUrl:'./shared/staging-location/staging_location.tpl.html',
            scope:{
            	
                stagingLocation:'=',
                stagingLocationTranslationRequired:'=',
                stagingLocationErrors:'=',
               // stagingLocationDelimiter:'@',
                stagingLocationCallback: '=stagingLocationCallback',
                
            },
            link:function(scope, $element, $attr, ctrl, $transclude){
            	
	            	// link parent controller's function and invoke them accordingly.
	            	scope.postCallbackData = function(stagingLocationDetails){
	            	var callbackHandler = scope.stagingLocationCallback;
	            	callbackHandler(stagingLocationDetails,scope.ui.action);
 	              
 	            };

            },
            controller:["$scope",'$rootScope','$document','iscModal','iscI18n','iscDomUtility','iscAppContext',function($scope,$rootScope,$document,iscModal,iscI18n,iscDomUtility, iscAppContext){
				
               
                $scope.ui = {
                	action:'',
                	numOfStagingLocation:-1,
                	stagingLocationTextLabel: $scope.stagingLocationTranslationRequired ? 'stagingLocation.LABEL_ScanStagingLocation' : 'stagingLocation.LABEL_EnterStagingLocation',
                	skipStagingLocationValidation:$scope.stagingLocationTranslationRequired,
                	stagingLocationErrors:{displayError:false,errorMsg:""}
                };
                
                $scope.model = {
					stagingLocationList : {StagingLocationList:{StagingLocation:[]}},
					stagingLocation:""
				};
                
                $scope.$watch("stagingLocation",function(newValue){
                	$scope.stagingLocation = newValue;
                	$scope.prepareStagingLocationList($scope.stagingLocation);
                	
                	if(!$scope.ui.stagingLocationErrors.displayError) {
                		$scope.resetStagingLocation();
                	}
        		});
                
                $scope.$watch("model.stagingLocation",function(newValue){
                	if($scope.ui.stagingLocationErrors.displayError) {
                		$scope.ui.stagingLocationErrors = {displayError:false,errorMsg:""};
                	}
        		});
                
               $scope.$watch("stagingLocationErrors",function(newValue){
                	if(!iscCore.isVoid($scope.stagingLocationErrors)) {
                		$scope.ui.stagingLocationErrors.displayError = $scope.stagingLocationErrors.displayError;
                		if($scope.ui.stagingLocationErrors.displayError) {
                			$scope.ui.stagingLocationErrors.errorMsg = $scope.stagingLocationErrors.errorMsg;
                		}
                	}

        		});
               
                $scope.prepareStagingLocationList = function(stagingLocation) {
                	
                	if(stagingLocation) {
                		
                		
                		if(stagingLocation.indexOf(",") > -1) {
                			
                			var splitLocationArray = stagingLocation.split(",");
                    		
            				for(var i=0;i<splitLocationArray.length;i++){
            					
            					var location = splitLocationArray[i];
            					if(location) {
            						location = location.replace(/^\s+|\s+$/g, '');
            					}
            					
            					$scope.model.stagingLocationList.StagingLocationList.StagingLocation[i] = {};
            					$scope.model.stagingLocationList.StagingLocationList.StagingLocation[i].Location = $scope.trimString(splitLocationArray[i]);
            				}
            				
            				$scope.ui.numOfStagingLocation = splitLocationArray.length;
                			
                		} else {
                			
                			$scope.model.stagingLocationList.StagingLocationList.StagingLocation[0] = {};
        					$scope.model.stagingLocationList.StagingLocationList.StagingLocation[0].Location = $scope.trimString(stagingLocation);
        					$scope.ui.numOfStagingLocation = 1;
                			
                		}
                		
                		
                	} else {
                		
                		$scope.ui.numOfStagingLocation = 0;
                	}
                	
                	
                };
                
                $scope.deleteStagingLocation = function(locationToBeDeleted) {
                		
	        		var locationIndex = $scope.model.stagingLocationList.StagingLocationList.StagingLocation.indexOf(locationToBeDeleted);
	        		$scope.model.stagingLocationList.StagingLocationList.StagingLocation.splice(locationIndex, 1); 
	        		$scope.ui.action = 'DELETE';
	        		
	        		$scope.prepareCallbackDataByAction(location,'DELETE');
	        		
                };
                
                $scope.prepareCallbackDataByAction = function(location, action) {
                	
                	var updatedStagingLocation = ""; 
                	
                	if(action == 'ADD') {
                		updatedStagingLocation = angular.copy($scope.stagingLocation);
                		
                		if(updatedStagingLocation && !$scope.stagingLocationTranslationRequired) {
                			updatedStagingLocation = updatedStagingLocation + ", " + location;
                		} else {
                			updatedStagingLocation = location;
                		}
                		
                	} else if(action == 'DELETE') {
                		
                		updatedStagingLocation = $scope.getStringFromJSONArray($scope.model.stagingLocationList.StagingLocationList.StagingLocation, "Location", "\, ");
                	}
                	
                	$scope.postCallbackData(updatedStagingLocation);
                	
                	
                };
                
                
                $scope.getStringFromJSONArray = function(jsonArray, attribute, delimiter) {
                	
                	var concatenatedString = jsonArray.map(function(object) {
		                			return object[attribute];
		                		}).join(delimiter);
                	
                	return concatenatedString;
                	
                };
                
                
                $scope.trimString = function(value) {
                	
                	if(!angular.isString(value)) {
                        return value;
                    }  
                    return value.replace(/^\s+|\s+$/g, '');
                	
                };
                
					
                $scope.resetStagingLocation = function() {
		        	
					$scope.model.stagingLocation = "";
                   
		        };
                
                $scope.isStagingLocationValid = function(toBeAddedStagingLocation){
                	
                	var errorBundleKey = "";
                	
                	if(iscCore.isVoid(toBeAddedStagingLocation)) {
                		$scope.ui.stagingLocationErrors.displayError = true;
    	  				$scope.ui.stagingLocationErrors.errorMsg = iscI18n.translate("stagingLocation.MSG_InvalidStagingLocation");
    	  				return false;
                	}
                	
                	if($scope.ui.skipStagingLocationValidation) {
                		return true;
                	}
                	
                	if($scope.model.stagingLocation.indexOf(",") == -1) {
            			
            			if(!$scope.isStagingLocationDuplicate(toBeAddedStagingLocation)) {
            				
                			if($scope.validateStagingLocationForMaxLength(toBeAddedStagingLocation)) {
                				
                				return true;
                				
                			} else {
                				errorBundleKey = "stagingLocation.MSG_HoldLocationExceedsMaxLength";
                			}
                		} else {
                			errorBundleKey = "stagingLocation.MSG_DuplicateHoldLocation";
                		} 
            			
            		} else {
            			errorBundleKey = 'stagingLocation.MSG_InvalidHoldLocationText';
            		}
                	
                	if(errorBundleKey) {
                		//iscModal.showErrorMessage(iscI18n.translate(errorBundleKey));
                		$scope.ui.stagingLocationErrors.displayError = true;
    	  				$scope.ui.stagingLocationErrors.errorMsg = iscI18n.translate(errorBundleKey);
                	} 
                		
                    return false;
                };
                
                
                $scope.isStagingLocationDuplicate = function(stagingLocation){
                	
                	var isDuplicate = false;
        			
        			if($scope.model.stagingLocationList && $scope.model.stagingLocationList.StagingLocationList && $scope.model.stagingLocationList.StagingLocationList.StagingLocation &&
        					$scope.model.stagingLocationList.StagingLocationList.StagingLocation.length > 0 ) {
        				
        				for(var i =0;i<$scope.model.stagingLocationList.StagingLocationList.StagingLocation.length;i++) {
        					
        					var existingStgLocation = $scope.model.stagingLocationList.StagingLocationList.StagingLocation[i];
        					if(stagingLocation == existingStgLocation.Location) {
        						isDuplicate = true;
        						break;
        					}
        					
        				}
        				
        			} 
        			
        			return isDuplicate;
        			
        		};
        		
        		$scope.validateStagingLocationForMaxLength = function(stagingLocation) {
        			
        			var updatedStagingLocation = angular.copy($scope.stagingLocation);
        			if(updatedStagingLocation) {
        				updatedStagingLocation = updatedStagingLocation + ", " + stagingLocation;
        				if (updatedStagingLocation.length <= 40) {
        					return true;
            			}
        			} else {
        				return true;
        			}
        			
        			return false;
            		
        			
        		};
                
                $scope.uiConfirmDeleteStagingLocation = function(locationToBeDeleted) {
                	
                	$scope.deleteStagingLocation(locationToBeDeleted);
                	
                	/*iscModal.showConfirmationMessage(iscI18n.translate('stagingLocation.MSG_deleteHoldLocation')).then(function(action){
            			if(action == 'YES'){
            				$scope.deleteStagingLocation(locationToBeDeleted);
            			}
            		});*/
                };
                
                
                $scope.uiAddStagingLocation = function() {
                	
                	if($scope.isStagingLocationValid(angular.copy($scope.trimString($scope.model.stagingLocation)))) {
                		$scope.ui.action = 'ADD';
                		$scope.prepareCallbackDataByAction(angular.copy($scope.trimString($scope.model.stagingLocation)),'ADD');
                	} 
                	
                };
                
                var init = function(){
                	
                	/*if(!iscCore.isVoid($scope.stagingLocationError)) {
                		$scope.ui.errors.displayError = $scope.stagingLocationError.displayError;
                		if($scope.ui.errors.displayError) {
                			$scope.ui.errors.errorMsg = $scope.stagingLocationError.errors.errorMsg;
                		}
                	}*/
                	
                	if(iscCore.isVoid($scope.stagingLocation)) {
                		$scope.stagingLocation = $scope.model.stagingLocation = "";
                	} else {
                		$scope.prepareStagingLocationList($scope.stagingLocation);
                	}
                	
                	iscDomUtility.setFocus(document.getElementById('stagingLocation'));
                	
                }
                
                
                init();
                
               
            }]
        }
 
    }]);
    
})(window.iscCore);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp. 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/



/**
 * @ngdoc directive
 * @name iscStoreList
 *
 * @requires iscI18n
 *
 * @restrict E
 *
 * @description
 * Store list display
 * @example
 * <isc-store-list node="node" store="ui.searchedStore" store-Desc="ui.searchedStoreDesc" >
 * </isc-store-list> 
 *
 *	
 * @param {Object} node Current node in the output list of nodes.
 * @param {Object} store node/store selected in radio button.
 * (default selection from the list of stores)
 * @param {String} storeDesc Description of the selected store in the list.
 */

angular.module('isc.shared').directive('iscStoreList',['iscI18n',function(iscI18n) {

  return {
    restrict: 'E',
	scope: {
          node:'=',
          store: '=',
          storeDesc : '='	  
		},
	
    templateUrl: './shared/store-list/store-list.tpl.html'
};
}]);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp. 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/

/**
 * @ngdoc directive
 * @name iscIgnoreDirty
 * @restrict A
 * 
 * @description Skips dirty checking for input elements defined in ng-form. Dirty checking is skipped by overriding the $setDirty method defined on the model controller.
 * 
 * @param {Object} model(ngModel) object of the input element which requires to skip dirty check.
 * 
 * @example
 *    <input type="text" ng-model="model.barCodeData" isc-barcode-scanner="PRIMARY" isc-ignore-dirty>
 */
(function(sharedModule){
	'use strict';
	
	sharedModule.directive("iscIgnoreDirty", function () {
		
	  return {
		    restrict: 'A',
		    require: 'ngModel',
		    link: function (scope, element, attrs, controller) {
		    	controller.$setDirty = angular.noop;
		    }
		  }
		})

})(angular.module("isc.shared"));

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/

/**
 * @ngdoc directive
 * @name iscWizardPageView
 * @restrict E
 * 
 * @description This directive will show wizard page
 * 
 * 
 * @priority 400,-400
 * @example
    <!-- To define wizard page view 
    <div isc-wizard-view></div>
    
 */

(function(angular){
  
  
  angular.module('isc.shared').directive('iscWizardPageView', iscWizardPageViewFactory);
  angular.module('isc.shared').directive('iscWizardPageView', iscWizardPageViewFillContentFactory);
  
  
  iscWizardPageViewFactory.$inject = ['$anchorScroll', '$animate'];
  
  function iscWizardPageViewFactory($anchorScroll, $animate) {
    return {
      restrict: 'ECA',
      require: "^iscWizard",
      terminal: true,
      priority: 400,
      transclude: 'element',
      link: function(scope, $element, attr, wizardCtrl, $transclude) {
          var currentScope,
              currentElement,
              previousLeaveAnimation,
              autoScrollExp = attr.autoscroll,
              onloadExp = attr.onload || '';
  
          scope.$on('$wizardPageChangeSuccess', update);
          //update();
  
          function cleanupLastView() {
            if (previousLeaveAnimation) {
              $animate.cancel(previousLeaveAnimation);
              previousLeaveAnimation = null;
            }
  
            if (currentScope) {
              currentScope.$destroy();
              currentScope = null;
            }
            if (currentElement) {
              previousLeaveAnimation = $animate.leave(currentElement);
              previousLeaveAnimation.then(function() {
                previousLeaveAnimation = null;
              });
              currentElement = null;
            }
          }
  
          function update(e,currentPage) {
            scope.current = currentPage;
            var locals = scope.current && scope.current.locals,
                template = locals && locals.$template;
  
            if (angular.isDefined(template)) {
              var newScope = scope.$new();
              var current = scope.current;
  
              // Note: This will also link all children of ng-view that were contained in the original
              // html. If that content contains controllers, ... they could pollute/change the scope.
              // However, using ng-view on an element with additional content does not make sense...
              // Note: We can't remove them in the cloneAttchFn of $transclude as that
              // function is called before linking the content, which would apply child
              // directives to non existing elements.
              var clone = $transclude(newScope, function(clone) {
                $animate.enter(clone, null, currentElement || $element).then(function onIscWizardPageViewEnter() {
                  if (angular.isDefined(autoScrollExp)
                    && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                    $anchorScroll();
                  }
                });
                cleanupLastView();
              });
  
              currentElement = clone;
              currentScope = current.scope = newScope;
              currentScope.$emit('$wizardPageViewContentLoaded');
              currentScope.$eval(onloadExp);
            } else {
              cleanupLastView();
            }
          }
      }
    };
  }

  // This directive is called during the $transclude call of the first `ngView` directive.
  // It will replace and compile the content of the element with the loaded template.
  // We need this directive so that the element content is already filled when
  // the link function of another directive on the same element as ngView
  // is called.
  iscWizardPageViewFillContentFactory.$inject = ['$compile', '$controller'];
  function iscWizardPageViewFillContentFactory($compile, $controller) {
    return {
      restrict: 'ECA',
      require: "^iscWizard",
      priority: -400,
      link: function(scope, $element,$attr,wizardCtrl) {
        var current = scope.current,
            locals = current.locals;
  
        $element.html(locals.$template);
  
        var link = $compile($element.contents());
  
        if (current.controller) {
          locals.$scope = scope;
          var controller = $controller(current.controller, locals);
          if (current.controllerAs) {
            scope[current.controllerAs] = controller;
          }
          $element.data('$ngControllerController', controller);
          $element.children().data('$ngControllerController', controller);
        }
  
        link(scope);
      }
    };
  }

  
  
})(window.angular);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/


/**
 * @ngdoc directive
 * @name iscWizardPage
 * @restrict E
 * 
 * @description This directive will create wizard page and registers the page for the wizard
 * This directive should be used only inside iscWizard directive
 * 
 * 
 * @priority 600
 * @param {string} title Title of the wizard page
 * @param {string} pageEnterAction Action name for entering the page (bundle_key)
 * @param {string} templateUrl Template url of the page view
 * @param {string} controller Controller name of the page view
 * @param {string} pageId Id of the wizard page to register
 * 
 * @example
    <!-- To define wizard page template html -->
    <isc-wizard custom-transition="true"
      wizard-init-controller="myWizardInitController"
      wizard-init-template-url="myWizardInitTpl.html"
      wizard-finish-controller="myWizardFinishController"
      wizard-finish-template-url="myWizardFinishTpl.html"
    >
      <isc-wizard-page page-id="myPage1" page-enter-action="myPage1ActionBundleKey" 
        template-url="mypage1.html" controller="mypage1controller"></isc-wizard-page>
      <isc-wizard-page page-id="myPage2" page-enter-action="myPage2ActionBundleKey" 
        template-url="mypage2.html" controller="mypage2controller"></isc-wizard-page>
    </isc-wizard>
    
 */




angular.module('isc.shared').directive('iscWizardPage', function(){

  return {
    require: "^iscWizard",
    restrict: 'E',
    scope: {
      title: '@',
	    pageEnterAction:'@',
	    templateUrl:'@',
	    controller:'@',
	    pageId:'@'
    },
    replace: false,
    link: function(scope, element, attrs, wizardController){
      
      var page = {
        title:scope.title,
        pageEnterAction:scope.pageEnterAction,
        templateUrl:scope.templateUrl,
        controller:scope.controller
      };
      wizardController.registerPage(scope.pageId,page);
    }
  };

});

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp.  2015, 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/

(function(iscCore){
  
  iscCore.createWizardStack = function(previousWizardStack){
    
    var wizardStack = {};
    wizardStack._stack = [];
    wizardStack._current = null;
    
    if(!iscCore.isVoid(previousWizardStack)){
        wizardStack._stack = previousWizardStack._stack;
        wizardStack._current = wizardStack._stack[wizardStack._stack.length-1];
    }
    
    wizardStack.push= function(pageData){
      wizardStack._stack.push(pageData);
      wizardStack._current = pageData;
    };
    
    wizardStack.pop = function(){
      wizardStack._stack.pop();
      wizardStack._current = wizardStack._stack[wizardStack._stack.length-1];
      return wizardStack._current;
    };
    
    wizardStack.clear = function(){
      wizardStack._stack = [];
      wizardStack._current = null;
    };
    
    wizardStack.getCurrent = function(){
      return wizardStack._current;
    };
    
    wizardStack.isEmpty = function(){
      return wizardStack._stack.length<=1;
    };
    
    wizardStack.length = function(){
      return wizardStack._stack.length;
    };
    
    return wizardStack;
    
  };
  
  
})(window.iscCore);

(function(iscCore){
	/**
	 * @ngdoc directive
	 * @name iscWizard
	 * @restrict E
	 * 
	 * @description This directive will create wizard and registers the pages for the wizard
	 * 
	 * 
	 * 
	 * @priority 600
	 * @param {string} wizardInitController Init Controller for the wizard
	 * @param {string} wizardInitTemplateUrl Init templateUrl for the wizard
	 * @param {string} wizardFinishController Init Controller for the wizard
	 * @param {string} wizardFinishTemplateUrl Init templateUrl for the wizard
	 * @param {boolean} [customTransition=false] Boolean to indicate whether wizard should follow custom transition or standard transition
	 * 
	 * wizardInitController should be used for validation the wizard input before the starting the wizard flow. 
	 * Once the validation is done, should call startWizard for Standard transistion and for custom transition should call gotoCustomPage to start the wizard
	 * 
	 * wizardFinishController should be used for navigating away from the wizard.
	 * 
	 * When customTransition is true, each wizard page should control the flow of the wizard by using gotoCustomPage method of iscWizard service
	 * 
	 * @example
		<!-- To define wizard template html -->
		<isc-wizard custom-transition="true"
		  wizard-init-controller="myWizardInitController"
		  wizard-init-template-url="myWizardInitTpl.html"
		  wizard-finish-controller="myWizardFinishController"
		  wizard-finish-template-url="myWizardFinishTpl.html"
		>
		</isc-wizard>
		
	 */
  angular.module('isc.shared').directive('iscWizard', ['$rootScope','iscWizard', '$templateRequest', '$sce','iscStateParams',function($rootScope,iscWizard, $templateRequest, $sce,iscStateParams){
  
  	
    var showWizardPage = function showWizardPage(page,$scope){
      
      //console.log(page);
      iscWizard._setWizardPageInput(page.pageInput);
      iscWizard._setWizardPageOptions(page.pageOptions);
      $template = $templateRequest(page.pageConfig.templateUrl);
  		  
  	  $template.then(function(template){
  	    var currentPage = {
  	      locals:{
  	        $template:template
  	      },
  	      controller : page.pageConfig.controller,
          pageConfig : page
  	    };
  	    $rootScope.$broadcast('$wizardPageChangeSuccess',currentPage);
				if(!iscCore.isVoid(page.pageOptions)){
					$scope.wizardPageCssClass = page.pageOptions.wizardPageCssClass;	
				}
				else{
					$scope.wizardPageCssClass = undefined;
				}
  	  });
    };
  
  
    return {
      restrict: 'E',
      transclude: true,
  
      scope: {
        //onBeforeStepChange: '&',
        //onStepChanging: '&',
        //onAfterStepChange: '&',
  	    wizardInitController:'@',
  	    wizardInitTemplateUrl:'@',
  	    wizardFinishController:'@',
  	    wizardFinishTemplateUrl:'@',
  	    customTransition:'@'
      },	
      templateUrl: './shared/wizard/wizard.tpl.html',
  
      replace: true,
  
      link: function($scope){
          var page = null;
          if(iscCore.isBooleanTrue($scope.isWizardRenderingFromBack)){
              page = $scope.wizardStack.getCurrent();
          }
          else{
              $scope.wizardStack.clear();
              page = {pageConfig:{templateUrl:$scope.wizardInitTemplateUrl,controller:$scope.wizardInitController},pageInput:null,pageOptions:null};
          }
        
        
        showWizardPage(page,$scope);
      },
  
      controller: ['$scope','$rootScope','iscState', function($scope,$rootScope,iscState){
  		  $scope.pages = [];
  		  $scope.pageRegistry = {};
  		  $scope.currentPage = 0;
  		  var customTransition = false;
  		  if($scope.customTransition==="true"){
  		    customTransition = true;
  		  }
  		  
				var wizardCtrl = this;
				
  		  $scope.$on('$handleBackButton',function(e,data){
  		    if(!$scope.wizardStack.isEmpty()){
  		      e.preventDefault();
  		      iscWizard.gotoPreviousPage();
  		    }
					else{
						data = data ? data : {};
						if(data && !data.force && wizardCtrl._handleWizardPageBack()){
							e.preventDefault();							
						}
					}
  		    
  		  });
				
				$scope.$on('$beforeStateChange',function(e,data){
					//console.log(data);					
					wizardCtrl.exitState = {
						options:data.options,
						params:data.params,
						state:data.state
					}
                    
                    if(!iscState._isDefaultState(data)){
                        //console.log(iscState);
                        if(iscCore.isBooleanTrue(iscState.currentState.stateInfo.addToHistory)){
                            iscState.currentState.options.wizardData = {};
                            iscState.currentState.options.wizardData._stack = wizardStack._stack;
                        }
                    }
                    
					data = data ? data : {};
					if(data && !data.force && wizardCtrl._handleWizardExit()){
						e.preventDefault();							
					}
				});
  		  
				this.isFirstPage = function(){
				    return $scope.wizardStack.isEmpty();					
				}
				
  		  $scope.$on('$destroy',function(e){
  		    iscWizard.clearWizard();
  		  });
  		  
  		  iscWizard.clearWizard();
  		  iscWizard._setWizardController(this);
  		  var previousWizardStack = iscStateParams.options.wizardData;
          $scope.isWizardRenderingFromBack = iscStateParams.options.backButtonClicked;
  		  var wizardStack = iscCore.createWizardStack(previousWizardStack);
  		  $scope.wizardStack = wizardStack;
  		  
        this.registerPage = function(pageId,pageData){
          //console.log(page);
          $scope.pages.push(pageData);
          $scope.pageRegistry[pageId]=pageData;
        };
        
        //$scope.$on('startWizard',this.startWizard);
    		//$scope.$on('startCustomWizard',this.startCustomWizard);
    		//$scope.$on('gotoNextPage',this.gotoNextPage);
    		//$scope.$on('gotoPreviousPage',this.gotoPreviousPage);
    		//$scope.$on('gotoCustomPage',this.gotoCustomPage);
    		//$scope.$on('finishWizard', this.finishWizard);
    		
    		
    		this.startWizard = function (e,data){
          if(!customTransition){
            var page = {pageConfig:$scope.pages[0],pageInput:null,pageOptions:null};
  		      wizardStack.push(page);
    			  showWizardPage(page,$scope);
          }
    		};
    		
    		this.startCustomWizard = function(pageId,pageInput,pageOptions){
    		  if(customTransition){
    			  $scope.showCustomPage(pageId,pageInput,pageOptions);
    		  }
    		};
    		
        this.gotoNextPage = function(e,data){
          if(!customTransition){
    				$scope.showNextPage();
          }
    		};
    		
				this._handleWizardPageBack = function(){
					var pageCtrl = iscWizard.getWizardPageController();
					if(!iscCore.isVoid(pageCtrl)){
						if(angular.isFunction(pageCtrl.handleWizardBack)){
							return pageCtrl.handleWizardBack();							
						}
						else{
							return false;
						}
					}
					else{
						return false;
					}					
				}
				
				this._handleWizardExit = function(){
					var pageCtrl = iscWizard.getWizardPageController();
					if(!iscCore.isVoid(pageCtrl)){
						if(angular.isFunction(pageCtrl.handleWizardExit)){
							return pageCtrl.handleWizardExit();							
						}
						else{
							return false;
						}
					}
					else{
						return false;
					}					
				}
				
				this._exitWizard = function(){
					wizardCtrl.exitState = wizardCtrl.exitState?wizardCtrl.exitState:{};
					wizardCtrl.exitState.force = true;
					$rootScope.$broadcast("$stateChangeStart",wizardCtrl.exitState);					
				}
				
    		this.gotoPreviousPage = function(force){
					if(!force && this._handleWizardPageBack()){
						console.log("Page is stoping the wizard back");
					}else{
						if(!$scope.wizardStack.isEmpty()){							 
							$scope.showPreviousPage();	
						}
						else if(force){
								$rootScope.$broadcast('$backButtonClicked',{force:force});
						}
						
					}    				
    		};
    		
    		this.gotoCustomPage = function(pageId,pageInput,pageOptions){
    		  if(customTransition){
    				$scope.showCustomPage(pageId,pageInput,pageOptions);
    		  } 
    		};
    		
    		this.finishWizard = function(e,data){
    				$scope.finishWizard(data);
    		};
    		
    		this.closeWizard = function(e,data){
    				$scope.closeWizard(data);
    		};
    		
    		$scope.showNextPage = function(){
    		  var currentPage = wizardStack.length();
    		  console.log("currentPage :: "+currentPage);
    		  var page = {pageConfig:$scope.pages[currentPage],pageInput:null,pageOptions:null};
  		    wizardStack.push(page);
  		    $scope.wizardAction = "wizardNext";
  		    iscWizard._setWizardAction("NEXT");
  		    showWizardPage(page,$scope);
        };
        
    		$scope.showPreviousPage = function(){
  		    $scope.wizardAction = "wizardPrevious";
  		    iscWizard._setWizardAction("PREVIOUS");
  		    if(!wizardStack.isEmpty()){
  		      showWizardPage(wizardStack.pop(),$scope);
  		    }
        };
    		
    		$scope.showCustomPage = function(pageId,pageInput,pageOptions){
    		  iscWizard._setWizardAction("NEXT");
    		  var page = {pageConfig:$scope.pageRegistry[pageId],pageInput:pageInput,pageOptions:pageOptions};
					if(pageOptions && pageOptions.removeCurrent){
							delete pageOptions.removeCurrent;
							wizardStack.pop();
					}
    		  wizardStack.push(page);
    		  showWizardPage(page,$scope);
    		};
    	
    	  $scope.finishWizard = function(){
    	    wizardStack.clear();
    	    iscWizard._setWizardAction("FINISH");
    	    var page = {pageConfig:{templateUrl:$scope.wizardFinishTemplateUrl,controller:$scope.wizardFinishController},pageInput:null,pageOptions:null};
          showWizardPage(page,$scope);
    	  };
    	  
    	  $scope.closeWizard = function(){
    	    wizardStack.clear();
    	    iscWizard._setWizardAction("CLOSE");
    	    var page = {pageConfig:{templateUrl:$scope.wizardFinishTemplateUrl,controller:$scope.wizardFinishController},pageInput:null,pageOptions:null};
          showWizardPage(page,$scope);
    	  };
      }]
    };
  
  }]);
})(window.iscCore);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp.  2015, 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/

/**
 * @ngdoc directive
 * @name iscAddressCapture
 *
 * @description
 * Used to capture address.The address capture template is loaded based on country selection.
 * By default template for US is loaded.
 * If initiated via event call, the directive can perform verification of the address by calling verifyAddress API.
 * The directive auto populates City and State value if valid ZipCode is provided.

 *
 * @example
 * <isc-Address-Capture show-defaultbillto="true" show-defaultshipto="false" hide-contact="false" hide-shipaddress="false" 
 * person-info="ui.personInfo" country-list="ui.CountryList">  </isc-Address-Capture>
 *
 * @param {Object} personInfo Object containing address information to be displayed.
 * @param {Object} countryList Object List of countries. Default selection is 'US'.
 * @param {Boolean} hideContact Used to hide/show section containing FirstName,LastName,DayPhone,EMailID 
 * @param {Boolean} hideShipaddress Used to hide/show section containing defaulting of shipping and billing address. 
 * @param {Boolean} showDefaultbillto Used to hide/show check box to default billing address. 
 * @param {Boolean} showDefaultshipto Used to hide/show check box to default shipping address. 
 * @param {String} identifier Id for the directive instance.  
 *
 *
 * @emits AddressVerified This event is emitted  with the result of address verification output.
 *        The params passed to calling view included 'State' key which takes either MULTI_ADDRESS/SINGLE_ADDRESS.
 *        MULTI_ADDRESS implies address verification returned address which are similar to address being verified.
 *		  A selection is warranted in this case.
 *        SINGLE_ADDRESS implies single verified address was retuned by verifyAddress API.	  
 * @listens callVerifyAddress On calling this lisneter the directive performs address verification. The result of which is passed 
 *          on to the calling view by way of $emit - "AddressVerified". 
 */



angular.module('isc.shared').directive('iscAddressCapture', ['iscI18n',function(iscI18n) {
  return {
  
		scope: {
		  countryList: '=',
          personInfo:'=',
          hideShipaddress:'=',
		  hideContact:'=',
          showDefaultbillto:'=',
          showDefaultshipto:'=',
          addressTypeBundlekey:'@',
          identifier:'=?',
          uniqueIdSuffix:'=?'
		},
		
	 
  
      controller:['$scope','iscMashup','supportedLocale','iscObjectUtility',function($scope,iscMashup,supportedLocale,iscObjectUtility){
	  
      	var originalPersonInfoInput = angular.copy($scope.personInfo);
		$scope.displayTemplateUrl = "";
		$scope.verifyAddressUrl='./shared/address/address-capture/verifyAddress.tpl.html';
		$scope.errorSection='./shared/address/address-capture/verifyAddressError.tpl.html';
		$scope.verifiedAddress = {};
		$scope.stateList = null;
		$scope.DefaultStateSelectionText = iscI18n.translate('address.LABEL_State_Selection');
		
		if(!$scope.identifier){
			$scope.identifier = '';
		}
		if(!$scope.uniqueIdSuffix){
      		$scope.uniqueIdSuffix = 'address_capture';
      	}
		if(!$scope.personInfo){
			$scope.personInfo = {};
		}
		
		
		if(!$scope.personInfo.IsDefaultShippingAddress){
		   $scope.personInfo.IsDefaultShippingAddress = "N";
		}else if(!$scope.personInfo.IsDefaultBillingAddress) {
		    $scope.personInfo.IsDefaultBillingAddress = "N";
		}else{
			$scope.showDefaultbillto = true;
		}
		
		
		$scope.init = function(){
				  if(!$scope.countryList){
					 var mashupInput = {};
					 mashupInput.CommonCode ={};
					 mashupInput.CommonCode.CodeType = "COUNTRY";		 
					 iscMashup.callSimpleMashup($scope,"wsccommon_getCountryList", mashupInput,{}).then($scope.successHandler.bind($scope),$scope.failureHandler.bind($scope));
				}
				 
				  
				  if(iscCore.isVoid($scope.addressTypeBundlekey)){
					  $scope.addressTypeBundlekey = 'globals.LABEL_ShippingAddress';
				  }
				 
				
				$scope.country = "";
				if(!$scope.country){
					$scope.country = {}
					if(!$scope.personInfo.Country){
						$scope.country.CodeValue = supportedLocale.getDefaultLocale();
					}
					else {
						$scope.country.CodeValue = $scope.personInfo.Country;
					}
				}
		}
		
		$scope.intiStateValue = function(stateVal){
			if((!$scope.personInfo.State || $scope.personInfo.State === "") && stateVal){
				$scope.personInfo.State = stateVal;
			}
		}
		
		
		
		$scope.$watch("country",function(newValue){
		
		    
		    var isSupported = supportedLocale.isLocaleSupported($scope.country.CodeValue);
			if(isSupported){
			   var locale = $scope.country.CodeValue;
			}else{
			   var locale = supportedLocale.getDefaultLocale();
			}
		
			$scope.displayTemplateUrl = './shared/address/address-capture/templates/'+locale+'/address-capture.tpl.html';
			if(!$scope.personInfo.Country || $scope.personInfo.Country != $scope.country.CodeValue){
				$scope.personInfo.Country = $scope.country.CodeValue;
			}
			if(!originalPersonInfoInput || !originalPersonInfoInput.Country || !originalPersonInfoInput.Country === $scope.personInfo.Country){
				$scope.personInfo.State = "";
			}
			$scope.getStateList($scope.country);
			
		});
		
		$scope.$watch("personInfo.Country",function(newValue){
		
		    if($scope.personInfo.State && !$scope.personInfo.State.RegionName){//new PersonInfo record being set on directive, hence change the originalPersonInfo
		    	originalPersonInfoInput = angular.copy($scope.personInfo);
		    }
		    var isSupported = supportedLocale.isLocaleSupported($scope.country.CodeValue);
			if(isSupported){
			   var locale = $scope.country.CodeValue;
			}else{
			   var locale = supportedLocale.getDefaultLocale();
			}
		
			$scope.displayTemplateUrl = './shared/address/address-capture/templates/'+locale+'/address-capture.tpl.html';
			if($scope.personInfo.Country && $scope.personInfo.Country != $scope.country.CodeValue){
				for(var j = 0; j < $scope.countryList.length; j++){
					var countryObj = $scope.countryList[j];
					var coutnryName = countryObj.CodeValue;
					if($scope.personInfo.Country === coutnryName){
						$scope.country = countryObj;
					}
				}
			}
		});
		
		$scope.$watch("personInfo.State",function(newValue){
			if($scope.stateList && !newValue.RegionName){
				for(var j = 0; j < $scope.stateList.length; j++){
					var region = $scope.stateList[j];
					var regionName = region.RegionName;
					if($scope.personInfo.State === regionName){
						$scope.personInfo.State = region;
					}
				}
			}
		});
		
		$scope.setFormScope = function(formScope){
		
		  $scope.formScope = formScope;
		
		},
		
		
		$scope.getCountryList = function (){
		 
         var mashupInput = {};
			 mashupInput.CommonCode ={};
			 mashupInput.CommonCode.CodeType = "COUNTRY";		 
		     iscMashup.callSimpleMashup($scope,"wsccommon_getCountryList", mashupInput,{}),then($scope.successHandler.bind($scope),$scope.failureHandler.bind($scope));
		 
		},

		$scope.getStateList = function(country){
          	 	
		     //console.log("inside state list");
			 var mashupId ="addressCapture_getStateList";
			 
			 var mashupInput = {};
			 mashupInput.Region ={};
			 mashupInput.Region.Country = country.CodeValue;
				
			 
			 iscMashup.callSimpleMashup($scope,mashupId, mashupInput,{}).then($scope.successHandler.bind($scope),$scope.failureHandler.bind($scope));	
		},
		
		
		$scope.$on("callVerifyAddress",function(event,args){
		    
			 $scope.params = args;
		     $scope.verifyaddress();
		});
		
		
		
		$scope.verifyaddress =  function (){
		
		         if($scope.formScope.addressCapture.$invalid){
					   $scope.errorText = iscI18n.translate('screenErrors.Error_ScreenInError');
					   return false;
				 }else{
				      $scope.errorText ="";
				 
				 }


			     var obj = angular.copy(this.personInfo);
				 obj  = iscObjectUtility.sanitizeObject(obj);
			     var mashupInput = {};
			     mashupInput.PersonInfo = {};
				 mashupInput.PersonInfo = obj;
				 if($scope.stateList && mashupInput.PersonInfo.State && mashupInput.PersonInfo.State.RegionName){
				 	mashupInput.PersonInfo.State = mashupInput.PersonInfo.State.RegionName;
				 }
				 delete mashupInput.PersonInfo.IsDefaultBillingAddress;
				 delete mashupInput.PersonInfo.IsDefaultShippingAddress;
				 
			     iscMashup.callSimpleMashup( $scope,"wscaddressCapture_verifyAddress", mashupInput,{}).then($scope.successHandler.bind($scope),$scope.failureHandler.bind($scope)); 
		},
		
		$scope.successHandler = function(response){
		 
		  $scope.initializeErrorFrame();
		  var mashupRefs = response.MashupRefs.MashupRef;
		  for(i=0;mashupRefs[i];i++){
			  if(mashupRefs[i].mashupId){
				  var mashupId = mashupRefs[i].mashupId;
				   if(mashupId == "addressCapture_getStateList"){
				     $scope.processStateListOutput(mashupRefs[i]);
				 }else if (mashupId == "wsccommon_getCountryList"){
				     $scope.processCountryListOutput(mashupRefs[i]);
				 }else if(mashupId == "wscaddressCapture_verifyAddress"){
					 $scope.processVerifyAddressOutput(mashupRefs[i]);		    		  
				 }else if(mashupId == "addressCapture_WSCgetCityStateForZip"){
				     $scope.processGetCityState(mashupRefs[i]);
				 }		

			   }
		   }
		},
		
		
		$scope.getCityState = function ( arg){
		
		   
			 var mashupId = "addressCapture_WSCgetCityStateForZip";
			 
			/*  <Region  RegionSchemaKey="ALL_US" >
             <PersonInfo Country="US" ZipCode="90876"/></Region> */
			 
			 var mashupInput = {};
			 mashupInput.Region ={};
			 mashupInput.Region.RegionSchemaKey=$scope.RegionSchemaKey;
			 mashupInput.Region.PersonInfo = {};
			 mashupInput.Region.PersonInfo.Country=$scope.personInfo.Country;
			 mashupInput.Region.PersonInfo.ZipCode=$scope.personInfo.ZipCode;
				
			 
			 iscMashup.callSimpleMashup($scope,mashupId, mashupInput,{}).then($scope.successHandler.bind($scope),$scope.failureHandler.bind($scope));	
		
		},
		
		
		$scope.processGetCityState = function (mashupRefObj){
		
		     var region = mashupRefObj.Output.Regions;
		     if(region){
			    if(region.RegionSchema){
			    	if($scope.stateList){
					    $scope.personInfo.State = {};
			    		$scope.personInfo.State.RegionName = region.RegionSchema.State;
			    		$scope.personInfo.State.RegionDescription = region.RegionSchema.StateDescription;
			    	}
				    else{
				     	$scope.personInfo.State = region.RegionSchema.State;
				    }
			      	$scope.personInfo.City = region.RegionSchema.City;
				}else{
					if($scope.stateList){
						//$scope.personInfo.State = $scope.stateList[0];
					}
					else {
						//$scope.personInfo.State = "";
					}
				  //$scope.personInfo.City="";
				}
			  }
		   
		},
		
		
		$scope.initializeErrorFrame = function(){
			
			  $scope.AVSMessages = [];
			  $scope.errorText = "";
			  $scope.addressFailedError = "";
			
			
		},
		
		$scope.uiVerifiedAddressSelected = function (verifiedPersonInfo,status,isAddressVerified){
		
		      delete verifiedPersonInfo.OriginalKey;
			  delete verifiedPersonInfo.EnterpriseCode;
			  delete verifiedPersonInfo.$$hashKey;
			  delete verifiedPersonInfo.UserEnteredAddress;
			  delete verifiedPersonInfo.PersonInfoKey;
			  
			  if( angular.isObject(verifiedPersonInfo.State)){
				   verifiedPersonInfo.State = verifiedPersonInfo.State.RegionName;
			  } 
		  
		     $scope.verifiedAddress = verifiedPersonInfo;
			 $scope.verifiedAddress.IsAddressVerified=isAddressVerified;
			 $scope.verifiedAddress.IsDefaultShippingAddress = $scope.personInfo.IsDefaultShippingAddress;
			 $scope.verifiedAddress.IsDefaultBillingAddress =  $scope.personInfo.IsDefaultBillingAddress;
			 $scope.$emit("AddressVerified",{'data':$scope.verifiedAddress,'State':status,'Params':$scope.params,'formScope':$scope.formScope,'identifier':$scope.identifier});
		
		},
		
		
		$scope.processStateListOutput = function (mashupRefObj){
		
		    
		   var regions = mashupRefObj.Output.Regions;
					  
			  if(regions.RegionSchema){
				$scope.stateList = regions.RegionSchema.Region;
				$scope.RegionSchemaKey = regions.RegionSchema.RegionSchemaKey;
				
				if(originalPersonInfoInput && originalPersonInfoInput.State) {
					for(var j = 0; j < $scope.stateList.length; j++){
						var region = $scope.stateList[j];
						var regionName = region.RegionName;
						if(originalPersonInfoInput.State === regionName){
							$scope.personInfo.State = region;
						}
					}
				}
				//if(!$scope.personInfo.State){
					//$scope.personInfo.State = $scope.stateList[0];
				//}
			  }else{
				$scope.stateList = "";
				if(originalPersonInfoInput && originalPersonInfoInput.State){
					if(originalPersonInfoInput.State.RegionName){
						$scope.personInfo.State = originalPersonInfoInput.State.RegionName;
					}
					else {
						$scope.personInfo.State = originalPersonInfoInput.State
					}
				}
				else{
					$scope.personInfo.State = "";
				}
			  }
		
		},
		
		$scope.processCountryListOutput = function(mashupRefObj){
		  var commonCodeList = mashupRefObj.Output;
		  $scope.countryList = commonCodeList.CommonCodeList.CommonCode;
		 },
		
		
		$scope.processVerifyAddressOutput = function(mashupRefObj){
			  
			     var personInfoList = mashupRefObj.Output.PersonInfoList;
				 
				/*var snd = angular.copy(personInfoList.PersonInfo[0]);
				 snd.FirstName="First";
				 snd.LastName="Last";
				 snd.AddressLine1 = "Park Joe";
				 snd.DayPhone="3667777";
				 snd.ZipCode="56667";
				 personInfoList.PersonInfo[1] = snd;*/
				 
				 
				 if(personInfoList.Status == "VERIFIED"){
						
						 if(personInfoList.PersonInfo.length > 1){
							$scope.showPossibleoptions = true;
							$scope.addresslistFromue = personInfoList.PersonInfo;
							$scope.uiVerifiedAddressSelected(personInfoList.PersonInfo[0],"MULTI_ADDRESS",'Y');
						 }else if (personInfoList.PersonInfo.length == 1 && personInfoList.ProceedWithSingleAVSResult == "Y"){ 
							$scope.uiVerifiedAddressSelected(personInfoList.PersonInfo[0],"SINGLE_ADDRESS",'Y');

						 }else if (personInfoList.PersonInfo.length == 1 && personInfoList.ProceedWithSingleAVSResult == "N"){ 
							$scope.showPossibleoptions = true;
							$scope.addresslistFromue = personInfoList.PersonInfo;
							$scope.uiVerifiedAddressSelected(personInfoList.PersonInfo[0],"MULTI_ADDRESS",'Y');

						 }else if (personInfoList.PersonInfo.length == 1){ 
							$scope.uiVerifiedAddressSelected(personInfoList.PersonInfo[0],"SINGLE_ADDRESS",'N');

						 }else{
						   $scope.uiVerifiedAddressSelected(angular.copy($scope.personInfo),"SINGLE_ADDRESS",'N');
						 }
						
					}else if (personInfoList.Status == "FAILED"){
						$scope.addressFailedError = iscI18n.translate('address.LABEL_Address_Failed');
						if(personInfoList.AddressVerificationResponseMessages){
						  $scope.AVSMessages = personInfoList.AddressVerificationResponseMessages.AddressVerificationResponseMessage; 
					    }	
					}else if (personInfoList.Status == "AVS_DOWN"){
						//$scope.errorText = iscI18n.translate('address.LABEL_Address_AVSDown');
						$scope.uiVerifiedAddressSelected(angular.copy($scope.personInfo),"SINGLE_ADDRESS",'N');
						
					}else if (personInfoList.Status == "UE_MISSING"){
						//$scope.errorText = iscI18n.translate('address.LABEL_Address_UENotImpl');
						$scope.uiVerifiedAddressSelected(angular.copy($scope.personInfo),"SINGLE_ADDRESS",'N');
					}
				   
				  			
			
		},
		
		$scope.failureHandler = function(response){
		 
		  console.log("request unsuccessful");
		  
		},
		
		$scope.uiEditAddress = function(){
		
		   $scope.showPossibleoptions = false;
		   $scope.uiVerifiedAddressSelected(angular.copy($scope.personInfo),"MODIFY_ADDRESS",'N');
		   
		},
		
		$scope.uiValidator = function(validationResponseObj, angularErrorObj, modelValue, viewValue) {
		
			
			if (angularErrorObj.required) {
				validationResponseObj.booleanResponse = false;
				validationResponseObj.errorMesssage = iscI18n.translate('datatype.GenericRequired');
			}else if (angularErrorObj.email || angularErrorObj.pattern){
				validationResponseObj.booleanResponse = false;
				validationResponseObj.errorMesssage = iscI18n.translate('datatype.EmailFormat');
			  
			}else if(angularErrorObj.iscDatatypeValidator){
				validationResponseObj.booleanResponse = false;
				validationResponseObj.errorMesssage = iscI18n.translate('datatype.Maxlength');
			
			}
			return validationResponseObj;
		},
		
		
	  
	  $scope.init();
	}],
	 template:'<div ng-include="errorSection" role="alert" aria-live="assertive"></div>'
	            +'<div  ng-form="addressCapture" class="address-capture">'
					+'<div class="form-group">'
					  //+'<label for="countrySelection" class="comapps-label a11y-hidden-label" isc-i18n="address.LABEL_Country_Address"></label>'
					   +'<div ng-show="!showPossibleoptions" class="text-box">'
					  	//	+'<select class="form-control" ng-model="country" id="countrySelection" ng-options="country.CodeLongDescription for country in countryList track by country.CodeValue">'
					  	//	+'</select>'
							+'<isc-input'
							+'	input-config-id = "countrySelection_{{uniqueIdSuffix}}"'
							+'	input-config-name = "combobox"'
							+'	input-config-ng-model = "country"'
							+'	input-config-ng-options = "country.CodeLongDescription for country in countryList track by country.CodeValue"'
							+'	label-config-isc-i18n = "address.LABEL_Country_Address">'
							+'</isc-input>'
					   +'</div>'
					+'</div>'	 
					+'<div ng-if="!showPossibleoptions" ng-include="displayTemplateUrl"></div>'
					+'<div ng-if="showPossibleoptions" ng-include="verifyAddressUrl"></div>'
				+'</div>'
    
  };
}]);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
/**
 * @ngdoc directive
 * @name iscAddressDisplay
 *
 * @description
 * Used to display address.
 *
 * @example
 * <isc-Address-Display person-Info="personRecord.PersonInfo" display-Format="long" > </isc-Address-Display>
 *
 * @param {Object} personInfo Object containing address information to be displayed.
 * @param {String} displayFormat String to know which address display format to choose. Supported values are 'long','short' and 
           mini. Default value is 'long'. 
 */


angular.module('isc.shared').directive('iscAddressDisplay', function() {
  return {
    scope: {
	  personInfo: '=personInfo',
      addressType: '@',
      displayFormat:'@'	  
      
    },

	controller:['$scope','supportedLocale','iscI18n',function($scope,supportedLocale,iscI18n){
		$scope.displayTemplateUrl = "";
		$scope.addressDisplaySeperator = iscI18n.translate('globals.AddressDisplaySeperator');
		
		$scope.getFormattedDisplay = function(a,b,c){
		
		   var str = "";
		   
		   if(a){
		       str = a;
			   if(b){
				   str = str+$scope.addressDisplaySeperator+b;
			   }
			   if(c){
				   str = str+$scope.addressDisplaySeperator+c;
			   }
			   return str;
		   }else if(b){
		          str = b;
		       if(c){
				  str = str+$scope.addressDisplaySeperator+c;
			   } 
			   return str;
		   }else if (c){
		          str = c;
		       return str;
		   }
		   return str;
		
		
		};
		
		var initializePersonInfo = function(personInfo) {
			
			if(!personInfo){
				$scope.personInfo = {};
			}
			
			if(!$scope.personInfo.Country){
			   $scope.personInfo.Country = ""; 
			}
			
			if(angular.isObject($scope.personInfo.State)){
			   $scope.personInfo.State = $scope.personInfo.State.RegionName;
			}
			
		};
		
		$scope.$watch("personInfo",initializePersonInfo);
		
		
		$scope.$watch("personInfo.Country",function(newValue){
		   
		    
		    var isSupported = supportedLocale.isLocaleSupported(newValue);
			if(isSupported){
			   var locale = newValue;
			}else{
			   var locale = supportedLocale.getDefaultLocale();
			}
		
		    if(!$scope.displayFormat){
			   $scope.displayFormat = 'long';
			} 
			$scope.displayTemplateUrl = './shared/address/address-display/templates/'+$scope.displayFormat+'/'+locale+'/address-display.tpl.html';
		});
		
		initializePersonInfo($scope.personInfo);
	  
	}],
	template:"<div ng-if='displayTemplateUrl' ng-include='displayTemplateUrl'></div>"
    
  };
});

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp.  2015, 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
/**
 * @ngdoc directive
 * @name iscAddressFilter
 *
 * @description
 * Used as input template to search based on address attributes like Country,Zip Code etc
 *
 * @example
 * <isc-Address-Filter person-info="ui.personInfo" country-list="ui.CountryList" > </isc-Address-Filter>
 *
 * @param {Object} personInfo Object containing search parameters.
 * @param {String} countryList List of countries. Default selection is 'US'.
 */

angular.module('isc.shared').directive('iscAddressFilter', function() {
  return {
  
		scope: {
		  countryList: '=?',
          personInfo:'='	  
		},
  
      controller:['$scope','iscMashup','supportedLocale','iscI18n',function($scope,iscMashup,supportedLocale,iscI18n){
      	var originalPersonInfoInput = $scope.personInfo;
		$scope.displayTemplateUrl = "";
		$scope.DefaultStateSelectionText = iscI18n.translate('address.LABEL_State_Selection');
		if(!$scope.personInfo){
			$scope.personInfo = {};
		}
		
		$scope.stateList = null;
		
		$scope.init = function(){
		  if(!$scope.countryList){
		     var mashupInput = {};
  			 mashupInput.CommonCode ={};
  			 mashupInput.CommonCode.CodeType = "COUNTRY";		 
  		     iscMashup.callSimpleMashup($scope,"wsccommon_getCountryList", mashupInput,{}).then($scope.successHandler.bind($scope),$scope.failureHandler.bind($scope));
  		}
  		
  		$scope.country = "";
  		if(!$scope.country){
  		    $scope.country = {}
  		    if(!$scope.personInfo.Country){
  		    	$scope.country.CodeValue = supportedLocale.getDefaultLocale();
  		    }
  		    else {
  		    	$scope.country.CodeValue = $scope.personInfo.Country;
  		    }
  		}
		}
		
		
		$scope.$watch("country",function(newValue){
		
		    var isSupported = supportedLocale.isLocaleSupported($scope.country.CodeValue);
			if(isSupported){
			   var locale = $scope.country.CodeValue;
			}else{
			   var locale = supportedLocale.getDefaultLocale();
			}
			
		
			$scope.displayTemplateUrl = './shared/address/address-filter/templates/'+locale+'/address-filter.tpl.html';
			if(!$scope.personInfo.Country || $scope.personInfo.Country != $scope.country.CodeValue){
				$scope.personInfo.Country = $scope.country.CodeValue;
			}
			$scope.getStateList($scope.country, $scope.personInfo.State);
		});
		
		
		$scope.getCountryList = function (){
		 
         var mashupInput = {};
			 mashupInput.CommonCode ={};
			 mashupInput.CommonCode.CodeType = "COUNTRY";		 
		  
		     iscMashup.callSimpleMashup($scope,"wsccommon_getCountryList", mashupInput,{}).then($scope.successHandler.bind($scope),$scope.failureHandler.bind($scope));
		 
		},
		
		$scope.getStateList = function(country){
          	 	
		     console.log("inside state list");
			 var mashupId ="addressCapture_getStateList";
			 
			 var mashupInput = {};
			 mashupInput.Region ={};
			 mashupInput.Region.Country = country.CodeValue;
				
			 
			 iscMashup.callSimpleMashup($scope,mashupId, mashupInput,{}).then($scope.successHandler.bind($scope),$scope.failureHandler.bind($scope));	
		},
		
		$scope.getCityState = function ( arg){
		
		   
			 var mashupId = "addressCapture_WSCgetCityStateForZip";
			 
			/*  <Region  RegionSchemaKey="ALL_US" >
             <PersonInfo Country="US" ZipCode="90876"/></Region> */
			 
			 var mashupInput = {};
			 mashupInput.Region ={};
			 mashupInput.Region.RegionSchemaKey=$scope.RegionSchemaKey;
			 mashupInput.Region.PersonInfo = {};
			 mashupInput.Region.PersonInfo.Country=$scope.personInfo.Country;
			 mashupInput.Region.PersonInfo.ZipCode=$scope.personInfo.ZipCode;
				
			 
			 iscMashup.callSimpleMashup($scope,mashupId, mashupInput,{}).then($scope.successHandler.bind($scope),$scope.failureHandler.bind($scope));	
		
		},
		
		$scope.successHandler = function(response){
		  
		  var mashupRefObj = response.MashupRefs.MashupRef[0];
		  if(mashupRefObj.mashupId){
			  var mashupId = mashupRefObj.mashupId;
			   if(mashupId == "addressCapture_getStateList"){
				  var regions = mashupRefObj.Output.Regions;
				  if(regions.RegionSchema){
				      $scope.RegionSchemaKey = regions.RegionSchema.RegionSchemaKey;
				  }
				  
				  if(regions.RegionSchema){
					$scope.stateList = regions.RegionSchema.Region;
					if(originalPersonInfoInput.State && originalPersonInfoInput.Country == $scope.personInfo.Country){
						for(var j = 0; j < $scope.stateList.length; j++){
        					var region = $scope.stateList[j];
        					var regionName = region.RegionName;
        					if(originalPersonInfoInput.State === regionName){
        						$scope.personInfo.State = region;
        					}
        				}
					}
					//if(!$scope.personInfo.State){
    					//$scope.personInfo.State = $scope.stateList[0];
    				//}
				  }else{
					$scope.stateList = null;
					if(!iscCore.isVoid(originalPersonInfoInput.State) && originalPersonInfoInput.Country == $scope.personInfo.Country){
						$scope.personInfo.State = originalPersonInfoInput.State;
					}
					else{
						$scope.personInfo.State = null;
					}
				  }
			 }else if (mashupId == "wsccommon_getCountryList"){
			   var commonCodeList = mashupRefObj.Output;
			   $scope.countryList = commonCodeList.CommonCodeList.CommonCode;
			 }else if(mashupId == "addressCapture_WSCgetCityStateForZip"){
				     $scope.processGetCityState(mashupRefObj);
			 }
		 }
		},
		
		$scope.processGetCityState = function (mashupRefObj){
		
		     var region = mashupRefObj.Output.Regions;
		     if(region){
			    if(region.RegionSchema){
			    	if($scope.stateList){
					    $scope.personInfo.State = {};
			    		$scope.personInfo.State.RegionName = region.RegionSchema.State;
			    		$scope.personInfo.State.RegionDescription = region.RegionSchema.StateDescription;
			    	}
				    else{
				     	$scope.personInfo.State = region.RegionSchema.State;
				    }
			      	$scope.personInfo.City = region.RegionSchema.City;
				}else{
					if($scope.stateList){
						//$scope.personInfo.State = $scope.stateList[0];
					}
					else {
						//$scope.personInfo.State = "";
					}
				  //$scope.personInfo.City="";
				}
			  }
		   
		},
		
		$scope.failureHandler = function(response){
		 
		  console.log("request unsuccessful");
		}
	  
	  $scope.init();
	}],

	 template:'<div ng-form="addressFilter" class="address-filter">'
					+'<div class="form-group">'
					  //+'<label for="countrySelection" class="comapps-label a11y-hidden-label" isc-i18n="address.LABEL_Country_Address"></label>'
					   +'<div class="text-box">'
					  		//+'<select class="form-control" ng-model="country" id="countrySelection" ng-options="country.CodeLongDescription for country in countryList track by country.CodeValue">'
					  		//+'</select>'
							+'<isc-input'
							+'	input-config-id = "countrySelection"'
							+'	input-config-name = "combobox"'
							+'	input-config-ng-model = "country"'
							+'	input-config-ng-options = "country.CodeLongDescription for country in countryList track by country.CodeValue"'
							+'	label-config-isc-i18n = "address.LABEL_Country_Address">'
							+'</isc-input>'
					   +'</div>'
					+'</div>'	 
					+'<div ng-if="displayTemplateUrl" ng-include="displayTemplateUrl"></div>'
				+'</div>'
    
  };
});

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp. 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/



/**
 * @ngdoc directive
 * @name iscChangeStoreList
 *
 * @requires iscI18n
 *
 * @restrict E
 *
 * @description
 * Store list display
 * @example
 * <isc-change-store-list node="node" store="ui.searchedStore" store-Desc="ui.searchedStoreDesc" >
 * </isc-change-store-list> 
 *
 *	
 * @param {Object} node Current node in the output list of nodes.
 * @param {Object} store node/store selected in radio button.
 * (default selection from the list of stores)
 * @param {String} storeDesc Description of the selected store in the list.
 */

(function(iscCore){
	angular.module('isc.shared').directive('iscChangeStoreList',['iscI18n',function(iscI18n) {

		return {
			restrict: 'E',
			scope: {
				mode:"@?",
				store:'=',
				highlightedStore:'=',
				nodeModel:'=',
				onStoreHighlight:"&",
				onStoreSelection:"&",
				onNextPageCall:"&",
				apiCallInProgress:"=",
				totalStores:"=",
				scrollContainer:"@?"
			},
			
			templateUrl: './shared/appointment/store-list/store-list.tpl.html',
			
			controller:["$scope", "iscScreen", "iscMashup", "iscResourcePermission","$filter", "iscModal", "iscI18n","iscState", "$timeout", "iscDomUtility",function($scope, iscScreen, iscMashup, iscResourcePermission, $filter, iscModal, iscI18n,iscState, $timeout, iscDomUtility){
						
				$scope.uiHighlightStore = function(storeSel) {
					$scope.highlightedStore = storeSel;
					$scope.onStoreHighlight({storeHightlighted:{mode:$scope.mode, highStore:storeSel}});
				};
				
				$scope.uiSelectHighlightedStore = function() {
					$scope.store = $scope.highlightedStore;
					$scope.highlightedStore = {};
					$scope.onStoreSelection();
				};

				$scope.uiNextStoresValidator = function(){
					if($scope.apiCallInProgress || $scope.oTotalStores >= $scope.nodeModel.GetSurroundingNodeList.NodeList.Node.length)
						return false;
					return true;
				};

				$scope.uiFetchNextStores = function(){
					$scope.onNextPageCall({nextCallInput:{mode:$scope.mode}});
				};

			}]
		};
	}]);
})(window.iscCore);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp.  2015, 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/

/**
 * @ngdoc directive
 * @name iscPadss
 *
 * @description
 * Used to capture a credit card number field by creating an iframe widget which uses SSDCS. 
 * Handles all SSDCS related events and error and success result scenarios.
 *
 * @example
 * <isc-padss ssdcs-data-type="'ssdcsCreditCardNumber'" placeholder="'payment.LABEL_CreditCardNo'" 
 * ssdcs-display-value="paymentMethod.DisplayCreditCardNo" ssdcs-css-url="'/ngstore/style/blue/wsc-padss.css'"
 * payment-type="paymentMethod.PaymentType" ssdcs-error-method="ssdcsErrorMethod(isDigestRequired)" 
 * ssdcs-auto-submit="'Y'" re-init-padss="reInitPadss" ssdcs-token="paymentMethod.CreditCardNo" 
 * call-back-success-flag="ssdcsup" payment-method="paymentMethod">
 * </isc-padss>
 *
 * @param {String} ssdcsDataType identifier of data type which SSDCS understands.
 * @param {String} placeholder bundle entry for placeholder text for the field.
 * @param {Object} ssdcsDisplayValue model object to bind DisplayValue of the number.
 * @param {String} ssdcsCssUrl relative URL for the css file to be applied on the document object of the PADSS iframe. 
 * @param {Object} ssdcsToken model object to bind Token value of the number. 
 * @param {String} paymentType of the Payment method. 
 * @param {Object} ssdcsErrorMethod function object to bind to when there is any kind of communication error to SSDCS server. 
 * @param {String} ssdcsAutoSubmit flag to enable auto-submit, to enabled tokenization, on tab out of the field. 
 * @param {Object} reInitPadss object to enable re-initialization of the PADSS field by controlling the object value from parent directive/screen. 
 * @param {Object} paymentMethod model object.  
 *
 */

angular.module('isc.shared').directive('iscPadss', ['$http', '$timeout', 'iscAppInfo', 'iscI18n', 'iscHttpRequest', function($http, $timeout, iscAppInfo, iscI18n, iscHttpRequest) {
  return {
  
		scope: {
		 frameId: '=?',
				
		frameTitle: '=',
		
		ssdcsDataType : '=',
		
		ssdcsDisplayValue : '=',
		
		ssdcsCssUrl : '=',
		
		ssdcsToken : '=',
		
		ssdcsTabIndex : '=?',
		
		ssdcsAutoSubmit : '=',
		
		paymentType : "=",
		
		callBackSuccessFlag : '=',
		
		paymentMethod : '=',
		
		frameSrc : '=',
		
		reInitPadss  : '=',
		
		ssdcsErrorMethod : '&',
		
		placeholder : '='
		
		},
  
      controller:['$http', 'iscAppInfo', 'iscI18n', '$scope', '$rootScope', 'iscHttpRequest' ,function($http, iscAppInfo, iscI18n, $scope, $rootScope, iscHttpRequest){
      	$scope.frameId = "padssIframe"+new Date().getTime();
      	if(!$scope.paymentMethod){
      		paymentMethod = {'PaymentMethod':{}};
      	}
      	if(!$scope.ssdcsTabIndex){
			$scope.ssdcsTabIndex = "0";
		}
		if(!$scope.ssdcsDisplayValue){
			$scope.ssdcsDisplayValue = "";
		}
		if(!$scope.ssdcsToken){
			$scope.ssdcsToken = "";
		}
		$scope.displayTemplateUrl = "";
		$scope.padssOnload = function(element){
			if($scope.ssdcsAutoSubmit=="Y"){
				try {
					var framename = $scope.frameId;
					//Get iframe
					var padssIframe = window.frames[framename];
					var padssdocument = null;
					if(padssIframe){
						if(padssIframe.document){
							padssdocument = padssIframe.document;
						}
						else if (padssIframe.contentWindow && padssIframe.contentWindow.document){
							padssdocument = padssIframe.contentWindow.document;
						}
					}
					if(padssIframe && padssdocument && padssdocument.ssdcs){
						var form = padssdocument.ssdcs;					
						var state = form.ssdcsResultCode.value;
						if(state){
							$scope._success();
						}
						else{
							$scope._failure();
						}
					}
				} catch (ex){
					//$scope.callBackSuccessFlag.ServerStaus = 'N';
					console.log(ex);
					$scope.ssdcsErrorMethod({isDigestRequired:true});
				}
			}
		},
		
		$scope._setSsdcsAutoSubmitAttr = function(){
			if($scope.ssdcsAutoSubmit!=null){
				if($scope.ssdcsAutoSubmit == "true" || $scope.ssdcsAutoSubmit == "Y" || $scope.ssdcsAutoSubmit == "y"){
					$scope.ssdcsAutoSubmit="Y";
				}
				else if($scope.ssdcsAutoSubmit == "false" || $scope.ssdcsAutoSubmit == "N" || $scope.ssdcsAutoSubmit == "n"){
					$scope.ssdcsAutoSubmit="N";
				}
			}
			else{
				$scope.ssdcsAutoSubmit="N";
			}
		},
		
		$scope._reloadIframeWithNewAccessToken = function(){
			
			var dataToPost = {
				method: "POST",
				url: iscAppInfo.getApplicationContext() + '/scuiimpl/padssCreateNewAccessToken.do',
				headers: {"Content-Type": "application/x-www-form-urlencoded"}
			};
			
			dataToPost.data =  iscHttpRequest.addAdditionalParams("", "POST", iscAppInfo.getApplicationContext() + '/scuiimpl/padssCreateNewAccessToken.do');;
			//console.log(scControllerData);
			var promise = $http(dataToPost).
			then(
				function(response){
					var padssIframe = window.frames[$scope.frameId];
					var padssdocument = null;
					if(padssIframe){
						if(padssIframe.document){
							window.frames[$scope.frameId].document.ssdcs.ssdcsAuthenticationToken.value = response.data.replace(/(\r\n|\n|\r)/gm, "");
						}
						else if (padssIframe.contentWindow && padssIframe.contentWindow.document){
							window.frames[$scope.frameId].contentWindow.document.ssdcs.ssdcsAuthenticationToken.value = response.data.replace(/(\r\n|\n|\r)/gm, "");
						}
					}
				},
				function(response){
					var padssIframe = window.frames[$scope.frameId];
					var padssdocument = null;
					var failReason = null;
					if(padssIframe){
						if(padssIframe.document){
							failReason = window.frames[$scope.frameId].document.ssdcs.ssdcsFailReason.value;
						}
						else if (padssIframe.contentWindow && padssIframe.contentWindow.document){
							failReason = window.frames[$scope.frameId].contentWindow.document.ssdcs.ssdcsFailReason.value;
						}
					}
		            //$scope.callBackSuccessFlag.ServerStaus = 'N';
		            //$scope.ssdcsErrorMethod();
				}
			);
			//return promise;
		},
		
		$scope._success = function(){
			$scope.callBackSuccessFlag.ServerStaus = 'Y';
			var framename = $scope.frameId;
			//Get iframe
			var padssIframe = window.frames[framename];
			var padssdocument = null;
			if(padssIframe){
				if(padssIframe.document){
					padssdocument = padssIframe.document;
				}
				else if (padssIframe.contentWindow && padssIframe.contentWindow.document){
					padssdocument = padssIframe.contentWindow.document;
				}
			}
			var form = padssdocument.ssdcs;
			var state = padssdocument.ssdcs.ssdcsResultCode.value;
			var resultCode = padssdocument.ssdcs.ssdcsResultCode.value;
			var displayValue = padssdocument.ssdcs.ssdcsDisplayValue.value;
			var token = padssdocument.ssdcs.ssdcsToken.value;
			if(resultCode == "FAIL"){
				var failureReason = padssdocument.ssdcs.ssdcsFailReason.value;
				if(resultCode === "FAIL"){
					if(failureReason === "INVALID_SESSION"){
						$scope._reloadIframeWithNewAccessToken();
					}			
				}
			}
			$scope._ssdcsCallBackSuccess(padssdocument.ssdcs);
		},
		
		$scope._failure = function(){
			//$scope.callBackSuccessFlag.ServerStaus = 'N';
			$scope.ssdcsErrorMethod({isDigestRequired:true});
		},
		
		$scope._ssdcsCallBackSuccess = function(ssdcsElem){
			var result = ssdcsElem.ssdcsResultCode.value;
            var cardType = "";
            var cardNo = "";
            var displayCardNo = "";
            if (result && result == "INITIAL") {
            	if($scope.paymentType.PaymentTypeGroup === 'CREDIT_CARD' || $scope.paymentMethod.PaymentTypeGroup === 'CREDIT_CARD'){
		            cardType = $scope.paymentMethod.CreditCardType;
	                cardNo = $scope.paymentMethod.CreditCardNo;
	                displayCardNo = $scope.paymentMethod.DisplayCreditCardNo;
		        }
	            else if($scope.paymentType.PaymentTypeGroup === 'STORED_VALUE_CARD' || $scope.paymentMethod.PaymentTypeGroup === 'STORED_VALUE_CARD'){
	            	cardNo = $scope.paymentMethod.SvcNo;
	                displayCardNo = $scope.paymentMethod.DisplaySvcNo;
	            }
                ssdcsElem.ssdcsDataToTokenize.placeholder = iscI18n.translate($scope.placeholder);
                ssdcsElem.ssdcsDataToTokenize.autocomplete = "off";
                ssdcsElem.ssdcsDataToTokenize.focus();
            }
            if (result && result == "SUCCESS") {
                var additionalResultsData = ssdcsElem.ssdcsAdditionalResultData.value;
                var additionalResults = null;
                additionalResults = $scope.splitPADSSData(
                additionalResultsData);
                cardType = additionalResults["CardType"];
                cardNo = ssdcsElem.ssdcsToken.value;
                displayCardNo = ssdcsElem.ssdcsDisplayValue.value;
                ssdcsElem.ssdcsDataToTokenize.autocomplete = "off";
            }
            //handle based on payment type (Credit Card or Store Value Card)
            if($scope.paymentType.PaymentTypeGroup === 'CREDIT_CARD' || $scope.paymentMethod.PaymentTypeGroup === 'CREDIT_CARD'){
	            $scope.paymentMethod.CreditCardType = cardType;
	            $scope.paymentMethod.CreditCardNo = cardNo;
	            $scope.paymentMethod.DisplayCreditCardNo = displayCardNo;
            }
            else if($scope.paymentType.PaymentTypeGroup === 'STORED_VALUE_CARD' || $scope.paymentMethod.PaymentTypeGroup === 'STORED_VALUE_CARD'){
            	$scope.paymentMethod.SvcNo = cardNo;
	            $scope.paymentMethod.DisplaySvcNo = displayCardNo;
            }
            
            if (result && result == "FAIL") {
                var failReason = ssdcsElem.ssdcsFailReason.value;
                var failResultDescription = ssdcsElem.ssdcsResultDescription.value;
                if(!(failReason === 'INVALID_DATA' && failResultDescription == 'ssdcsDataToTokenize') 
                && !(failReason === 'INVALID_SESSION')
                && !(failReason === 'TOKENIZATION_FAILED')){
                	 //$scope.callBackSuccessFlag.ServerStaus = 'N';
                	$scope.ssdcsErrorMethod({isDigestRequired:true});
                }
                if(failReason === 'INVALID_DATA'){//Setting invalid data so that parent screen can set the field in error
                	if($scope.paymentType.PaymentTypeGroup === 'CREDIT_CARD' || $scope.paymentMethod.PaymentTypeGroup === 'CREDIT_CARD'){
			            $scope.paymentMethod.CreditCardNo = "INVALID";
		            }
		            else if($scope.paymentType.PaymentTypeGroup === 'STORED_VALUE_CARD' || $scope.paymentMethod.PaymentTypeGroup === 'STORED_VALUE_CARD'){
		            	$scope.paymentMethod.SvcNo = "INVALID";
		            }
                }
                if(ssdcsElem.ssdcsDataToTokenize){
                	ssdcsElem.ssdcsDataToTokenize.autocomplete = "off";
                }
            } 
            $rootScope.$digest();
		},
		
		$scope.splitPADSSData = function(/*String*/input){
			var retVal={};
			if(input){
				var additionalResultsList = null;
				additionalResultsList=input.split(";");
				for (var index=0; index<additionalResultsList.length; index++){
					var token = additionalResultsList[index].split(":");
					if (token[0] !== "") {
						retVal[token[0].toString()] = token[1];
					}
				}
			}
			
			return retVal;
		},
		$scope._isAlive = function(url) {
			var dataToPost = {
				method: "POST",
				url: iscAppInfo.getApplicationContext() + '/scuiimpl/padssIsAlive.do',
				headers: {"Content-Type": "application/x-www-form-urlencoded"}
			};
			
			dataToPost.data =  iscHttpRequest.addAdditionalParams("", "POST", iscAppInfo.getApplicationContext() + '/scuiimpl/padssIsAlive.do');
			var promise = $http(dataToPost).
			then(
				function(response){
					if ( response) {
						response.data = response.data.replace(/(\r\n|\n|\r)/gm, "");
						response.data = response.data.replace(/while\(1\);/,"").trim();						
						response.data = eval("(" + response.data + ")");
						var alive = response.data.response.isAlive;
						if ( alive == "true" ) {
							iscHttpRequest.submitForm({
								url : iscAppInfo.getApplicationContext()+ "/scuiimpl/padssInitializer.do",
								params : {
									'ssdcsDataType' :  $scope.ssdcsDataType,
									'ssdcsDisplayValue' : $scope.ssdcsDisplayValue,
									'ssdcsCssUrl' : $scope.ssdcsCssUrl,
									'ssdcsToken' : $scope.ssdcsToken,
									'ssdcsAutoSubmit' : $scope.ssdcsAutoSubmit,
									'ssdcsTabIndex' : $scope.ssdcsTabIndex,
									'ssdcsDataTypeDetail' : $scope.paymentType
								},
								target : $scope.frameId,
								method : 'POST'
							});
							//$scope.frameSrc = url;
						} else {
							$scope.ssdcsErrorMethod({isDigestRequired:false});
						}		
					} else {
						$scope.ssdcsErrorMethod({isDigestRequired:false});
					}
				},
				function(response){
					$scope.ssdcsErrorMethod({isDigestRequired:false});
				}
			);
		};	
		$scope._setSsdcsAutoSubmitAttr();
		$scope.$watch("reInitPadss",function(newValue){
			if(newValue && newValue == 'Y'){
				//handle based on payment type (Credit Card or Store Value Card)
				if(($scope.paymentType.PaymentTypeGroup === 'CREDIT_CARD' || $scope.paymentMethod.PaymentTypeGroup === 'CREDIT_CARD')
				|| ($scope.paymentType.PaymentTypeGroup === 'STORED_VALUE_CARD' || $scope.paymentMethod.PaymentTypeGroup === 'STORED_VALUE_CARD')){
					if(!$scope.ssdcsTabIndex){
						$scope.ssdcsTabIndex = "0";
					}
					if(!$scope.ssdcsDisplayValue){
						$scope.ssdcsDisplayValue = "";
					}
					if(!$scope.ssdcsToken){
						$scope.ssdcsToken = "";
					}
					iscHttpRequest.submitForm({
						url : iscAppInfo.getApplicationContext()+ "/scuiimpl/padssInitializer.do",
						params : {
							'ssdcsDataType' :  $scope.ssdcsDataType,
							'ssdcsDisplayValue' : $scope.ssdcsDisplayValue,
							'ssdcsCssUrl' : $scope.ssdcsCssUrl,
							'ssdcsToken' : $scope.ssdcsToken,
							'ssdcsAutoSubmit' : $scope.ssdcsAutoSubmit,
							'ssdcsTabIndex' : $scope.ssdcsTabIndex,
							'ssdcsDataTypeDetail' : $scope.paymentType,
							'reInit' : 'true'
						},
						target : $scope.frameId,
						method : 'POST'
					});
				}
			}
			$scope.reInitPadss = 'N';
		});
		
	}],
	templateUrl: './shared/payment/padss/templates/padss.tpl.html',
	link : function(scope, element, attributes, ctrl){
		var url = iscAppInfo.getApplicationContext()+ "/scuiimpl/padssInitializer.do";
		var padssIframe = window.frames[scope.frameId];
		if(!padssIframe){
			padssIframe = window.frames["{{frameId}}"];
			padssIframe.name = scope.frameId;
			padssIframe.id = scope.frameId;
		}
		scope._isAlive(url);
	}
    
  };
}]);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp.  2015, 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/

/**
 * @ngdoc directive
 * @name iscPaymentCapture
 *
 * @description
 * Used to capture a payment method for a specific payment type. 
 *
 * @example
 * <isc-payment-capture customer="{'CustomerID':model.getCompleteOrderDetails.Order.BillToID}" 
 * remaining-amount="ui.remainingAmount" payment-currency="model.getCompleteOrderDetails.Order.PriceInfo.Currency" 
 * action-clicked="ui.actionClicked" ng-if="ui.initcomplete" payment-identifier="'paymentMethodNew_'+$index" 
 * payment-type-list="model.getPaymentTypeList.PaymentTypeList.PaymentType" payment-method="newPaymentMethod" mode="'add'" 
 * currency-list="model.getCurrencyList" payment-card-type-list="model.getPaymentCardTypeList" rule-details-name="model.getRuleDetails_CCName" 
 * rule-details-real-time-auth="model.getRulesDetails_ReatTimeAuth"  
 * country-list="model.getCountryList.CommonCodeList.CommonCode" encrypt-enabled="ui.encryptEnabled" re-init-padss="ui.reInitPadss" 
 * billing-address-list="model.getCompleteOrderDetails.Order.ShippingAddressList" is-refund-mode="'N'" unique-id-suffix="ordercapture_paymentnew">
 * </isc-payment-capture>
 *
 * @param {String} customer Id for relevant object like Order.
 * @param {Object} remainingAmount object to bind and track the remaining amount pending from the parent screen/directive.
 * @param {String} paymentCurrency for currency identifier of the reference entity like Order currency for Order entity.
 * @param {Object} actionClicked object to use actions performed from parent screen/directive to control show/hide of input fields along with performing validations. 
 * @param {String} paymentIdentifier which will identify a specific instance of the directive. 
 * @param {Object} paymentTypeList model Object which has the list of payment types. 
 * @param {Object} paymentMethod model object to bind the directive input values to. 
 * @param {String} mode of payment capture. Supports values 'add' and 'edit'. 
 * @param {Object} currencyList model Object which has the list of currencies. 
 * @param {Object} paymentCardTypeList model Object which has the list of payment card types/credit card types. 
 * @param {Object} ruleDetailsName object for rule definition of Rule 'WSC_STORE_USE_CREDIT_CARD_NAME'. 
 * @param {Object} ruleDetailsRealTimeAuth object for rule definition of Rule 'WSC_STORE_REAL_TIME_AUTHORIZATION'. 
 * @param {Object} countryList model Object which has the list of countries. 
 * @param {Object} encrypt-enabled model object to enable credit card field encryption.
 * @param {Object} reInitPadss object to enable re-initialization of the PADSS field by controlling the object value from parent directive/screen.
 * @param {Object} billingAddressList model Object which has the list of Shipping Addresses on Order to select from, for the Billing address on Payment. 
 * @param {String} isRefundMode which determines if the payment capture is being used for refund or not (valid values 'Y' or 'N'). 
 * @param {String} uniqueIdSuffix string which will be used as suffix for all id values in input fields to keep the id unique in a screen with repeating payment capture panels.
 *
 */

angular.module('isc.shared').directive('iscPaymentCapture', ['iscModal', 'iscWizard', 'iscI18n', 'iscObjectUtility', 'iscPaymentinput', 'iscPayment', 'iscPaymentInputTemplate', 
  	function(iscModal, iscWizard, iscI18n, iscObjectUtility, iscPaymentinput, iscPayment, iscPaymentInputTemplate) {
  return {
  
		scope: {
		  paymentTypeList: '=',
          paymentMethod:'=',
          mode:'=',
          currencyList:'=',
          paymentCardTypeList:'=',
          ruleDetailsName:'=',
          ruleDetailsRealTimeAuth:'=',
          ssdcsup:'=?',
          countryList:'=',
          reInitPadss : '=',
          billingAddressList : '=',
          paymentIdentifier:'=',
          actionClicked:'=',
          paymentCurrency:'=',
          remainingAmount:'=',
          customer:'=?',
          focusInAmountField:'=?',
          encryptEnabled:'=',
          isRefundMode:'=?',
          uniqueIdSuffix:'='
		},
  
      controller:['$scope', '$rootScope', '$filter', 'iscModal', 'iscMashup', 'iscObjectUtility', 'iscPaymentinput', 'iscPayment', function($scope, $rootScope, $filter, iscModal, iscMashup, iscObjectUtility, iscPaymentinput, iscPayment){
      	$scope.styleTheme = $rootScope.ui.theme;
      	if(iscObjectUtility.isEmpty($scope.styleTheme)){
      		$scope.styleTheme = 'default';
      	}
      	if(!$scope.isRefundMode){
      		$scope.isRefundMode = 'N';
      	}
      	if(!$scope.uniqueIdSuffix){
      		$scope.uniqueIdSuffix = 'pc';
      	}
      	if(!$scope.ssdcsup){
      		$scope.ssdcsup = {ServerStaus:'Y'};
      	}
      	$scope.multiAddressMode = false;
      	if($scope.focusInAmountField == undefined){
      		$scope.focusInAmountField = false;
      	}
      	if($scope.encryptEnabled == undefined){
      		$scope.encryptEnabled = false;
      	}
      	if(!$scope.paymentCurrency){
      		$scope.paymentCurrency = "USD";
      	}
      	if(!$scope.customer){
      		$scope.customer = {};
      	}
      	if(!$scope.actionClicked){
      		$scope.actionClicked = '';
      	}
      	if(!$scope.paymentIdentifier){
      		if($scope.mode == 'edit'){
      			$scope.paymentIdentifier = 'paymentMethodOld';
      		}
      		else{
      			$scope.paymentIdentifier = 'paymentMethodNew';
      		}
      	}
      	if($scope.isRefundMode == 'Y'){
      		if($scope.paymentType && $scope.paymentType.NoProcessingRequired && $scope.paymentType.NoProcessingRequired === 'Y'){
      			$scope.paymentMethod.NoProcessingRequired = "Y";
      		}
      		else {
	      		$scope.paymentMethod.NoProcessingRequired = "N";
	      	}
      	}
      	else {
      		if($scope.paymentType && $scope.paymentType.NoProcessingRequired && $scope.paymentType.NoProcessingRequired === 'Y'){
	      		$scope.paymentMethod.Operation = "Collect";
	      		$scope.paymentMethod.NoProcessingRequired = "Y";
	      	}
	      	else {
	      		$scope.paymentMethod.NoProcessingRequired = "N";
	      	}
      	}
      	if(!$scope.paymentMethod.DetailView){
      		if($scope.mode == 'add'){
      			$scope.paymentMethod.DetailView = 'Y';
      		}
      		else if($scope.paymentMethod.IncompletePaymentType === 'Y'){
      			$scope.paymentMethod.DetailView = 'Y';
      		}
      		else{
      			$scope.paymentMethod.DetailView = 'N';
      		}
      	}
      	if($scope.isRefundMode == 'Y' && $scope.mode === 'edit' && iscPayment.isPaymentExpired($scope.paymentMethod, $scope.encryptEnabled)){
	      	$scope.paymentMethod.DetailView = 'Y';
      	}
		 	
      	$scope.addressIdentifier = $scope.paymentIdentifier + 'address';
		$scope.displayTemplateUrl = "";
		if($scope.paymentMethod && $scope.paymentMethod.PaymentType && $scope.mode == 'edit'){
			$scope.paymentType = {};
			for(var j = 0; j < $scope.paymentTypeList.length; j++){
				var paymentType = $scope.paymentTypeList[j].PaymentType;
				if($scope.paymentMethod.PaymentType === paymentType){
					$scope.paymentType = $scope.paymentTypeList[j];
				}
			}
			if($scope.paymentMethod.CreditCardType){
				for(var k = 0; k < $scope.paymentCardTypeList.PaymentCardTypeList.PaymentCardType.length; k++){
					var paymentCardType = $scope.paymentCardTypeList.PaymentCardTypeList.PaymentCardType[k].PaymentCardType;
					if($scope.paymentMethod.CreditCardType === paymentCardType){
						$scope.paymentMethod.CardType = $scope.paymentCardTypeList.PaymentCardTypeList.PaymentCardType[k];
					}
				}
			}
			if($scope.isRefundMode == 'Y'){
				$scope.paymentMethod.RequestedAmount = iscPayment.calculatePlannedRefundAmountToDisplay($scope.paymentMethod);
			}
			else {
				$scope.paymentMethod.RequestedAmount = $scope.paymentMethod.MaxChargeLimit;
			}
		}
		$scope.paymentMethod.DisplayRequestedAmount = $filter('iscCurrency')(angular.copy($scope.paymentMethod.RequestedAmount),$scope.paymentCurrency);
		if(!$scope.paymentType && $scope.paymentMethod.PaymentType){
		    $scope.paymentType = $scope.paymentMethod.PaymentType;
		}
		if($scope.paymentMethod && !$scope.paymentMethod.PersonInfoBillTo){
			$scope.paymentMethod.PersonInfoBillTo = {};
			$scope.originalPersonInfoBillTo = angular.copy($scope.paymentMethod.PersonInfoBillTo);
		}
		else {
			$scope.originalPersonInfoBillTo = angular.copy($scope.paymentMethod.PersonInfoBillTo);
		}
		if($scope.mode === 'edit' || $scope.paymentMethod.IncompletePaymentType != 'Y'){
			var bundleKey = "payment.LABEL_CaptureTo";
			if($scope.isRefundMode == 'Y'){ 
				bundleKey = "payment.LABEL_RefundTo";
			}
			if($scope.paymentMethod.PaymentTypeGroup === 'CREDIT_CARD'){
				var creditCardType = iscPayment.getPaymentCardTypeDescription($scope.paymentMethod.CreditCardType, $scope.paymentCardTypeList.PaymentCardTypeList);
				//newPayment.PaymentDescription = creditCardType + ' - ' + paymentAccNo;
				var paymentCardTypeDescription = iscI18n.translate("payment.LABEL_CreditCardDescription",{cardType:creditCardType,paymentType:$scope.paymentType.PaymentTypeDescription});
				$scope.paymentDescription = iscI18n.translate(bundleKey,{paymentType:paymentCardTypeDescription,paymentAccNo:$scope.paymentMethod.DisplayPrimaryAccountNo});
			}
			else {
				//newPayment.PaymentDescription = paymentTypeDescription + ' - ' + paymentAccNo;
				$scope.paymentDescription = iscI18n.translate(bundleKey,{paymentType:$scope.paymentType.PaymentTypeDescription,paymentAccNo:$scope.paymentMethod.DisplayPrimaryAccountNo});
			}
			var bundle2Key = "payment.LABEL_MessageCaptureTo";
			if($scope.isRefundMode == 'Y'){ 
				bundle2Key = "payment.LABEL_MessageRefundTo";
			}
			$scope.paymentTitleMessage = iscI18n.translate(bundle2Key);
		}
		else {
			var bundle2Key = "payment.LABEL_MessageCaptureTo";
			if($scope.isRefundMode == 'Y'){ 
				bundle2Key = "payment.LABEL_MessageRefundTo";
			}
			$scope.paymentTitleMessage = iscI18n.translate(bundle2Key);
		}
		$scope.$watch("paymentType",function(newValue){
			$scope.ssdcsup = {ServerStaus:'Y'};
			$scope.actionClicked = '';
			if($scope.paymentMethodForm && $scope.paymentMethodForm.$$parentForm){
				$scope.paymentMethodForm.$$parentForm.$submitted = false;
			}
			if($scope.isRefundMode == 'Y'){
	      		if($scope.paymentType && $scope.paymentType.NoProcessingRequired && $scope.paymentType.NoProcessingRequired === 'Y'){
	      			$scope.paymentMethod.NoProcessingRequired = "Y";
	      		}
	      		else {
		      		$scope.paymentMethod.NoProcessingRequired = "N";
		      	}
	      	}
	      	else {
	      		if($scope.paymentType && $scope.paymentType.NoProcessingRequired && $scope.paymentType.NoProcessingRequired === 'Y'){
		      		$scope.paymentMethod.Operation = "Collect";
		      		$scope.paymentMethod.NoProcessingRequired = "Y";
		      	}
		      	else {
		      		$scope.paymentMethod.NoProcessingRequired = "N";
		      	}
	      	}
			$scope.displayTemplateUrl = iscPaymentInputTemplate.getTemplateForPaymentType($scope.paymentType);
			$scope.paymentMethod.PaymentType = $scope.paymentType.PaymentType;
			$scope.paymentMethod.PaymentTypeGroup = $scope.paymentType.PaymentTypeGroup;
			if($scope.mode === 'add'){
				delete $scope.paymentMethod.FundsAvailable;
			}
		});
		$scope.ssdcsErrorMethod = function(isDigestRequired){
			if($scope.paymentMethod.PaymentTypeGroup === 'CREDIT_CARD' || $scope.paymentMethod.PaymentTypeGroup === 'STORED_VALUE_CARD'){
				$scope.ssdcsup.ServerStaus = 'N';
			}
			else {
				$scope.ssdcsup.ServerStaus = 'Y';
			}
			if(isDigestRequired){
				$rootScope.$digest();
			}
		};
		$scope.updateSecurityCodeInWizardModel = function(){
			var secureAuthCodeMap = iscWizard.getWizardModel("secureAuthCodeMap");
			if(!secureAuthCodeMap){
				secureAuthCodeMap = [];
			}
			var paymentKey = $scope.paymentMethod.PaymentKey;
			if(paymentKey){
				secureAuthCodeMap[paymentKey] = $scope.paymentMethod.SecureAuthenticationCode;
			}
			iscWizard.setWizardModel("secureAuthCodeMap", secureAuthCodeMap);
		};
		if($scope.paymentMethod.SecureAuthenticationCode){
			$scope.updateSecurityCodeInWizardModel();
		}
		else {
			var secureAuthCodeMap = iscWizard.getWizardModel("secureAuthCodeMap");
			if(secureAuthCodeMap){
				var paymentKey = $scope.paymentMethod.PaymentKey;
				if(paymentKey && secureAuthCodeMap[paymentKey]){
					$scope.paymentMethod.SecureAuthenticationCode = secureAuthCodeMap[paymentKey];
				}
			}
		}
		$scope.$watch("paymentMethod.CreditCardType",function(newValue){
			if($scope.paymentType.PaymentTypeGroup === 'CREDIT_CARD'){	
				for(var k = 0; k < $scope.paymentCardTypeList.PaymentCardTypeList.PaymentCardType.length; k++){
					var paymentCardType = $scope.paymentCardTypeList.PaymentCardTypeList.PaymentCardType[k].PaymentCardType;
					if($scope.paymentMethod.CreditCardType === paymentCardType){
						$scope.paymentMethod.CardType = $scope.paymentCardTypeList.PaymentCardTypeList.PaymentCardType[k];
					}
				}
        	}
		});
		$scope.$watch("paymentMethod.CreditCardNo",function(newValue){
			if($scope.paymentMethodForm && $scope.paymentMethodForm.paymentMethodForm_CreditCardNo){
				var ccNo = $scope.paymentMethod.CreditCardNo;
				if(ccNo && ccNo === "INVALID"){
					$scope.paymentMethodForm.paymentMethodForm_CreditCardNo.$setValidity("invalidNo",false);
				}
				else {
					$scope.paymentMethodForm.paymentMethodForm_CreditCardNo.$setValidity("invalidNo",true);
				}
			}
		});
		$scope.$watch("paymentMethod.SvcNo",function(newValue){
			if($scope.paymentMethodForm && $scope.paymentMethodForm.paymentMethodForm_SvcNo){
				var svcNo = $scope.paymentMethod.SvcNo;
				if(svcNo && svcNo === "INVALID"){
					$scope.paymentMethodForm.paymentMethodForm_SvcNo.$setValidity("invalidNo",false);
				}
				else {
					$scope.paymentMethodForm.paymentMethodForm_SvcNo.$setValidity("invalidNo",true);
				}
			}
		});
		$scope.$watch("paymentMethodForm.paymentMethodForm_amount_hidden.$valid",function(newValue){
			if($scope.paymentMethodForm.paymentMethodForm_amount){
				$scope.paymentMethodForm.paymentMethodForm_amount.$setValidity("",newValue);
			}
		});
		$scope.selectShippingAddress = function(arg){
			if($scope.paymentMethod.useShpAddressForBill === 'Y' && $scope.billingAddressList && $scope.billingAddressList.PersonInfo && $scope.billingAddressList.PersonInfo.length > 0){
				if($scope.billingAddressList.PersonInfo.length == 1){
					$scope.paymentMethod.PersonInfoBillTo = angular.copy($scope.billingAddressList.PersonInfo[0]);
			       // $scope.paymentMethod.BillToKey = $scope.billingAddressList.PersonInfo[0].PersonInfoKey;
				}
				else {
					$scope.paymentMethod.useShpAddressForBill = 'N'
					var modalInputObj = {};
		        	modalInputObj.HeaderTitle = 'payment.TITLE_BillingAddress';
		        	modalInputObj.BodyTitle = 'payment.TITLE_SelectBillingAddress';
		        	modalInputObj.PersonInfoList = $scope.billingAddressList;
		        	var addressListInput = {
		        			modalInput: function(){
		        				return modalInputObj;
		        			}
		        	};
		        	iscModal.openModal('store.views.common.address.addressselectionpopup',addressListInput,{})
						.then(function(callBackData){
							if(callBackData.PersonInfo.Selected){
								delete callBackData.PersonInfo.Selected;
							}
		        			$scope.paymentMethod.PersonInfoBillTo = angular.copy(callBackData.PersonInfo);
		        			$scope.paymentMethod.useShpAddressForBill = 'Y'
		        			//$scope.paymentMethod.BillToKey = callBackData.PersonInfo.PersonInfoKey;
		   				},
						angular.noop);
				}
			}
			
			if($scope.paymentMethod.useShpAddressForBill === 'N'){
				var newPersonInfo = {};
				newPersonInfo.Country = $scope.paymentMethod.PersonInfoBillTo.Country;
				//newPersonInfo.State = $scope.paymentMethod.PersonInfoBillTo.State;
				newPersonInfo.State = null;
				if($scope.originalPersonInfoBillTo && !iscObjectUtility.isEmpty($scope.originalPersonInfoBillTo)){
					$scope.paymentMethod.PersonInfoBillTo = angular.copy($scope.originalPersonInfoBillTo);
				}
				else {
					$scope.paymentMethod.PersonInfoBillTo = angular.copy(newPersonInfo);
				}
			}
		};
		$scope.updateAmountField = function(){
			$scope.focusInAmountField = false;
			$scope.paymentMethod.RequestedAmount = angular.copy($scope.paymentMethod.DisplayRequestedAmount);
			var valueEntered = angular.copy($scope.paymentMethod.DisplayRequestedAmount);
			var originalAmountBeforeChange = 0;
			var newAmountEntered = 0;
			var previousValueValid = $scope.originalAmountValidityBeforeOnFocus;
			if(previousValueValid){
				originalAmountBeforeChange = parseFloat($scope.originalAmountBeforeOnFocus);
			}			
			if(!$scope.paymentMethodForm.paymentMethodForm_amount_hidden.$valid && valueEntered != undefined && valueEntered !=""){
				$scope.paymentMethod.DisplayRequestedAmount = valueEntered;
				$scope.paymentMethod.RequestedAmount = valueEntered;
				$scope.paymentMethodForm.paymentMethodForm_amount.$setValidity("",false);
			}
			else {
				if(valueEntered){
					var groupingRegExp = new RegExp(",", "g");
					valueEntered = valueEntered.replace(groupingRegExp, "");
					newAmountEntered = parseFloat(valueEntered);
				}
				else {
					newAmountEntered = 0;
				}
				$scope.paymentMethodForm.paymentMethodForm_amount.$setValidity("",true);
				if(!iscObjectUtility.isStringVoid($scope.paymentMethod.RequestedAmount)){
					var groupingRegExp = new RegExp(",", "g");
					$scope.paymentMethod.RequestedAmount = $scope.paymentMethod.RequestedAmount.replace(groupingRegExp, "");
					$scope.paymentMethod.DisplayRequestedAmount = $filter('iscCurrency')(angular.copy($scope.paymentMethod.RequestedAmount),$scope.paymentCurrency);
				}
				else {
					$scope.paymentMethod.DisplayRequestedAmount = "";
				}
			}
			var change = (newAmountEntered - originalAmountBeforeChange).toFixed(2);
			var newRemainingAmount = (angular.copy($scope.remainingAmount) - change).toFixed(2);
			$scope.remainingAmount = parseFloat(newRemainingAmount);
			$scope.paymentMethodForm.paymentMethodForm_amount.$setUntouched();
			if($scope.paymentMethod.RequestedAmount){
				$scope.originalAmountBeforeOnFocus = angular.copy($scope.paymentMethod.RequestedAmount);
			}
			else {
				$scope.originalAmountBeforeOnFocus = 0;
			}
			$scope.originalAmountValidityBeforeOnFocus = $scope.paymentMethodForm.paymentMethodForm_amount_hidden.$valid;
		};
		$scope.onAmountFieldChange = function(){
			if($scope.focusInAmountField){
				$scope.paymentMethod.RequestedAmount = $scope.paymentMethod.DisplayRequestedAmount;
			}
		};
		$scope.deformatAmountField = function(){
			$scope.focusInAmountField = true;
			if($scope.paymentMethod.RequestedAmount){
				$scope.originalAmountBeforeOnFocus = angular.copy($scope.paymentMethod.RequestedAmount);
			}
			else {
				$scope.originalAmountBeforeOnFocus = 0;
			}
			$scope.originalAmountValidityBeforeOnFocus = $scope.paymentMethodForm.paymentMethodForm_amount_hidden.$valid;
			if(!iscObjectUtility.isStringVoid($scope.paymentMethod.RequestedAmount)){
				var originalAmount = angular.copy($scope.paymentMethod.RequestedAmount);
				$scope.paymentMethod.RequestedAmount = $scope.paymentMethod.DisplayRequestedAmount = originalAmount;
			}
			else {
				$scope.paymentMethod.DisplayRequestedAmount = $scope.paymentMethod.RequestedAmount = "";
			}
			$scope.paymentMethodForm.paymentMethodForm_amount.$setTouched();
		};
		
		 $scope.$on('AddressVerified',function(event,args){
			if(args.identifier && args.identifier === $scope.addressIdentifier){
			 	$scope.formScope = args.formScope;
			 	if (args){
				    if($scope.formScope && $scope.formScope.addressCapture && $scope.formScope.addressCapture.$invalid){
						console.log("screen in error");
						$scope.paymentMethod.PersonInfoBillTo = angular.copy(args.data);
						$scope.multiAddressMode = false;
					}else if(args.State == "SINGLE_ADDRESS"){
						console.log("single address verified");
						$scope.paymentMethod.PersonInfoBillTo = angular.copy(args.data);
						$scope.multiAddressMode = false;
					}else if (args.State == "MULTI_ADDRESS"){
						//$scope.billingAddressList = null; //Temp fix since edit mode is hidden in address capture in this case
						$scope.multiAddressMode = true;
						if(!$scope.enteredPersonInfoBillTo){
							$scope.enteredPersonInfoBillTo = angular.copy($scope.paymentMethod.PersonInfoBillTo);
						}
						$scope.paymentMethod.PersonInfoBillTo = angular.copy(args.data); 
						$scope.paymentMethod.PersonInfoBillTo.AddressVerifyRequired = 'N';
					} else if(args.State == "MODIFY_ADDRESS"){
						if($scope.enteredPersonInfoBillTo){
							$scope.paymentMethod.PersonInfoBillTo = angular.copy($scope.enteredPersonInfoBillTo); 
							$scope.enteredPersonInfoBillTo = null;
						}
						else {
							$scope.paymentMethod.PersonInfoBillTo = angular.copy(args.data); 
						}
						$scope.paymentMethod.PersonInfoBillTo.AddressVerifyRequired = 'Y';
						$scope.multiAddressMode = false;
					}
				}
			}
		 });
		 $scope.validateExpirationDate = function(){
		 	if($scope.mode === 'edit' && $scope.encryptEnabled && $scope.paymentMethod.CreditCardExpDate && $scope.paymentMethod.CreditCardExpDate === "**/**"){
		 		$scope.paymentMethodForm.paymentMethodForm_ccexpdate.$setValidity("pastDate", true);
		 		$scope.paymentMethodForm.paymentMethodForm_ccexpdate.$setValidity("validMonth", true);
		 		$scope.paymentMethodForm.paymentMethodForm_ccexpdate.$setValidity("pattern", true);
		 	}
		 	else {
		 		iscPayment.validateExpirationDate($scope.paymentMethod.CreditCardExpDate, $scope.paymentMethodForm.paymentMethodForm_ccexpdate);
		 	}
		 };
		 $scope.isPaymentAuthorizedOrCharged = function(paymentMethod){
		 	return iscPayment.isPaymentMethodAuthorizedOrCharged(paymentMethod);
		 };
		 $scope.getFundsAvaialble = function(){
		 	delete $scope.paymentMethod.FundsAvailable;
		 	var mashupInput = {};
		 	if($scope.paymentType.ChargeUpToAvailable === 'Y'){
		 		mashupInput.InvokeUE = {};
		 		mashupInput.InvokeUE.XMLData = {};
		 		mashupInput.InvokeUE.XMLData.PaymentMethod = iscPaymentinput.prepareGetFundsAvailableUEInput($scope.paymentMethod);
				iscMashup.callSimpleMashup($scope,"wsc_payment_getFundsAvailableUE", mashupInput,{}).then($scope.successHandler.bind($scope),$scope.failureHandler.bind($scope));
		 	}
		 	else if($scope.paymentMethod.PaymentTypeGroup === 'CUSTOMER_ACCOUNT'){
		 		if(!$scope.customer.CustomerID){
				 	iscModal.showErrorMessage(iscI18n.translate('payment.ERROR_GETTING_FUNDS_AVAILABLE_NO_CUSTOMER'));
				 }
				 else{
				 	mashupInput.Customer = {};
		 			mashupInput.Customer.CustomerID = $scope.customer.CustomerID;
					iscMashup.callSimpleMashup($scope,"wsc_payment_getCustomerAccountBalance", mashupInput,{}).then($scope.successHandler.bind($scope),$scope.failureHandler.bind($scope));
				 }
		 		
		 	}
		 };
		 $scope.successHandler = function(response){
		 
		 	var mashupRefs = response.MashupRefs.MashupRef;
		 	for(i=0;mashupRefs[i];i++){
				if(mashupRefs[i].mashupId){
					var mashupId = mashupRefs[i].mashupId;
					if(mashupId == "wsc_payment_getFundsAvailableUE"){
				    	$scope.processFundsAvaialbleUECallSuccess(mashupRefs[i]);
					}
					else if(mashupId == "wsc_payment_getCustomerAccountBalance"){
				    	$scope.processCustAccountBalanceCallSuccess(mashupRefs[i]);
					}
				}
			}
		};
		$scope.failureHandler = function(response){
		 
		  iscModal.showErrorMessage(iscI18n.translate('payment.ERROR_GETTING_FUNDS_AVAILABLE'));
		};
		$scope.processFundsAvaialbleUECallSuccess = function(mashupRefObj){
			 var paymentMethod = mashupRefObj.Output.InvokeUE.XMLData.PaymentMethod;
			 var fundsAvailable = paymentMethod.FundsAvailable;
			 if(fundsAvailable){
			 	$scope.paymentMethod.FundsAvailable = fundsAvailable;
			 }
			 else {
			 	iscModal.showErrorMessage(iscI18n.translate('payment.ERROR_GETTING_FUNDS_AVAILABLE_UE_ERROR'));
			 }
		};
		$scope.processCustAccountBalanceCallSuccess = function(mashupRefObj){
			var custAcctFound = false;
			 var custPaymentMethodList = mashupRefObj.Output.Customer.CustomerPaymentMethodList;
			 if(custPaymentMethodList && custPaymentMethodList.CustomerPaymentMethod && custPaymentMethodList.CustomerPaymentMethod.length > 0){
			 	var custPaymentMethods = custPaymentMethodList.CustomerPaymentMethod;
		 		for(i=0;custPaymentMethods[i];i++){
		 			var custPaymentMethod = custPaymentMethods[i];
		 			var custPaymentMethodPaymentType = custPaymentMethod.PaymentType;
		 			var custPaymentMethodPaymentTypeGroup = custPaymentMethod.PaymentTypeGroup;
		 			var custPaymentMethodPrimaryAccountNo = custPaymentMethod.PrimaryAccountNo;
		 			if((custPaymentMethodPaymentTypeGroup && custPaymentMethodPaymentTypeGroup === $scope.paymentType.PaymentTypeGroup)
		 				&& (custPaymentMethodPaymentType && custPaymentMethodPaymentType === $scope.paymentType.PaymentType)
		 				&& (custPaymentMethodPrimaryAccountNo && custPaymentMethodPrimaryAccountNo === $scope.paymentMethod.CustomerAccountNo)
		 				){
		 				var fundsAvailable = custPaymentMethod.AvailableAccountBalance;
						if(fundsAvailable){
							custAcctFound = true;
							$scope.paymentMethod.FundsAvailable = fundsAvailable;
							break;
						}
		 			}
		 			
		 		}
			 }
			 if(!custAcctFound){
			 	iscModal.showErrorMessage(iscI18n.translate('payment.ERROR_GETTING_FUNDS_AVAILABLE_NO_CUST_ACCOUNT'));
			 }
		};
		$scope.paymentMethod.expandPaymentMethodDetails = function(){
			$scope.paymentMethod.DetailView = 'Y';
		};
		$scope.paymentMethod.collapsePaymentMethodDetails = function(){
			 $scope.$broadcast('$validate');
		     if($scope.paymentMethodForm.$invalid) {
		     	$scope.paymentMethodForm.$dirty = true;
		     	$scope.paymentMethodForm.$touched = true;
        
				for(i in $scope.paymentMethodForm) {
					if($scope.paymentMethodForm[i] && $scope.paymentMethodForm[i].hasOwnProperty && $scope.paymentMethodForm[i].hasOwnProperty('$touched')) {
						$scope.paymentMethodForm[i].$touched = true;
					}
				}
		     }
		    else {
		    	if($scope.mode === 'add' || 'Y' === $scope.paymentMethod.IncompletePaymentType){
		    		var bundleKey = "payment.LABEL_CaptureTo";
					if($scope.isRefundMode == 'Y'){ 
						bundleKey = "payment.LABEL_RefundTo";
					}
					var displayAccNo = $scope.paymentMethod.DisplayPrimaryAccountNo ? $scope.paymentMethod.DisplayPrimaryAccountNo : iscPayment.getDisplayAccountNo($scope.paymentMethod);
					if($scope.paymentMethod.PaymentTypeGroup === 'CREDIT_CARD'){
						var creditCardType = iscPayment.getPaymentCardTypeDescription($scope.paymentMethod.CreditCardType, $scope.paymentCardTypeList.PaymentCardTypeList);
						//newPayment.PaymentDescription = creditCardType + ' - ' + paymentAccNo;
						var paymentCardTypeDescription = iscI18n.translate("payment.LABEL_CreditCardDescription",{cardType:creditCardType,paymentType:$scope.paymentType.PaymentTypeDescription});
						$scope.paymentDescription = iscI18n.translate(bundleKey,{paymentType:paymentCardTypeDescription,paymentAccNo:displayAccNo});
					}
					else {
						//newPayment.PaymentDescription = paymentTypeDescription + ' - ' + paymentAccNo;
						$scope.paymentDescription = iscI18n.translate(bundleKey,{paymentType:$scope.paymentType.PaymentTypeDescription,paymentAccNo:displayAccNo});
					}
		    	}
		    	$scope.paymentMethod.DetailView = 'N';
		    }
		}; 
		$scope.uiValidatorForCardNo = function(validationResponseObj, angularErrorObj, modelValue, viewValue) {
			console.log("validator", validationResponseObj, angularErrorObj, modelValue, viewValue);
			if (angularErrorObj.invalidNo) {
				validationResponseObj.booleanResponse = false;
				validationResponseObj.errorMesssage = iscI18n.translate('payment.InvalidCardNoErrorMsg');
			}
			return validationResponseObj;
		}; 
		$scope.uiValidatorForExpDate = function(validationResponseObj, angularErrorObj, modelValue, viewValue) {
			console.log("validator", validationResponseObj, angularErrorObj, modelValue, viewValue);
			if($scope.mode === 'edit' && $scope.encryptEnabled && viewValue && viewValue === "**/**"){
		 		$scope.paymentMethodForm.paymentMethodForm_ccexpdate.$setValidity("pastDate", true);
		 		$scope.paymentMethodForm.paymentMethodForm_ccexpdate.$setValidity("validMonth", true);
		 		$scope.paymentMethodForm.paymentMethodForm_ccexpdate.$setValidity("expdatepattern", true);
		 	}
		 	else {
		 		iscPayment.validateExpirationDate(viewValue, $scope.paymentMethodForm.paymentMethodForm_ccexpdate);
		 	}
			if (angularErrorObj.expdatepattern) {
				validationResponseObj.booleanResponse = false;
				validationResponseObj.errorMesssage = iscI18n.translate('payment.ERRORMSG_InvalidExpiryDate');
			}
			else if (angularErrorObj.pastDate) {
				validationResponseObj.booleanResponse = false;
				validationResponseObj.errorMesssage = iscI18n.translate('payment.ERRORMSG_PastExpiryDate');
			}
			else if (angularErrorObj.validMonth) {
				validationResponseObj.booleanResponse = false;
				validationResponseObj.errorMesssage = iscI18n.translate('payment.ERRORMSG_InvalidMonth');
			}
			return validationResponseObj;
		}; 
		$scope.isAmountFieldMandatory = function(){
			if($scope.paymentType.PaymentType){
				var paymentType = $scope.paymentType.PaymentType;
				if(paymentType === 'CHECK' || paymentType === 'REFUND_CHECK' || paymentType === 'PRE_PAID'){
					return true;
				}
				else {
					return false;
				}
			}
			return false;
		};
		$scope.uiIsModeEdit = function(){
			return $scope.mode === 'edit';
		};
		$scope.isEmptyPayment = $scope.mode === 'add' || $scope.paymentMethod.IncompletePaymentType === 'Y';
		$scope.isPaymentInRefundMode = $scope.isRefundMode == 'Y';
		
	}],
	 templateUrl:'./shared/payment/payment-capture/templates/payment-capture.tpl.html'
  };
}]);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp.  2015, 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/

/**
 * @ngdoc directive
 * @name iscPaymentList
 *
 * @description
 * Used to display a list of payment types. 
 *
 * @example
 * <isc-payment-list payment-type-list="model.paymentTypeList" payment-method="model.selectedPaymentMethod">
 * </isc-payment-list>
 * 
 * @param {Object} paymentTypeList model Object which has the list of payment types. 
 * @param {Object} paymentMethod model object to bind the directive input values to. 
 *
 */

angular.module('isc.shared').directive('iscPaymentList', ['iscObjectUtility', 
  	function(iscObjectUtility) {
	
	var uId = 1;
	
  return {
	  
		scope: {
		  paymentTypeList: '=',
		  paymentMethod: '='
		},
  
      controller:['$scope','$rootScope','iscObjectUtility', function($scope, $rootScope, iscObjectUtility){
    	  
    	  
    	$scope.paymentType = {"PaymentTypeDescription": ""};
      	$scope.styleTheme = $rootScope.ui.theme;
      	
      	$scope.showPaymentMethodDetailView = "N";
  		if(iscObjectUtility.isEmpty($scope.styleTheme)){
      		$scope.styleTheme = 'default';
      	}
      	
		$scope.$watch("paymentType",function(newValue){
				$scope.paymentMethod = {};
				$scope.displayTemplateUrl = $scope.getTemplateForPaymentType($scope.paymentType);
				$scope.paymentMethod.PaymentType = $scope.paymentType.PaymentType;
				$scope.showPaymentMethodDetailView = "Y";
				
		});
		
		$scope.$watch("paymentMethod.DisplayCreditCardNo",function(newValue, oldValue){
			
			var onlyDigitsRegEx = /^\d+$/;
			
			if(!iscCore.isVoid(newValue) && (newValue.length > 4 || !onlyDigitsRegEx.test(newValue))) {       
				 $scope.paymentMethod.DisplayCreditCardNo = oldValue;
			}

		});
		
		$scope.$watch("paymentMethod.DisplayCustomerAccountNo",function(newValue, oldValue){
			if(!iscCore.isVoid(newValue) && newValue.length > 4) {       
			    $scope.paymentMethod.DisplayCustomerAccountNo = oldValue;
			  }
		});
		
		
		$scope.getTemplateForPaymentType = function(paymentType) {
			var capturePaymentTemaplatesForPaymentType = {
				'CHECK' : './shared/payment/payment-list/templates/payment-list-check.tpl.html',
				'REFUND_CHECK' : './shared/payment/payment-list/templates/payment-list-check.tpl.html',
				'PRE_PAID' : './shared/payment/payment-list/templates/payment-list-prepaid.tpl.html'
			};
			var capturePaymentTemaplatesForPaymentTypeGroup = {
				'CREDIT_CARD' : './shared/payment/payment-list/templates/payment-list-cc.tpl.html',
				'CUSTOMER_ACCOUNT' : './shared/payment/payment-list/templates/payment-list-cacc.tpl.html',
				'STORED_VALUE_CARD' : './shared/payment/payment-list/templates/payment-list-svc.tpl.html',
				'OTHER' : './shared/payment/payment-list/templates/payment-list-other.tpl.html'
			};
			var paymentTypeGroup = paymentType.PaymentTypeGroup;
			var paymentType = paymentType.PaymentType;
			if(capturePaymentTemaplatesForPaymentType[paymentType]){
				return capturePaymentTemaplatesForPaymentType[paymentType];
			} else if (capturePaymentTemaplatesForPaymentTypeGroup[paymentTypeGroup]){
				return capturePaymentTemaplatesForPaymentTypeGroup[paymentTypeGroup];
			}
			else {
				return null;
			}
		};
		
				
	}],
	 templateUrl:'./shared/payment/payment-list/templates/payment-list.tpl.html',
	 link: function(scope, elem, attrs) {
         scope.uId = uId++;
     }
  };
}]);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp. 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/


/**
 * @ngdoc directive
 * @name iscShipmentOrderBarcodeScanner
 * @restrict E
 *
 * @description
 * Searches for Outbound Shipments when a Shipment Number or Order Number is scanned
 *
 * @scope
 * @param {String=} action - Action.
 * @param {String=} stopEnterEventProp - To stop enter event propogation in barcode panel.
 * @param {String=} displaySearch - Whether search with barcode scanning required. 
 * @param {String=} onTranslation - Callback handler function to be executed on getting the tranlation result.
 * @example
 *  The HTML will have the directive specified like below:
 *   <div>
 *       <isc-shipment-order-barcode-scanner action="pick" stop-enter-event-prop="Y" display-search="Y"  
			on-translation="ui.handleBarcodeOrSearchOutput(translationOutput);" ></isc-shipment-order-barcode-scanner>
 *   </div>
 */

(function(iscCore){
    
    angular.module("isc.shared").directive("iscShipmentOrderBarcodeScanner",[function(){
        
        return {
            restrict: 'E',
            templateUrl:'./shared/shipment/shipment-order-barcode-scanner/shipment-order-barcode-scanner.tpl.html',
            scope:{
                action:"@?",
				inputClass:"@?",
                stopEnterEventProp:'@?',
                displaySearch:'@?',
                onTranslation:"&"
            },
            link:function($scope, $element, $attr, ctrl, $transclude){
                
            },
            controller:["$scope", "iscScreen", "iscMashup", "iscResourcePermission","$filter", "iscModal", "iscI18n","iscState", "$timeout", "iscDomUtility",function($scope, iscScreen, iscMashup, iscResourcePermission, $filter, iscModal, iscI18n,iscState, $timeout, iscDomUtility){
				
				$scope.model={
					"scanInput":{}
                };
                
                $scope.uiScanBarCodeData = function(seachType, eventArg){
					if (!iscCore.isVoid($scope.model.scanInput.value)) {
						if(seachType == 'SCAN'){
							var translateBarCodeApiInput = {BarCode:{BarCodeData:$scope.model.scanInput.value,ActionInvoked:$scope.action}};
							iscMashup.callSimpleMashup($scope,"shared.shipment.outboundShipment.translateBarCodeForOutboundShipment", translateBarCodeApiInput,{}).then($scope.processBarCodeTranslation.bind($scope),angular.noop);
						}else{
							var searchShipmentInput = {Shipment:{ShipmentNo:$scope.model.scanInput.value,ActionInvoked:$scope.action}};
							iscMashup.callSimpleMashup($scope,"shared.shipment.outboundShipment.getOutboundShipmentListByShipmentOrOrderNo", searchShipmentInput,{}).then($scope.processBarCodeSearch.bind($scope),angular.noop);
						}
						$scope.model.scanInput.value = "";
					} else {
						iscModal.showErrorMessage(iscI18n.translate('shipmentorderbarcode.MSG_InvalidBarCodeData'));
					}
					if (eventArg != null && $scope.stopEnterEventProp && $scope.stopEnterEventProp == 'Y') {
						eventArg.preventDefault();
						eventArg.stopPropagation();
					}
				};

				$scope.processBarCodeTranslation = function(response){
					var numberOfOutboundShipments = 0,shipments = "", barCodeTranslatedEntity = "", barCodeTranslatedValue = "";
					var apiOutput = $scope.getOutputByMashupId(response,"shared.shipment.outboundShipment.translateBarCodeForOutboundShipment");

					if(!iscCore.isVoid(apiOutput) && !iscCore.isVoid(apiOutput.BarCode.Shipments) && !iscCore.isVoid(apiOutput.BarCode.Shipments.TotalNumberOfRecords)) {
						barCodeTranslatedEntity = apiOutput.BarCode.BarCodeTranslatedEntity;
						barCodeTranslatedValue = apiOutput.BarCode.BarCodeTranslatedValue;
						numberOfOutboundShipments = $filter('number')(apiOutput.BarCode.Shipments.TotalNumberOfRecords);
						shipments = {Shipments:apiOutput.BarCode.Shipments};
					}
					
					$scope.handleFinalOutput(numberOfOutboundShipments, shipments, barCodeTranslatedEntity, barCodeTranslatedValue);
				};

				$scope.processBarCodeSearch = function(response){
					var numberOfOutboundShipments = 0,shipments = "", barCodeTranslatedEntity = "", barCodeTranslatedValue = "";
					var apiOutput = $scope.getOutputByMashupId(response,"shared.shipment.outboundShipment.getOutboundShipmentListByShipmentOrOrderNo");

					if(!iscCore.isVoid(apiOutput) && !iscCore.isVoid(apiOutput.Shipments) && !iscCore.isVoid(apiOutput.Shipments.TotalNumberOfRecords)) {
						barCodeTranslatedEntity = apiOutput.Shipments.SearchSource;
						barCodeTranslatedValue = apiOutput.Shipments.SearchSourceValue;
						numberOfOutboundShipments = $filter('number')(apiOutput.Shipments.TotalNumberOfRecords);
						shipments = {Shipments:apiOutput.Shipments};
					}
					
					$scope.handleFinalOutput(numberOfOutboundShipments, shipments, barCodeTranslatedEntity, barCodeTranslatedValue);
				};

				$scope.handleFinalOutput = function(numberOfOutboundShipments, shipments, barCodeTranslatedEntity, barCodeTranslatedValue){
					$scope.onTranslation({translationOutput:{"numberOfOutboundShipments":numberOfOutboundShipments, "Shipments":shipments.Shipments, "barCodeTranslatedEntity":barCodeTranslatedEntity, "barCodeTranslatedValue":barCodeTranslatedValue}});
				};

				$scope.getOutputByMashupId = function(response, requiredMashupId) {
									    	 
					 var output = "";
					 var mashupRefs = response.MashupRefs.MashupRef;
					 for(var i=0;mashupRefs[i];i++){
						 if(mashupRefs[i].mashupId){
							  var mashupId = mashupRefs[i].mashupId;
							  if(mashupId == requiredMashupId){
								  output =	mashupRefs[i].Output;
								  break;
							  }
						  }
					  }
						  
					return output;
					 
				 };

            }]
        }
 
    }]);
    
})(window.iscCore);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10)
 * (C) Copyright IBM Corp.  2015, 2016 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
/*
	This decorator is not documented under JSDoc documentation because it is not directly used by the customer.
	'uibAccordionGroupDirective' is decorated to add feature to scroll to the accordion group when the accordion panel is opened
*/
angular.module('ui.bootstrap.accordion').config(['$provide',function($provide) {
  $provide.decorator('uibAccordionGroupDirective',['$delegate',"$timeout", function($delegate,$timeout) {
    var directive = $delegate[0];
    

    directive.compile = function() {		

			return function(scope, element, attrs, accordionCtrl, transclude) {
			
				accordionCtrl.addGroup(scope);

				scope.openClass = attrs.openClass || 'panel-open';
				scope.panelClass = attrs.panelClass;
				scope.$watch('isOpen', function(value) {
					element.toggleClass(scope.openClass, !!value);
					if (value) {
						accordionCtrl.closeOthers(scope);
						$timeout(function() {
								element[0].parentElement.parentElement.parentElement.scrollTop = element[0].offsetTop;
						}, 10);                
					}
				});

				scope.toggleOpen = function($event) {
					if (!scope.isDisabled) {
						if (!$event || $event.which === 32) {
							scope.isOpen = !scope.isOpen;
						}
					}
				};
			};
    };
	
    return $delegate;
  }]);
}]);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp.  2015, 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
/*
	This decorator is not documented under JSDoc documentation because it is not directly used by the customer.
	'uibTabsetDirective' internally uses 'uibTabDirective' to close a tab that is open already.
	'select' function of the out-of-the-box 'uibTab' directive is modified by this decorator. 
	If a tab is opened by clicking the link associated with it, tabset's active property is set to the index of the tab that is clicked.
	If the link for the tab is clicked again (when it is already open),tabset's active property is set to null. Hence the tab will close.
*/
angular.module('ui.bootstrap.tabs').config(['$provide',function($provide) {
  $provide.decorator('uibTabDirective',['$delegate', function($delegate) {
    var directive = $delegate[0];
    var compile = directive.compile;

    directive.compile = function() {
		var link = compile.apply(this, arguments); 

		return function(scope, elm, attrs, tabsetCtrl, transclude) {
			link.apply(this, arguments);
			if(tabsetCtrl && tabsetCtrl.closable) {
				scope.select = function() {
					if (!scope.disabled && scope.$parent.$parent.tabset.active != scope.index) {
						scope.$parent.$parent.tabset.active = scope.index;
						return;
					}
					if(!scope.disabled && scope.$parent.$parent.tabset.active == scope.index ) scope.$parent.$parent.tabset.active = null;
				};
			}
		};
    };
	
    return $delegate;
  }]);
}]);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp.  2015, 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
/**
 * @ngdoc decorator
 * @name uibTabsetDirective
 * @restrict EA
 *
 * @description
 * Customises the 'uibTabset' directive provided by Angular bootstrap (ui.bootstrap.tabs.uibTabset).
 * Angular bootstrap 'uibTabset' directive does not provide a way to close any of the tabs inside the tabset once it is clicked and opened.
 * 
 * Hence a new boolean attribute called 'closable' is provided for a uibTabset.
 * If 'closable' is set to true, then on click of a tab that is already open, the tab will be closed. 
 *
 * @example
 * <uib-tabset justified="true" class="cart-additional-info display-tabs fixed-tab" closable=true>
 * 	<uib-tab>
 * 		<tab-heading>
 * 			<span class="btn-icon-font app-glyphicons app-icon-idCustomer_30"></span>
 *	 	</tab-heading>
 * 		<div class="cart-additional-action"  
 *			 ng-include="'./store/views/order/view-cart/view-cart-customer-pnl.tpl.html'">
 *		</div>
 *	</uib-tab>
 * </uib-tabset>
 */
angular.module('ui.bootstrap.tabs').config(['$provide',function($provide) {
	$provide.decorator('uibTabsetDirective',['$delegate', function($delegate) {
		var directive = $delegate[0];
		var compile = directive.compile;
		var link = compile.apply(this, arguments);
		
		directive.compile = function() {
			return {
				pre: function(scope, elm, attrs,tabsetCtrl) {
					if(attrs && attrs.closable) {
						tabsetCtrl.closable = angular.isDefined(attrs.closable) ? scope.$parent.$eval(attrs.closable) : false;
						elm.addClass('closable');
					}
				},
				post: function(scope, elm, attrs,tabsetCtrl) {
					link.apply(this, arguments);
					scope.$watch("tabset.active", function(newValue, oldValue) {
						if(newValue != null && newValue >= 0) {
							if(!elm.hasClass('has-active-tab'))
								elm.addClass('has-active-tab');
						} else {
							if(elm.hasClass('has-active-tab'))
								elm.removeClass('has-active-tab');
						}
					});
				}
			}
		}
		
		return $delegate;
	}]);
}]);

/*******************************************************************************
 * IBM Confidential
 * OCO Source Materials
 * IBM Sterling Order Management Store (5725-D10), IBM Order Management (5737-D18), IBM Store Engagement (5737D58)
 * (C) Copyright IBM Corp. 2015, 2017 All Rights Reserved.
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 ******************************************************************************/
/* This file contains the list of all template HTML overrides to the templates present in ui-bootstrap-tpls.js which is shipped as part of
angular-bootstrap module */

(function (angular) {
	'use strict';
	
	// Added aria-labelledby for dialog role and role = main
	angular.module("template/modal/window.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/modal/window.html",
		"<div modal-render=\"{{$isRendered}}\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"modalTitle\" class=\"modal\"\n" +
		"    uib-modal-animation-class=\"fade\"\n" +
		"    modal-in-class=\"in\"\n" +
		"    ng-style=\"{'z-index': 1050 + index*10, display: 'block'}\">\n" +
		"    <div class=\"modal-dialog\" ng-class=\"size ? 'modal-' + size : ''\"><div class=\"modal-content\" role=\"main\" uib-modal-transclude></div></div>\n" +
		"</div>\n" +
		"");
	}]);
	
	// Added role, aria-label and aria-live for the div
	angular.module("template/alert/alert.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/alert/alert.html",
		"<div class=\"alert\" role=\"region\" aria-label=\"Alert Message\" ng-class=\"['alert-' + (type || 'warning'), closeable ? 'alert-dismissible' : null]\">\n" +
		"    <button ng-show=\"closeable\" type=\"button\" class=\"close\" ng-click=\"close({$event: $event})\">\n" +
		"        <span aria-hidden=\"true\">&times;</span>\n" +
		"        <span class=\"sr-only\">Close</span>\n" +
		"    </button>\n" +
		"    <div ng-transclude role=\"alert\" aria-live=\"assertive\"></div>\n" +
		"</div>\n" +
		"");
	}]);
	
	//As of now, we are using the bootstrap theme for the select widget. Hence overriding the template files of that theme.
	// Added role = group for the input tag
	angular.module("ui.select").run(["$templateCache", function($templateCache) {
		$templateCache.put("bootstrap/select.tpl.html","<div class=\"ui-select-container ui-select-bootstrap dropdown\" ng-class=\"{open: $select.open}\"><div class=\"ui-select-match\"></div><input type=\"text\" role=\"group\" autocomplete=\"false\" tabindex=\"-1\" aria-expanded=\"true\" aria-label=\"{{ $select.baseTitle }}\" aria-owns=\"ui-select-choices-{{ $select.generatedId }}\" aria-activedescendant=\"ui-select-choices-row-{{ $select.generatedId }}-{{ $select.activeIndex }}\" class=\"form-control ui-select-search\" placeholder=\"{{$select.placeholder}}\" ng-model=\"$select.search\" ng-show=\"$select.searchEnabled && $select.open\"><div class=\"ui-select-choices\"></div></div>");
	}]);
	
	// Added an sr-only span for the link to fix DAP violation that link should have text or image with alt
	// Removed the ng-click for the <i> tag
	angular.module("ui.select").run(["$templateCache", function($templateCache) {
		$templateCache.put("bootstrap/match.tpl.html","<div class=\"ui-select-match\" ng-hide=\"$select.open\" ng-disabled=\"$select.disabled\" ng-class=\"{\'btn-default-focus\':$select.focus}\"><span tabindex=\"-1\" class=\"btn btn-default form-control ui-select-toggle\" aria-label=\"{{ $select.baseTitle }} activate\" ng-disabled=\"$select.disabled\" ng-click=\"$select.activate()\" style=\"outline: 0;\"><span ng-show=\"$select.isEmpty()\" class=\"ui-select-placeholder text-muted\">{{$select.placeholder}}</span> <span ng-hide=\"$select.isEmpty()\" class=\"ui-select-match-text pull-left\" ng-class=\"{\'ui-select-allow-clear\': $select.allowClear && !$select.isEmpty()}\" ng-transclude=\"\"></span> <i class=\"caret pull-right\"></i> <a ng-show=\"$select.allowClear && !$select.isEmpty()\" aria-label=\"{{ $select.baseTitle }} clear\" style=\"margin-right: 10px\" ng-click=\"$select.clear($event)\" class=\"btn btn-xs btn-link pull-right\"><i class=\"glyphicon glyphicon-remove\" aria-hidden=\"true\"></i><span class=\"sr-only\">{{ $select.baseTitle }} clear</span></a></span></div>");
	}]);
	
	// Added aria-label for ul
	angular.module("ui.select").run(["$templateCache", function($templateCache) {
		$templateCache.put("bootstrap/choices.tpl.html","<ul class=\"ui-select-choices ui-select-choices-content ui-select-dropdown dropdown-menu\" role=\"listbox\" ng-show=\"$select.items.length > 0\" aria-label=\"Select one of the options\"><li class=\"ui-select-choices-group\" id=\"ui-select-choices-{{ $select.generatedId }}\"><div class=\"divider\" ng-show=\"$select.isGrouped && $index > 0\"></div><div ng-show=\"$select.isGrouped\" class=\"ui-select-choices-group-label dropdown-header\" ng-bind=\"$group.name\"></div><div id=\"ui-select-choices-row-{{ $select.generatedId }}-{{$index}}\" class=\"ui-select-choices-row\" ng-class=\"{active: $select.isActive(this), disabled: $select.isDisabled(this)}\" role=\"option\"><a href=\"javascript:void(0)\" class=\"ui-select-choices-row-inner\"></a></div></li></ul>");
	}]);
	
	// Moved the <ol> tag above the transclude div to show the carousel slider above
	angular.module("template/carousel/carousel.html", []).run(["$templateCache", function($templateCache) {
	  $templateCache.put("template/carousel/carousel.html",
		"<div ng-mouseenter=\"pause()\" ng-mouseleave=\"play()\" class=\"carousel\" ng-swipe-right=\"prev()\" ng-swipe-left=\"next()\">\n" +
		"  <a role=\"button\" href class=\"left carousel-control\" ng-click=\"prev()\" ng-show=\"slides.length > 1\">\n" +
		"    <span aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-left\"></span>\n" +
		"    <span class=\"sr-only\">previous</span>\n" +
		"  </a>\n" +
		"  <a role=\"button\" href class=\"right carousel-control\" ng-click=\"next()\" ng-show=\"slides.length > 1\">\n" +
		"    <span aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-right\"></span>\n" +
		"    <span class=\"sr-only\">next</span>\n" +
		"  </a>\n" +
		"  <ol class=\"carousel-indicators\" ng-show=\"slides.length > 1\">\n" +
		"    <li ng-repeat=\"slide in slides | orderBy:indexOfSlide track by $index\" ng-class=\"{ active: isActive(slide) }\" ng-click=\"select(slide)\">\n" +
		"      <span class=\"sr-only\">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if=\"isActive(slide)\">, currently active</span></span>\n" +
		"    </li>\n" +
		"  </ol>\n" +
		"  <div class=\"carousel-inner\" ng-transclude></div>\n" +
		"</div>");
	}]);
    
    
    angular.module("uib/template/carousel/carousel.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("uib/template/carousel/carousel.html",
        "<div class=\"carousel-inner\" ng-transclude ng-swipe-right=\"prev()\" ng-swipe-left=\"next()\"></div>\n" +
        "<a role=\"button\" href class=\"left carousel-control\" ng-click=\"prev()\" ng-class=\"{ disabled: isPrevDisabled() }\" ng-show=\"slides.length > 1\">\n" +
        "  <span aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-left\"></span>\n" +
        "  <span class=\"sr-only\">previous</span>\n" +
        "</a>\n" +
        "<a role=\"button\" href class=\"right carousel-control\" ng-click=\"next()\" ng-class=\"{ disabled: isNextDisabled() }\" ng-show=\"slides.length > 1\">\n" +
        "  <span aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-right\"></span>\n" +
        "  <span class=\"sr-only\">next</span>\n" +
        "</a>\n" +
        "<ol class=\"carousel-indicators\" ng-show=\"slides.length > 1\">\n" +
        "  <li ng-repeat=\"slide in slides | orderBy:indexOfSlide track by $index\" ng-class=\"{ active: isActive(slide) }\" ng-click=\"select(slide)\">\n" +
        "    <span class=\"sr-only\">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if=\"isActive(slide)\">, currently active</span></span>\n" +
        "  </li>\n" +
        "</ol>\n" +
        "");
    }]);

	
})(window.angular);